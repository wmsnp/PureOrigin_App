// Generated by dart2js (NullSafetyMode.sound, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.7.2.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_7", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, A, C, F, E, G,
  B = {
    DataPage$() {
      return new B.DataPage(null);
    },
    __DataPageState_State_TickerProviderStateMixin_dispose_closure: function __DataPageState_State_TickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    DataPage: function DataPage(t0) {
      this.key = t0;
    },
    _DataPageState: function _DataPageState(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _._types = t0;
      _._typeLabels = t1;
      _._data_page$_records = t2;
      _._loading = false;
      _._hasMore = true;
      _._data_page$_skip = 0;
      _.___DataPageState__filterType_AI = $;
      _._searchKeyword = "";
      _.___DataPageState_hdm_FI = $;
      _._sC = t3;
      _.___DataPageState__tC_FI = $;
      _.TickerProviderStateMixin__tickers = t4;
      _.TickerProviderStateMixin__tickerModeNotifier = t5;
      _._widget = null;
      _._debugLifecycleState = t6;
      _._framework$_element = null;
    },
    _DataPageState_initState_closure: function _DataPageState_initState_closure(t0) {
      this.$this = t0;
    },
    _DataPageState_initState_closure0: function _DataPageState_initState_closure0(t0) {
      this.$this = t0;
    },
    _DataPageState_initState__closure: function _DataPageState_initState__closure(t0) {
      this.$this = t0;
    },
    _DataPageState__loadMore_closure: function _DataPageState__loadMore_closure(t0) {
      this.$this = t0;
    },
    _DataPageState__loadMore_closure0: function _DataPageState__loadMore_closure0(t0) {
      this.$this = t0;
    },
    _DataPageState__loadMore_closure1: function _DataPageState__loadMore_closure1(t0) {
      this.$this = t0;
    },
    _DataPageState__refresh_closure: function _DataPageState__refresh_closure(t0) {
      this.$this = t0;
    },
    _DataPageState__refreshRecord_closure: function _DataPageState__refreshRecord_closure(t0, t1, t2) {
      this.$this = t0;
      this.record = t1;
      this.newData = t2;
    },
    _DataPageState__refreshRecord__closure: function _DataPageState__refreshRecord__closure(t0) {
      this.record = t0;
    },
    _DataPageState__buildRecordRow_closure: function _DataPageState__buildRecordRow_closure() {
    },
    _DataPageState__buildRecordRow_closure0: function _DataPageState__buildRecordRow_closure0() {
    },
    _DataPageState__buildRecordRow_closure1: function _DataPageState__buildRecordRow_closure1(t0, t1) {
      this.$this = t0;
      this.record = t1;
    },
    _DataPageState__buildRecordRow__closure: function _DataPageState__buildRecordRow__closure(t0, t1) {
      this.$this = t0;
      this.record = t1;
    },
    _DataPageState_build_closure: function _DataPageState_build_closure() {
    },
    _DataPageState_build_closure0: function _DataPageState_build_closure0(t0) {
      this.$this = t0;
    },
    _DataPageState_build_closure1: function _DataPageState_build_closure1(t0) {
      this.$this = t0;
    },
    __DataPageState_State_TickerProviderStateMixin: function __DataPageState_State_TickerProviderStateMixin() {
    },
    _RefreshProgressIndicatorPainter: function _RefreshProgressIndicatorPainter(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15) {
      var _ = this;
      _.arrowheadScale = t0;
      _.trackColor = t1;
      _.valueColor = t2;
      _.value = t3;
      _.headValue = t4;
      _.tailValue = t5;
      _.offsetValue = t6;
      _.rotationValue = t7;
      _.strokeWidth = t8;
      _.strokeAlign = t9;
      _.arcStart = t10;
      _.arcSweep = t11;
      _.strokeCap = t12;
      _.trackGap = t13;
      _.year2023 = t14;
      _._repaint = t15;
    },
    RefreshProgressIndicator: function RefreshProgressIndicator(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.elevation = t0;
      _.strokeWidth = t1;
      _.strokeAlign = t2;
      _.strokeCap = t3;
      _.value = t4;
      _.backgroundColor = t5;
      _.color = t6;
      _.valueColor = t7;
      _.semanticsLabel = t8;
      _.semanticsValue = t9;
      _.key = t10;
    },
    _RefreshProgressIndicatorState: function _RefreshProgressIndicatorState(t0, t1, t2) {
      var _ = this;
      _.___RefreshProgressIndicatorState__additionalRotationTween_FI = _.___RefreshProgressIndicatorState__convertTween_FI = $;
      _._progress_indicator$_lastValue = null;
      _.___CircularProgressIndicatorState__controller_A = $;
      _.SingleTickerProviderStateMixin__ticker = t0;
      _.SingleTickerProviderStateMixin__tickerModeNotifier = t1;
      _._widget = null;
      _._debugLifecycleState = t2;
      _._framework$_element = null;
    },
    _RefreshProgressIndicatorState__buildAnimation_closure: function _RefreshProgressIndicatorState__buildAnimation_closure(t0) {
      this.$this = t0;
    },
    RefreshIndicatorStatus: function RefreshIndicatorStatus(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    RefreshIndicatorTriggerMode: function RefreshIndicatorTriggerMode(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    _IndicatorType: function _IndicatorType(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    RefreshIndicator: function RefreshIndicator(t0, t1, t2) {
      this.child = t0;
      this.onRefresh = t1;
      this.key = t2;
    },
    RefreshIndicatorState: function RefreshIndicatorState(t0, t1, t2) {
      var _ = this;
      _.__RefreshIndicatorState__valueColor_A = _.__RefreshIndicatorState__value_A = _.__RefreshIndicatorState__scaleFactor_A = _.__RefreshIndicatorState__positionFactor_A = _.__RefreshIndicatorState__scaleController_A = _.__RefreshIndicatorState__positionController_A = $;
      _._dragOffset = _._isIndicatorAtTop = _._refresh_indicator$_status = null;
      _.__RefreshIndicatorState__effectiveValueColor_AI = $;
      _.TickerProviderStateMixin__tickers = t0;
      _.TickerProviderStateMixin__tickerModeNotifier = t1;
      _._widget = null;
      _._debugLifecycleState = t2;
      _._framework$_element = null;
    },
    RefreshIndicatorState__handleScrollNotification_closure: function RefreshIndicatorState__handleScrollNotification_closure(t0) {
      this.$this = t0;
    },
    RefreshIndicatorState__dismiss_closure: function RefreshIndicatorState__dismiss_closure(t0, t1) {
      this.$this = t0;
      this.newMode = t1;
    },
    RefreshIndicatorState__dismiss_closure0: function RefreshIndicatorState__dismiss_closure0(t0) {
      this.$this = t0;
    },
    RefreshIndicatorState__show_closure: function RefreshIndicatorState__show_closure(t0, t1) {
      this.$this = t0;
      this.completer = t1;
    },
    RefreshIndicatorState__show__closure: function RefreshIndicatorState__show__closure(t0) {
      this.$this = t0;
    },
    RefreshIndicatorState__show__closure0: function RefreshIndicatorState__show__closure0(t0, t1) {
      this.$this = t0;
      this.completer = t1;
    },
    RefreshIndicatorState_build_closure: function RefreshIndicatorState_build_closure(t0) {
      this.$this = t0;
    },
    RefreshIndicatorState_build_closure0: function RefreshIndicatorState_build_closure0(t0, t1) {
      this.$this = t0;
      this.showIndeterminateIndicator = t1;
    },
    _RefreshIndicatorState_State_TickerProviderStateMixin_dispose_closure: function _RefreshIndicatorState_State_TickerProviderStateMixin_dispose_closure(t0) {
      this.$this = t0;
    },
    _RefreshIndicatorState_State_TickerProviderStateMixin: function _RefreshIndicatorState_State_TickerProviderStateMixin() {
    },
    TabController: function TabController(t0, t1, t2, t3) {
      var _ = this;
      _._animationController = t0;
      _._animationDuration = t1;
      _.length = t2;
      _.ChangeNotifier__count = _._indexIsChangingCount = _._previousIndex = _._tab_controller$_index = 0;
      _.ChangeNotifier__listeners = t3;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _.ChangeNotifier__creationDispatched = _.ChangeNotifier__debugDisposed = false;
    },
    TabController__changeIndex_closure: function TabController__changeIndex_closure(t0) {
      this.$this = t0;
    },
    UnderlineTabIndicator: function UnderlineTabIndicator(t0, t1, t2) {
      this.borderRadius = t0;
      this.borderSide = t1;
      this.insets = t2;
    },
    _UnderlinePainter: function _UnderlinePainter(t0, t1, t2) {
      this.decoration = t0;
      this.borderRadius = t1;
      this.onChanged = t2;
    },
    _TabStyle$(animation, child, defaults, isPrimary, isSelected, labelColor, labelStyle, unselectedLabelColor, unselectedLabelStyle) {
      return new B._TabStyle(labelStyle, unselectedLabelStyle, isSelected, labelColor, unselectedLabelColor, defaults, child, animation, null);
    },
    _TabLabelBarRenderer$(crossAxisAlignment, direction, mainAxisAlignment, mainAxisSize, onPerformLayout, textDirection, verticalDirection) {
      var i, _null = null,
        t1 = A.LayerHandle$(type$.ClipRectLayer),
        _list = J.JSArray_JSArray$allocateFixed(4, type$.TextPainter);
      for (i = 0; i < 4; ++i)
        _list[i] = A.TextPainter$(_null, _null, _null, _null, _null, C.TextAlign_4, C.TextDirection_1, _null, C._LinearTextScaler_1, C.TextWidthBasis_0);
      t1 = new B._TabLabelBarRenderer(onPerformLayout, direction, mainAxisAlignment, mainAxisSize, crossAxisAlignment, textDirection, verticalDirection, _null, C.Clip_0, 0, t1, _list, true, 0, _null, _null, new A._LayoutCacheStorage(), A.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      t1.addAll$1(0, _null);
      return t1;
    },
    _indexChangeProgress(controller) {
      var previousIndex, currentIndex,
        t1 = controller.get$animation(0).__AnimationController__value_A;
      t1 === $ && A.throwLateFieldNI("_value");
      previousIndex = controller._previousIndex;
      currentIndex = controller._tab_controller$_index;
      if (controller._indexIsChangingCount === 0)
        return A.clampDouble(Math.abs(currentIndex - t1), 0, 1);
      return Math.abs(t1 - currentIndex) / Math.abs(currentIndex - previousIndex);
    },
    _TabsPrimaryDefaultsM3_indicatorWeight(indicatorSize) {
      var t1;
      switch (indicatorSize.index) {
        case 1:
          t1 = 3;
          break;
        case 0:
          t1 = 2;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    TabAlignment: function TabAlignment(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    TabIndicatorAnimation: function TabIndicatorAnimation(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    Tab: function Tab(t0, t1) {
      this.text = t0;
      this.key = t1;
    },
    _TabStyle: function _TabStyle(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.labelStyle = t0;
      _.unselectedLabelStyle = t1;
      _.isSelected = t2;
      _.labelColor = t3;
      _.unselectedLabelColor = t4;
      _.defaults = t5;
      _.child = t6;
      _.listenable = t7;
      _.key = t8;
    },
    _TabStyle__resolveWithLabelColor_closure: function _TabStyle__resolveWithLabelColor_closure(t0, t1) {
      this._box_0 = t0;
      this.animation = t1;
    },
    _TabLabelBarRenderer: function _TabLabelBarRenderer(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17) {
      var _ = this;
      _.onPerformLayout = t0;
      _._direction = t1;
      _._mainAxisAlignment = t2;
      _._mainAxisSize = t3;
      _._crossAxisAlignment = t4;
      _._flex$_textDirection = t5;
      _._verticalDirection = t6;
      _._textBaseline = t7;
      _._flex$_overflow = 0;
      _._flex$_clipBehavior = t8;
      _._spacing = t9;
      _._flex$_clipRectLayer = t10;
      _.DebugOverflowIndicatorMixin__indicatorLabel = t11;
      _.DebugOverflowIndicatorMixin__overflowReportNeeded = t12;
      _.ContainerRenderObjectMixin__childCount = t13;
      _.ContainerRenderObjectMixin__firstChild = t14;
      _.ContainerRenderObjectMixin__lastChild = t15;
      _._layoutCacheStorage = t16;
      _._computingThisDryBaseline = _._computingThisDryLayout = false;
      _._box$_size = null;
      _._debugActivePointers = 0;
      _._debugDisposed = false;
      _.parentData = null;
      _._depth = 0;
      _.debugCreator = _._object$_parent = null;
      _._debugDoingThisLayout = _._debugDoingThisResize = false;
      _._debugCanParentUseSize = null;
      _._debugMutationsLocked = false;
      _._object$_owner = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _._debugDoingThisPaint = false;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t17;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    _TabLabelBar: function _TabLabelBar(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10) {
      var _ = this;
      _.onPerformLayout = t0;
      _.direction = t1;
      _.mainAxisAlignment = t2;
      _.mainAxisSize = t3;
      _.crossAxisAlignment = t4;
      _.textDirection = t5;
      _.verticalDirection = t6;
      _.textBaseline = t7;
      _.spacing = t8;
      _.children = t9;
      _.key = t10;
    },
    _DividerPainter: function _DividerPainter(t0, t1, t2) {
      this.dividerColor = t0;
      this.dividerHeight = t1;
      this._repaint = t2;
    },
    _IndicatorPainter: function _IndicatorPainter(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _.controller = t0;
      _.indicator = t1;
      _.indicatorSize = t2;
      _.indicatorPadding = t3;
      _.tabKeys = t4;
      _.labelPaddings = t5;
      _.dividerColor = t6;
      _.dividerHeight = t7;
      _.showDivider = t8;
      _.devicePixelRatio = t9;
      _.indicatorAnimation = t10;
      _.textDirection = t11;
      _._tabs$_painter = _._currentRect = _._currentTextDirection = _._currentTabOffsets = null;
      _._tabs$_needsPaint = false;
      _._repaint = t12;
    },
    _ChangeAnimation: function _ChangeAnimation(t0) {
      this.controller = t0;
    },
    _DragAnimation: function _DragAnimation(t0, t1) {
      this.controller = t0;
      this.index = t1;
    },
    _TabBarScrollPosition: function _TabBarScrollPosition(t0, t1, t2, t3, t4, t5, t6, t7) {
      var _ = this;
      _.tabBar = t0;
      _._viewportDimensionWasNonZero = false;
      _._needsPixelsCorrection = true;
      _._heldPreviousVelocity = 0;
      _._userScrollDirection = t1;
      _._currentDrag = null;
      _.physics = t2;
      _.context = t3;
      _.keepScrollOffset = t4;
      _.debugLabel = t5;
      _._maxScrollExtent = _._minScrollExtent = null;
      _._impliedVelocity = 0;
      _._viewportDimension = _._pixels = null;
      _._haveDimensions = false;
      _._didChangeViewportDimensionOrReceiveCorrection = true;
      _._pendingDimensions = false;
      _._scroll_position$_lastMetrics = null;
      _._haveScheduledUpdateNotification = false;
      _._semanticActions = _._lastAxis = null;
      _.isScrollingNotifier = t6;
      _._activity = null;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t7;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _.ChangeNotifier__creationDispatched = _.ChangeNotifier__debugDisposed = false;
    },
    _TabBarScrollController: function _TabBarScrollController(t0, t1, t2, t3, t4) {
      var _ = this;
      _.tabBar = t0;
      _.onAttach = t1;
      _.onDetach = t2;
      _._positions = t3;
      _.ChangeNotifier__count = 0;
      _.ChangeNotifier__listeners = t4;
      _.ChangeNotifier__reentrantlyRemovedListeners = _.ChangeNotifier__notificationCallStackDepth = 0;
      _.ChangeNotifier__creationDispatched = _.ChangeNotifier__debugDisposed = false;
    },
    TabBar: function TabBar(t0, t1, t2, t3) {
      var _ = this;
      _.tabs = t0;
      _.controller = t1;
      _.isScrollable = t2;
      _.key = t3;
    },
    _TabBarState: function _TabBarState(t0) {
      var _ = this;
      _._currentIndex = _._indicatorPainter = _._tabs$_controller = _._tabs$_scrollController = null;
      _.___TabBarState__labelPaddings_A = _.___TabBarState__tabKeys_A = _.___TabBarState__tabStripWidth_A = $;
      _._debugHasScheduledValidTabsCountCheck = false;
      _._widget = null;
      _._debugLifecycleState = t0;
      _._framework$_element = null;
    },
    _TabBarState_initState_closure: function _TabBarState_initState_closure() {
    },
    _TabBarState__updateTabController_closure: function _TabBarState__updateTabController_closure(t0, t1) {
      this.$this = t0;
      this.newController = t1;
    },
    _TabBarState__handleTabControllerTick_closure: function _TabBarState__handleTabControllerTick_closure() {
    },
    _TabBarState__debugScheduleCheckHasValidTabsCount_closure: function _TabBarState__debugScheduleCheckHasValidTabsCount_closure(t0) {
      this.$this = t0;
    },
    _TabBarState__debugScheduleCheckHasValidTabsCount__closure: function _TabBarState__debugScheduleCheckHasValidTabsCount__closure(t0) {
      this.$this = t0;
    },
    _TabBarState__debugTabAlignmentIsValid_closure: function _TabBarState__debugTabAlignmentIsValid_closure(t0, t1) {
      this.$this = t0;
      this.tabAlignment = t1;
    },
    _TabBarState_build_closure: function _TabBarState_build_closure(t0, t1) {
      this.$this = t0;
      this.tabBarTheme = t1;
    },
    _TabBarState_build_closure0: function _TabBarState_build_closure0(t0, t1) {
      this.$this = t0;
      this.selectedState = t1;
    },
    _TabBarState_build_closure1: function _TabBarState_build_closure1(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    _TabsPrimaryDefaultsM3: function _TabsPrimaryDefaultsM3(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12, t13, t14, t15, t16, t17, t18) {
      var _ = this;
      _.context = t0;
      _.___TabsPrimaryDefaultsM3__textTheme_FI = _.___TabsPrimaryDefaultsM3__colors_FI = $;
      _.isScrollable = t1;
      _.indicator = t2;
      _.indicatorColor = t3;
      _.indicatorSize = t4;
      _.dividerColor = t5;
      _.dividerHeight = t6;
      _.labelColor = t7;
      _.labelPadding = t8;
      _.labelStyle = t9;
      _.unselectedLabelColor = t10;
      _.unselectedLabelStyle = t11;
      _.overlayColor = t12;
      _.splashFactory = t13;
      _.mouseCursor = t14;
      _.tabAlignment = t15;
      _.textScaler = t16;
      _.indicatorAnimation = t17;
      _.splashBorderRadius = t18;
    },
    _TabsPrimaryDefaultsM3_overlayColor_closure: function _TabsPrimaryDefaultsM3_overlayColor_closure(t0) {
      this.$this = t0;
    },
    __ChangeAnimation_Animation_AnimationWithParentMixin: function __ChangeAnimation_Animation_AnimationWithParentMixin() {
    },
    __DragAnimation_Animation_AnimationWithParentMixin: function __DragAnimation_Animation_AnimationWithParentMixin() {
    },
    TabBarTheme_of(context) {
      var t1;
      context.dependOnInheritedWidgetOfExactType$1$0(type$.TabBarTheme);
      t1 = A.Theme_of(context);
      return t1.tabBarTheme;
    }
  },
  D;
  J = holdersList[1];
  A = holdersList[0];
  C = holdersList[2];
  F = holdersList[14];
  E = holdersList[7];
  G = holdersList[10];
  B = hunkHelpers.updateHolder(holdersList[5], B);
  D = holdersList[15];
  B.DataPage.prototype = {
    createState$0() {
      var _null = null,
        t1 = type$.JSArray_String;
      return new B._DataPageState(A._setArrayType(["diet", "exercise", "sleep"], t1), A._setArrayType(["\u996e\u98df", "\u8fd0\u52a8", "\u7761\u7720"], t1), A._setArrayType([], type$.JSArray_Map_String_dynamic), A.ScrollController$(_null, _null), _null, _null, C._StateLifecycle_0);
    }
  };
  B._DataPageState.prototype = {
    get$hdm() {
      var t1, result,
        value = this.___DataPageState_hdm_FI;
      if (value === $) {
        $.$get$Get();
        t1 = $.GetInstance__getInstance;
        if (t1 == null)
          t1 = $.GetInstance__getInstance = C.C_GetInstance;
        result = t1.find$1$1$tag(0, null, type$.HealthDataController);
        this.___DataPageState_hdm_FI !== $ && A.throwLateFieldADI("hdm");
        this.___DataPageState_hdm_FI = result;
        value = result;
      }
      return value;
    },
    get$_tC() {
      var result, _this = this,
        value = _this.___DataPageState__tC_FI;
      if (value === $) {
        result = new B.TabController(A.AnimationController$unbounded(null, 0, _this), C.Duration_300000, 3, $.$get$ChangeNotifier__emptyListeners());
        A.ChangeNotifier_maybeDispatchObjectCreation(result);
        _this.___DataPageState__tC_FI !== $ && A.throwLateFieldADI("_tC");
        _this.___DataPageState__tC_FI = result;
        value = result;
      }
      return value;
    },
    initState$0() {
      var _this = this;
      _this.super$State$initState();
      _this._loadMore$0();
      _this._sC.addListener$1(0, new B._DataPageState_initState_closure(_this));
      _this.get$_tC().addListener$1(0, new B._DataPageState_initState_closure0(_this));
    },
    _loadMore$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$handler = 2, $async$errorStack = [], $async$next = [], $async$self = this, newRecords, filtered, e, t1, value, exception, $async$exception;
      var $async$_loadMore$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1) {
          $async$errorStack.push($async$result);
          $async$goto = $async$handler;
        }
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              if (!$async$self._hasMore || $async$self._loading) {
                // goto return
                $async$goto = 1;
                break;
              }
              $async$self.setState$1(new B._DataPageState__loadMore_closure($async$self));
              $async$handler = 4;
              t1 = $async$self.get$hdm();
              value = $async$self.___DataPageState__filterType_AI;
              if (value === $)
                value = $async$self.___DataPageState__filterType_AI = $async$self._types[0];
              $async$goto = 7;
              return A._asyncAwait(t1.getRecords$3$limit$skip(value, 20, $async$self._data_page$_skip), $async$_loadMore$0);
            case 7:
              // returning from await.
              newRecords = $async$result;
              t1 = J.where$1$ax(newRecords, new B._DataPageState__loadMore_closure0($async$self));
              filtered = A.List_List$of(t1, true, t1.$ti._eval$1("Iterable.E"));
              C.JSArray_methods.addAll$1($async$self._data_page$_records, filtered);
              $async$self._data_page$_skip = $async$self._data_page$_skip + J.get$length$asx(newRecords);
              if (J.get$length$asx(newRecords) < 20)
                $async$self._hasMore = false;
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 4:
              // catch
              $async$handler = 3;
              $async$exception = $async$errorStack.pop();
              e = A.unwrapException($async$exception);
              A.print__debugPrintThrottled$closure().call$1("\u83b7\u53d6\u8bb0\u5f55\u5931\u8d25: " + A.S(e));
              $async$next.push(6);
              // goto finally
              $async$goto = 5;
              break;
            case 3:
              // uncaught
              $async$next = [2];
            case 5:
              // finally
              $async$handler = 2;
              $async$self.setState$1(new B._DataPageState__loadMore_closure1($async$self));
              // goto the next finally handler
              $async$goto = $async$next.pop();
              break;
            case 6:
              // after finally
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
            case 2:
              // rethrow
              return A._asyncRethrow($async$errorStack.at(-1), $async$completer);
          }
      });
      return A._asyncStartSync($async$_loadMore$0, $async$completer);
    },
    _refresh$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this;
      var $async$_refresh$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$self.setState$1(new B._DataPageState__refresh_closure($async$self));
              $async$goto = 2;
              return A._asyncAwait($async$self._loadMore$0(), $async$_refresh$0);
            case 2:
              // returning from await.
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_refresh$0, $async$completer);
    },
    _refreshRecord$1(record) {
      return this._refreshRecord$body$_DataPageState(type$.Map_String_dynamic._as(record));
    },
    _refreshRecord$body$_DataPageState(record) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1, newData;
      var $async$_refreshRecord$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = J.getInterceptor$asx(record);
              $async$goto = 2;
              return A._asyncAwait($async$self.get$hdm().getRecord$2(A._asString(t1.$index(record, "_type")), A._asDouble(t1.$index(record, "created_at"))), $async$_refreshRecord$1);
            case 2:
              // returning from await.
              newData = $async$result;
              J.$indexSet$ax(newData, "_type", t1.$index(record, "_type"));
              $async$self.setState$1(new B._DataPageState__refreshRecord_closure($async$self, record, newData));
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_refreshRecord$1, $async$completer);
    },
    _buildRecordRow$1(record) {
      var t1, t2, coreInfo, icon, typeLabel, timeStr, _null = null, _s4_ = "data";
      type$.Map_String_dynamic._as(record);
      t1 = J.getInterceptor$asx(record);
      switch (t1.$index(record, "_type")) {
        case "diet":
          t2 = J.map$1$1$ax(type$.List_dynamic._as(J.$index$asx(t1.$index(record, _s4_), "items")), new B._DataPageState__buildRecordRow_closure(), type$.NutritionItem);
          coreInfo = "\u70ed\u91cf: " + C.JSNumber_methods.toStringAsFixed$1(C.JSArray_methods.fold$1$2(A.List_List$of(t2, true, t2.$ti._eval$1("ListIterable.E")), 0, new B._DataPageState__buildRecordRow_closure0(), type$.double), 0) + " kcal";
          icon = D.IconData_58674_MaterialIcons_null_false;
          typeLabel = "\u996e\u98df";
          break;
        case "exercise":
          t2 = t1.$index(record, _s4_);
          t2 = t2 == null ? _null : J.$index$asx(t2, "summary");
          coreInfo = A._asString(t2 == null ? "" : t2);
          icon = F.IconData_57820_MaterialIcons_null_false;
          typeLabel = "\u8fd0\u52a8";
          break;
        case "sleep":
          t2 = t1.$index(record, _s4_);
          t2 = t2 == null ? _null : J.$index$asx(t2, "duration");
          coreInfo = A._asString(t2 == null ? "" : t2);
          icon = D.IconData_57563_MaterialIcons_null_false;
          typeLabel = "\u7761\u7720";
          break;
        default:
          t2 = t1.$index(record, "_type");
          typeLabel = A._asString(t2 == null ? "" : t2);
          icon = D.IconData_58121_MaterialIcons_null_true;
          coreInfo = "";
      }
      t1 = t1.$index(record, "time_spec");
      t1 = A.DateTime_tryParse(A._asString(J.$add$ansx(t1 == null ? _null : J.$index$asx(t1, "start"), "Z")));
      timeStr = t1 == null ? _null : t1.toLocal$0();
      t1 = A.Icon$(icon, _null, _null, 28);
      t2 = A.Text$(typeLabel + "  " + A.S(timeStr), _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null);
      return E.ListTile$(t1, _null, new B._DataPageState__buildRecordRow_closure1(this, record), A.Text$(coreInfo, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null), t2);
    },
    build$1(context) {
      var _this = this, _null = null,
        t1 = _this.get$_tC(),
        t2 = _this._typeLabels,
        t3 = A._arrayInstanceType(t2),
        t4 = t3._eval$1("MappedListIterable<1,Tab>");
      t4 = A.List_List$of(new A.MappedListIterable(t2, t3._eval$1("Tab(1)")._as(new B._DataPageState_build_closure()), t4), true, t4._eval$1("ListIterable.E"));
      return A.Scaffold$(new B.TabBar(t4, t1, true, _null), _null, A.StyledList_toColumn(A._setArrayType([A.StyledWidget_padding(A.TextField$(true, C.List_empty, false, _null, true, _null, A.text_field0_TextField__defaultContextMenuBuilder$closure(), _null, _null, _null, D.InputDecoration_dYY, C.DragStartBehavior_1, true, _null, true, _null, false, _null, C.Type_EditableText_O5i, _null, _null, _null, _null, _null, _null, _null, 1, _null, _null, false, "\u2022", _null, new B._DataPageState_build_closure0(_this), _null, _null, _null, false, _null, false, _null, _null, C.EdgeInsets_20_20_20_20, _null, _null, _null, _null, _null, _null, _null, _null, true, C.TextAlign_4, _null, C.TextCapitalization_30, _null, _null, _null), _null, 12, 4), A.Expanded$(new B.RefreshIndicator(E.ListView$builder(_null, _this._sC, new B._DataPageState_build_closure1(_this), _this._data_page$_records.length + 1, _null, _null, C.Axis_1, false), _this.get$_refresh(), _null), 1, _null)], type$.JSArray_Widget), C.CrossAxisAlignment_2, C.MainAxisAlignment_0, C.MainAxisSize_1), _null);
    },
    dispose$0() {
      this._sC.dispose$0();
      this.get$_tC().dispose$0();
      this.super$__DataPageState_State_TickerProviderStateMixin$dispose();
    },
    $isTickerProvider: 1
  };
  B.__DataPageState_State_TickerProviderStateMixin.prototype = {
    activate$0() {
      this.super$State$activate();
      this._updateTickerModeNotifier$0();
      this._updateTickers$0();
    },
    dispose$0() {
      var t1, _this = this;
      A.assertHelper(new B.__DataPageState_State_TickerProviderStateMixin_dispose_closure(_this).call$0());
      t1 = _this.TickerProviderStateMixin__tickerModeNotifier;
      if (t1 != null)
        t1.removeListener$1(0, _this.get$_updateTickers());
      _this.set$_tickerModeNotifier(null);
      _this.super$State$dispose();
    },
    debugFillProperties$1(properties) {
      var t1, t2, t3, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null) {
        t2 = t1._collection$_length;
        t3 = t2 === 1 ? "" : "s";
        t3 = "tracking " + t2 + " ticker" + t3;
        t2 = t3;
      } else
        t2 = _null;
      properties.add$1(0, A.DiagnosticsProperty$("tickers", t1, true, _null, t2, false, _null, _null, C.DiagnosticLevel_3, _null, false, true, true, C.DiagnosticsTreeStyle_8, _null, type$.Set_Ticker));
    }
  };
  B._RefreshProgressIndicatorPainter.prototype = {
    paint$2(canvas, size) {
      var t1, arcEnd, ux, uy, t2, radius, arrowheadRadius, innerRadius, outerRadius, t3, path, paint, _this = this;
      _this.super$_CircularProgressIndicatorPainter$paint(canvas, size);
      t1 = _this.arrowheadScale;
      if (t1 > 0) {
        arcEnd = _this.arcStart + _this.arcSweep;
        ux = Math.cos(arcEnd);
        uy = Math.sin(arcEnd);
        t2 = size._dx;
        A.assertHelper(t2 === size._dy);
        radius = t2 / 2;
        t2 = _this.strokeWidth;
        arrowheadRadius = t2 * 2 * t1;
        innerRadius = radius - arrowheadRadius;
        outerRadius = radius + arrowheadRadius;
        t3 = $.$get$_renderer();
        path = t3.createPath$0();
        path.moveTo$2(0, radius + ux * innerRadius, radius + uy * innerRadius);
        path.lineTo$2(0, radius + ux * outerRadius, radius + uy * outerRadius);
        path.lineTo$2(0, radius + ux * radius + -uy * t2 * 2 * t1, radius + uy * radius + ux * t2 * 2 * t1);
        path.close$0(0);
        paint = t3.createPaint$0();
        paint.set$color(0, _this.valueColor);
        paint.set$strokeWidth(t2);
        paint.set$style(0, C.PaintingStyle_0);
        canvas.drawPath$2(path, paint);
      }
    }
  };
  B.RefreshProgressIndicator.prototype = {
    get$backgroundColor(_) {
      return A.CircularProgressIndicator.prototype.get$backgroundColor.call(this, 0);
    },
    createState$0() {
      return new B._RefreshProgressIndicatorState(null, null, C._StateLifecycle_0);
    }
  };
  B._RefreshProgressIndicatorState.prototype = {
    get$widget() {
      return type$.RefreshProgressIndicator._as(A.State.prototype.get$widget.call(this));
    },
    build$1(context) {
      var t1, value0, result, _this = this,
        value = type$.RefreshProgressIndicator._as(A.State.prototype.get$widget.call(_this)).value;
      if (value != null) {
        _this._progress_indicator$_lastValue = value;
        t1 = _this.___CircularProgressIndicatorState__controller_A;
        t1 === $ && A.throwLateFieldNI("_controller");
        value0 = _this.___RefreshProgressIndicatorState__convertTween_FI;
        if (value0 === $) {
          result = new A.CurveTween(D.Interval_uxr);
          value0 !== $ && A.throwLateFieldADI("_convertTween");
          _this.set$___RefreshProgressIndicatorState__convertTween_FI(result);
          value0 = result;
        }
        t1.set$value(0, value0.transform$1(0, value) * 0.000225022502250225);
      }
      return _this._buildAnimation$0();
    },
    _buildAnimation$0() {
      var t1 = this.___CircularProgressIndicatorState__controller_A;
      t1 === $ && A.throwLateFieldNI("_controller");
      return A.AnimatedBuilder$(t1, new B._RefreshProgressIndicatorState__buildAnimation_closure(this), null);
    },
    _buildMaterialIndicator$5(context, headValue, tailValue, offsetValue, rotationValue) {
      var rotation, value0, t3, t4, result, valueColor, opacity, indicatorTheme, backgroundColor, strokeWidth, strokeAlign, strokeCap, _this = this, _null = null,
        t1 = type$.RefreshProgressIndicator,
        value = t1._as(A.State.prototype.get$widget.call(_this)).value,
        t2 = value == null,
        arrowheadScale = t2 ? 0 : D.Interval_uxr.transform$1(0, value);
      if (t2 && _this._progress_indicator$_lastValue == null)
        rotation = 0;
      else {
        value0 = _this.___RefreshProgressIndicatorState__additionalRotationTween_FI;
        if (value0 === $) {
          t3 = type$.Tween_double;
          t4 = type$.TweenSequenceItem_double;
          result = A.TweenSequence$(A._setArrayType([new A.TweenSequenceItem(new A.Tween(-0.1, -0.2, t3), 0.33, t4), new A.TweenSequenceItem(new A.Tween(-0.2, 1.35, t3), 0.6699999999999999, t4)], type$.JSArray_TweenSequenceItem_double), type$.double);
          _this.___RefreshProgressIndicatorState__additionalRotationTween_FI !== $ && A.throwLateFieldADI("_additionalRotationTween");
          _this.set$___RefreshProgressIndicatorState__additionalRotationTween_FI(result);
          value0 = result;
        }
        if (t2) {
          t3 = _this._progress_indicator$_lastValue;
          t3.toString;
        } else
          t3 = value;
        rotation = 3.141592653589793 * value0.transform$1(0, t3);
      }
      valueColor = t1._as(A.State.prototype.get$widget.call(_this))._getValueColor$1(context);
      opacity = valueColor.get$opacity(valueColor);
      valueColor = valueColor.withOpacity$1(1);
      A.Theme_of(context);
      switch (true) {
        case true:
          t2 = A._CircularProgressIndicatorDefaultsM3Year2023$(context, t2);
          break;
        case false:
          t2 = A._CircularProgressIndicatorDefaultsM2$(context, t2);
          break;
        default:
          t2 = _null;
      }
      indicatorTheme = A.ProgressIndicatorTheme_of(context);
      t3 = t1._as(A.State.prototype.get$widget.call(_this));
      A.CircularProgressIndicator.prototype.get$backgroundColor.call(t3, 0);
      backgroundColor = indicatorTheme.refreshBackgroundColor;
      if (backgroundColor == null)
        backgroundColor = A.Theme_of(context).canvasColor;
      t3 = t1._as(A.State.prototype.get$widget.call(_this)).strokeWidth;
      strokeWidth = t3 == null ? indicatorTheme.strokeWidth : t3;
      if (strokeWidth == null)
        strokeWidth = t2.get$strokeWidth();
      t1._as(A.State.prototype.get$widget.call(_this));
      strokeAlign = indicatorTheme.strokeAlign;
      if (strokeAlign == null)
        strokeAlign = t2.get$strokeAlign();
      strokeCap = t1._as(A.State.prototype.get$widget.call(_this)).strokeCap;
      if (strokeCap == null)
        strokeCap = indicatorTheme.strokeCap;
      t2 = t1._as(A.State.prototype.get$widget.call(_this));
      t1._as(A.State.prototype.get$widget.call(_this));
      t3 = t1._as(A.State.prototype.get$widget.call(_this));
      t1._as(A.State.prototype.get$widget.call(_this));
      t1 = tailValue * 3 / 2 * 3.141592653589793;
      t4 = Math.max(headValue * 3 / 2 * 3.141592653589793 - t1, 0.001);
      return t2._buildSemanticsWrapper$2$child$context(new A.Padding(C.EdgeInsets_4_4_4_4, A.SizedBox$fromSize(A.Material$(C.Duration_200000, true, _null, new A.Padding(D.EdgeInsets_12_12_12_12, A.Opacity$(A.Transform$rotate(rotation, A.CustomPaint$(_null, _null, _null, new B._RefreshProgressIndicatorPainter(arrowheadScale, _null, valueColor, _null, headValue, tailValue, offsetValue, rotationValue, strokeWidth, strokeAlign, -1.5707963267948966 + t1 + rotationValue * 3.141592653589793 * 2 + offsetValue * 0.5 * 3.141592653589793, t4, strokeCap, _null, true, _null), C.Size_0_0)), opacity), _null), C.Clip_0, backgroundColor, t3.elevation, _null, _null, _null, _null, _null, C.MaterialType_2), D.Size_41_41), _null), context);
    },
    set$___RefreshProgressIndicatorState__convertTween_FI(___RefreshProgressIndicatorState__convertTween_FI) {
      this.___RefreshProgressIndicatorState__convertTween_FI = type$.Animatable_double._as(___RefreshProgressIndicatorState__convertTween_FI);
    },
    set$___RefreshProgressIndicatorState__additionalRotationTween_FI(___RefreshProgressIndicatorState__additionalRotationTween_FI) {
      this.___RefreshProgressIndicatorState__additionalRotationTween_FI = type$.Animatable_double._as(___RefreshProgressIndicatorState__additionalRotationTween_FI);
    }
  };
  B.RefreshIndicatorStatus.prototype = {
    _enumToString$0() {
      return "RefreshIndicatorStatus." + this._name;
    }
  };
  B.RefreshIndicatorTriggerMode.prototype = {
    _enumToString$0() {
      return "RefreshIndicatorTriggerMode." + this._name;
    }
  };
  B._IndicatorType.prototype = {
    _enumToString$0() {
      return "_IndicatorType." + this._name;
    }
  };
  B.RefreshIndicator.prototype = {
    createState$0() {
      return new B.RefreshIndicatorState(null, null, C._StateLifecycle_0);
    },
    onRefresh$0() {
      return this.onRefresh.call$0();
    },
    notificationPredicate$1(arg0) {
      return A.scroll_notification__defaultScrollNotificationPredicate$closure().call$1(arg0);
    }
  };
  B.RefreshIndicatorState.prototype = {
    get$_effectiveValueColor() {
      var t1, _this = this,
        value = _this.__RefreshIndicatorState__effectiveValueColor_AI;
      if (value === $) {
        _this._widget.toString;
        t1 = A.Theme_of(_this.get$context(0));
        value = _this.__RefreshIndicatorState__effectiveValueColor_AI = t1.colorScheme.primary;
      }
      return value;
    },
    initState$0() {
      var t1, t2, t3, _this = this, _null = null;
      _this.super$State$initState();
      t1 = A.AnimationController$(_null, _null, _null, _null, _this);
      _this.__RefreshIndicatorState__positionController_A = t1;
      t2 = type$.double;
      t3 = type$.Animation_double;
      _this.set$__RefreshIndicatorState__positionFactor_A(t3._as(t1.drive$1$1($.$get$RefreshIndicatorState__kDragSizeFactorLimitTween(), t2)));
      _this.set$__RefreshIndicatorState__value_A(t3._as(_this.__RefreshIndicatorState__positionController_A.drive$1$1($.$get$RefreshIndicatorState__threeQuarterTween(), t2)));
      t1 = A.AnimationController$(_null, _null, _null, _null, _this);
      _this.__RefreshIndicatorState__scaleController_A = t1;
      _this.set$__RefreshIndicatorState__scaleFactor_A(t3._as(t1.drive$1$1($.$get$RefreshIndicatorState__oneToZeroTween(), t2)));
    },
    didChangeDependencies$0() {
      this._setupColorTween$0();
      this.super$State$didChangeDependencies();
    },
    didUpdateWidget$1(oldWidget) {
      this.super$State$didUpdateWidget(type$.RefreshIndicator._as(oldWidget));
      this._widget.toString;
    },
    dispose$0() {
      var t1 = this.__RefreshIndicatorState__positionController_A;
      t1 === $ && A.throwLateFieldNI("_positionController");
      t1.dispose$0();
      t1 = this.__RefreshIndicatorState__scaleController_A;
      t1 === $ && A.throwLateFieldNI("_scaleController");
      t1.dispose$0();
      this.super$_RefreshIndicatorState_State_TickerProviderStateMixin$dispose();
    },
    _setupColorTween$0() {
      var t1, color, t2, t3, t4, _this = this;
      _this._widget.toString;
      t1 = A.Theme_of(_this.get$context(0));
      _this.__RefreshIndicatorState__effectiveValueColor_AI = t1.colorScheme.primary;
      color = _this.get$_effectiveValueColor();
      t1 = type$.Animation_nullable_Color;
      if (color.get$alpha(color) === 0)
        _this.set$__RefreshIndicatorState__valueColor_A(t1._as(new A.AlwaysStoppedAnimation(color, type$.AlwaysStoppedAnimation_Color)));
      else {
        t2 = _this.__RefreshIndicatorState__positionController_A;
        t2 === $ && A.throwLateFieldNI("_positionController");
        t3 = color.withAlpha$1(0);
        t4 = color.withAlpha$1(color.get$alpha(color));
        _this.set$__RefreshIndicatorState__valueColor_A(t1._as(t2.drive$1$1(new A._ChainedEvaluation(type$.Animatable_double._as(new A.CurveTween(G.Interval_Gs3)), new A.ColorTween(t3, t4), type$.ColorTween._eval$1("_ChainedEvaluation<Animatable.T>")), type$.nullable_Color)));
      }
    },
    _refresh_indicator$_handleScrollNotification$1(notification) {
      var t1, t2, _0_0, t3, _this = this;
      type$.ScrollNotification._as(notification);
      if (!A.boolConversionCheck(_this._widget.notificationPredicate$1(notification)))
        return false;
      t1 = notification instanceof A.ScrollStartNotification && notification.dragDetails != null;
      if (!t1)
        if (notification instanceof A.ScrollUpdateNotification)
          if (notification.dragDetails != null)
            _this._widget.toString;
      if (t1) {
        t1 = notification.metrics;
        t2 = t1.axisDirection;
        if (!(t2 === C.AxisDirection_0 && Math.max(t1.get$maxScrollExtent() - t1.get$pixels(), 0) === 0))
          t1 = t2 === C.AxisDirection_2 && Math.max(t1.get$pixels() - t1.get$minScrollExtent(), 0) === 0;
        else
          t1 = true;
        t1 = t1 && _this._refresh_indicator$_status == null && _this._refresh_indicator$_start$1(0, t2);
      } else
        t1 = false;
      if (t1) {
        _this.setState$1(new B.RefreshIndicatorState__handleScrollNotification_closure(_this));
        return false;
      }
      t1 = notification.metrics;
      _0_0 = t1.axisDirection;
      $label0$0: {
        t2 = null;
        if (C.AxisDirection_2 === _0_0 || C.AxisDirection_0 === _0_0) {
          t2 = true;
          break $label0$0;
        }
        if (C.AxisDirection_3 === _0_0 || C.AxisDirection_1 === _0_0)
          break $label0$0;
      }
      if (t2 != _this._isIndicatorAtTop) {
        t1 = _this._refresh_indicator$_status;
        if (t1 === D.RefreshIndicatorStatus_0 || t1 === D.RefreshIndicatorStatus_1)
          _this._dismiss$1(D.RefreshIndicatorStatus_5);
      } else if (notification instanceof A.ScrollUpdateNotification) {
        t2 = _this._refresh_indicator$_status;
        if (t2 === D.RefreshIndicatorStatus_0 || t2 === D.RefreshIndicatorStatus_1) {
          if (_0_0 === C.AxisDirection_2) {
            t2 = _this._dragOffset;
            t2.toString;
            t3 = notification.scrollDelta;
            t3.toString;
            _this._dragOffset = t2 - t3;
          } else if (_0_0 === C.AxisDirection_0) {
            t2 = _this._dragOffset;
            t2.toString;
            t3 = notification.scrollDelta;
            t3.toString;
            _this._dragOffset = t2 + t3;
          }
          t1 = t1._scroll_metrics$_viewportDimension;
          t1.toString;
          _this._checkDragOffset$1(t1);
        }
        if (_this._refresh_indicator$_status === D.RefreshIndicatorStatus_1 && notification.dragDetails == null)
          _this._refresh_indicator$_show$0();
      } else if (notification instanceof A.OverscrollNotification) {
        t2 = _this._refresh_indicator$_status;
        if (t2 === D.RefreshIndicatorStatus_0 || t2 === D.RefreshIndicatorStatus_1) {
          if (_0_0 === C.AxisDirection_2) {
            t2 = _this._dragOffset;
            t2.toString;
            _this._dragOffset = t2 - notification.overscroll;
          } else if (_0_0 === C.AxisDirection_0) {
            t2 = _this._dragOffset;
            t2.toString;
            _this._dragOffset = t2 + notification.overscroll;
          }
          t1 = t1._scroll_metrics$_viewportDimension;
          t1.toString;
          _this._checkDragOffset$1(t1);
        }
      } else if (notification instanceof A.ScrollEndNotification)
        switch (_this._refresh_indicator$_status) {
          case D.RefreshIndicatorStatus_1:
            t1 = _this.__RefreshIndicatorState__positionController_A;
            t1 === $ && A.throwLateFieldNI("_positionController");
            t1 = t1.__AnimationController__value_A;
            t1 === $ && A.throwLateFieldNI("_value");
            if (t1 < 1)
              _this._dismiss$1(D.RefreshIndicatorStatus_5);
            else
              _this._refresh_indicator$_show$0();
            break;
          case D.RefreshIndicatorStatus_0:
            _this._dismiss$1(D.RefreshIndicatorStatus_5);
            break;
          case D.RefreshIndicatorStatus_5:
          case D.RefreshIndicatorStatus_4:
          case D.RefreshIndicatorStatus_3:
          case D.RefreshIndicatorStatus_2:
          case null:
          case void 0:
            break;
        }
      return false;
    },
    _handleIndicatorNotification$1(notification) {
      type$.OverscrollIndicatorNotification._as(notification);
      if (notification.ViewportNotificationMixin__depth !== 0 || !notification.leading)
        return false;
      if (this._refresh_indicator$_status === D.RefreshIndicatorStatus_0) {
        notification.accepted = false;
        return true;
      }
      return false;
    },
    _refresh_indicator$_start$1(_, direction) {
      var t1, _this = this;
      A.assertHelper(_this._refresh_indicator$_status == null);
      A.assertHelper(_this._isIndicatorAtTop == null);
      A.assertHelper(_this._dragOffset == null);
      switch (direction.index) {
        case 2:
        case 0:
          _this._isIndicatorAtTop = true;
          break;
        case 3:
        case 1:
          _this._isIndicatorAtTop = null;
          return false;
      }
      _this._dragOffset = 0;
      t1 = _this.__RefreshIndicatorState__scaleController_A;
      t1 === $ && A.throwLateFieldNI("_scaleController");
      t1.set$value(0, 0);
      t1 = _this.__RefreshIndicatorState__positionController_A;
      t1 === $ && A.throwLateFieldNI("_positionController");
      t1.set$value(0, 0);
      return true;
    },
    _checkDragOffset$1(containerExtent) {
      var newValue, t2, _this = this,
        t1 = _this._refresh_indicator$_status;
      A.assertHelper(t1 === D.RefreshIndicatorStatus_0 || t1 === D.RefreshIndicatorStatus_1);
      t1 = _this._dragOffset;
      t1.toString;
      newValue = t1 / (containerExtent * 0.25);
      if (_this._refresh_indicator$_status === D.RefreshIndicatorStatus_1)
        newValue = Math.max(newValue, 0.6666666666666666);
      t1 = _this.__RefreshIndicatorState__positionController_A;
      t1 === $ && A.throwLateFieldNI("_positionController");
      t1.set$value(0, A.clampDouble(newValue, 0, 1));
      if (_this._refresh_indicator$_status === D.RefreshIndicatorStatus_0) {
        t1 = _this.__RefreshIndicatorState__valueColor_A;
        t1 === $ && A.throwLateFieldNI("_valueColor");
        t1 = t1.get$value(t1);
        t1.toString;
        t1 = J.get$alpha$z(t1);
        t2 = _this.get$_effectiveValueColor();
        t2 = t1 === t2.get$alpha(t2);
        t1 = t2;
      } else
        t1 = false;
      if (t1) {
        _this._refresh_indicator$_status = D.RefreshIndicatorStatus_1;
        _this._widget.toString;
      }
    },
    _dismiss$1(newMode) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1;
      var $async$_dismiss$1 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              $async$goto = 2;
              return A._asyncAwait(A.Future_Future$value(null, type$.void), $async$_dismiss$1);
            case 2:
              // returning from await.
              A.assertHelper(newMode === D.RefreshIndicatorStatus_5 || newMode === D.RefreshIndicatorStatus_4);
              $async$self.setState$1(new B.RefreshIndicatorState__dismiss_closure($async$self, newMode));
            case 3:
              // switch
              switch ($async$self._refresh_indicator$_status.index) {
                case 4:
                  // goto case
                  $async$goto = 5;
                  break;
                case 5:
                  // goto case
                  $async$goto = 6;
                  break;
                case 1:
                  // goto case
                  $async$goto = 7;
                  break;
                case 0:
                  // goto case
                  $async$goto = 8;
                  break;
                case 3:
                  // goto case
                  $async$goto = 9;
                  break;
                case 2:
                  // goto case
                  $async$goto = 10;
                  break;
                default:
                  // goto after switch
                  $async$goto = 4;
                  break;
              }
              break;
            case 5:
              // case
              t1 = $async$self.__RefreshIndicatorState__scaleController_A;
              t1 === $ && A.throwLateFieldNI("_scaleController");
              $async$goto = 11;
              return A._asyncAwait(t1.animateTo$2$duration(1, C.Duration_200000), $async$_dismiss$1);
            case 11:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 6:
              // case
              t1 = $async$self.__RefreshIndicatorState__positionController_A;
              t1 === $ && A.throwLateFieldNI("_positionController");
              $async$goto = 12;
              return A._asyncAwait(t1.animateTo$2$duration(0, C.Duration_200000), $async$_dismiss$1);
            case 12:
              // returning from await.
              // goto after switch
              $async$goto = 4;
              break;
            case 7:
              // case
            case 8:
              // case
            case 9:
              // case
            case 10:
              // case
              A.assertHelper(false);
              // goto after switch
              $async$goto = 4;
              break;
            case 4:
              // after switch
              if ($async$self._framework$_element != null && $async$self._refresh_indicator$_status === newMode) {
                $async$self._isIndicatorAtTop = $async$self._dragOffset = null;
                $async$self.setState$1(new B.RefreshIndicatorState__dismiss_closure0($async$self));
              }
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$_dismiss$1, $async$completer);
    },
    _refresh_indicator$_show$0() {
      var t1, t2, _this = this;
      A.assertHelper(_this._refresh_indicator$_status !== D.RefreshIndicatorStatus_3);
      A.assertHelper(_this._refresh_indicator$_status !== D.RefreshIndicatorStatus_2);
      t1 = $.Zone__current;
      _this._refresh_indicator$_status = D.RefreshIndicatorStatus_2;
      _this._widget.toString;
      t2 = _this.__RefreshIndicatorState__positionController_A;
      t2 === $ && A.throwLateFieldNI("_positionController");
      t2.animateTo$2$duration(0.6666666666666666, C.Duration_150000).then$1$1(0, new B.RefreshIndicatorState__show_closure(_this, new A._AsyncCompleter(new A._Future(t1, type$._Future_void), type$._AsyncCompleter_void)), type$.void);
    },
    build$1(context) {
      var t1, t2, showIndeterminateIndicator, t3, t4, t5, _this = this, _null = null;
      A.debugCheckHasMaterialLocalizations(context);
      t1 = _this._widget.child;
      A.assertHelper(new B.RefreshIndicatorState_build_closure(_this).call$0());
      t2 = _this._refresh_indicator$_status;
      showIndeterminateIndicator = t2 === D.RefreshIndicatorStatus_3 || t2 === D.RefreshIndicatorStatus_4;
      t1 = A._setArrayType([new A.NotificationListener(_this.get$_refresh_indicator$_handleScrollNotification(), new A.NotificationListener(_this.get$_handleIndicatorNotification(), t1, _null, type$.NotificationListener_OverscrollIndicatorNotification), _null, type$.NotificationListener_ScrollNotification)], type$.JSArray_Widget);
      if (_this._refresh_indicator$_status != null) {
        t2 = _this._isIndicatorAtTop;
        t2.toString;
        _this._widget.toString;
        t2 = !t2 ? 0 : _null;
        t3 = _this.__RefreshIndicatorState__positionFactor_A;
        t3 === $ && A.throwLateFieldNI("_positionFactor");
        t4 = _this.__RefreshIndicatorState__scaleFactor_A;
        t4 === $ && A.throwLateFieldNI("_scaleFactor");
        t5 = _this.__RefreshIndicatorState__positionController_A;
        t5 === $ && A.throwLateFieldNI("_positionController");
        t1.push(A.Positioned$(t2, A.SizeTransition$(1, new A.Padding(new A.EdgeInsets(0, 40, 0, 0), A.Align$(C.Alignment_0_m1, A.ScaleTransition$(C.Alignment_0_0, A.AnimatedBuilder$(t5, new B.RefreshIndicatorState_build_closure0(_this, showIndeterminateIndicator), _null), t4), _null, _null, _null), _null), t3), _null, _null, 0, 0, 0, _null));
      }
      return new A.Stack(C.AlignmentDirectional_m1_m1, _null, C.StackFit_0, C.Clip_1, t1, _null);
    },
    set$__RefreshIndicatorState__positionFactor_A(__RefreshIndicatorState__positionFactor_A) {
      this.__RefreshIndicatorState__positionFactor_A = type$.Animation_double._as(__RefreshIndicatorState__positionFactor_A);
    },
    set$__RefreshIndicatorState__scaleFactor_A(__RefreshIndicatorState__scaleFactor_A) {
      this.__RefreshIndicatorState__scaleFactor_A = type$.Animation_double._as(__RefreshIndicatorState__scaleFactor_A);
    },
    set$__RefreshIndicatorState__value_A(__RefreshIndicatorState__value_A) {
      this.__RefreshIndicatorState__value_A = type$.Animation_double._as(__RefreshIndicatorState__value_A);
    },
    set$__RefreshIndicatorState__valueColor_A(__RefreshIndicatorState__valueColor_A) {
      this.__RefreshIndicatorState__valueColor_A = type$.Animation_nullable_Color._as(__RefreshIndicatorState__valueColor_A);
    },
    $isTickerProvider: 1
  };
  B._RefreshIndicatorState_State_TickerProviderStateMixin.prototype = {
    activate$0() {
      this.super$State$activate();
      this._updateTickerModeNotifier$0();
      this._updateTickers$0();
    },
    dispose$0() {
      var t1, _this = this;
      A.assertHelper(new B._RefreshIndicatorState_State_TickerProviderStateMixin_dispose_closure(_this).call$0());
      t1 = _this.TickerProviderStateMixin__tickerModeNotifier;
      if (t1 != null)
        t1.removeListener$1(0, _this.get$_updateTickers());
      _this.set$_tickerModeNotifier(null);
      _this.super$State$dispose();
    },
    debugFillProperties$1(properties) {
      var t1, t2, t3, _null = null;
      this.super$State$debugFillProperties(properties);
      t1 = this.TickerProviderStateMixin__tickers;
      if (t1 != null) {
        t2 = t1._collection$_length;
        t3 = t2 === 1 ? "" : "s";
        t3 = "tracking " + t2 + " ticker" + t3;
        t2 = t3;
      } else
        t2 = _null;
      properties.add$1(0, A.DiagnosticsProperty$("tickers", t1, true, _null, t2, false, _null, _null, C.DiagnosticLevel_3, _null, false, true, true, C.DiagnosticsTreeStyle_8, _null, type$.Set_Ticker));
    }
  };
  B.TabController.prototype = {
    get$animation(_) {
      var t1 = this._animationController;
      return t1 == null ? null : t1;
    },
    _changeIndex$3$curve$duration(value, curve, duration) {
      var _this = this,
        t1 = _this.length;
      t1 = value < t1 || t1 === 0;
      A.assertHelper(t1);
      A.assertHelper(_this._indexIsChangingCount >= 0);
      t1 = _this._tab_controller$_index;
      if (value === t1 || _this.length < 2)
        return;
      _this._previousIndex = t1;
      _this._tab_controller$_index = value;
      t1 = _this._indexIsChangingCount + 1;
      if (duration._duration > 0) {
        _this._indexIsChangingCount = t1;
        _this.notifyListeners$0();
        _this._animationController.animateTo$3$curve$duration(_this._tab_controller$_index, curve, duration).whenCompleteOrCancel$1(new B.TabController__changeIndex_closure(_this));
      } else {
        _this._indexIsChangingCount = t1;
        _this._animationController.set$value(0, value);
        --_this._indexIsChangingCount;
        _this.notifyListeners$0();
      }
    },
    dispose$0() {
      var t1 = this._animationController;
      if (t1 != null)
        t1.dispose$0();
      this._animationController = null;
      this.super$ChangeNotifier$dispose();
    },
    get$length(receiver) {
      return this.length;
    }
  };
  B.UnderlineTabIndicator.prototype = {
    lerpFrom$2(a, t) {
      var t1, t2;
      if (a instanceof B.UnderlineTabIndicator) {
        t1 = A.BorderSide_lerp(a.borderSide, this.borderSide, t);
        t2 = A.EdgeInsetsGeometry_lerp(a.insets, this.insets, t);
        t2.toString;
        return new B.UnderlineTabIndicator(null, t1, t2);
      }
      return this.super$Decoration$lerpFrom(a, t);
    },
    lerpTo$2(b, t) {
      var t1, t2;
      if (b instanceof B.UnderlineTabIndicator) {
        t1 = A.BorderSide_lerp(this.borderSide, b.borderSide, t);
        t2 = A.EdgeInsetsGeometry_lerp(this.insets, b.insets, t);
        t2.toString;
        return new B.UnderlineTabIndicator(null, t1, t2);
      }
      return this.super$Decoration$lerpTo(b, t);
    },
    createBoxPainter$1(onChanged) {
      return new B._UnderlinePainter(this, this.borderRadius, type$.nullable_void_Function._as(onChanged));
    },
    _indicatorRectFor$2(rect, textDirection) {
      var indicator = this.insets.resolve$1(textDirection).deflateRect$1(rect),
        t1 = indicator.left,
        t2 = this.borderSide.width,
        t3 = indicator.bottom - t2;
      return new A.Rect(t1, t3, t1 + (indicator.right - t1), t3 + t2);
    },
    getClipPath$2(rect, textDirection) {
      var t2,
        t1 = this.borderRadius;
      if (t1 != null) {
        t2 = $.$get$_renderer().createPath$0();
        t2.addRRect$1(t1.toRRect$1(this._indicatorRectFor$2(rect, textDirection)));
        return t2;
      }
      t1 = $.$get$_renderer().createPath$0();
      t1.addRect$1(this._indicatorRectFor$2(rect, textDirection));
      return t1;
    }
  };
  B._UnderlinePainter.prototype = {
    paint$3(canvas, offset, configuration) {
      var t2, t3, rect, t4, paint, indicator,
        t1 = configuration.size;
      A.assertHelper(t1 != null);
      t2 = offset._dx;
      t3 = offset._dy;
      rect = new A.Rect(t2, t3, t2 + t1._dx, t3 + t1._dy);
      t1 = configuration.textDirection;
      t1.toString;
      t2 = this.borderRadius;
      t3 = this.decoration;
      t4 = t3.borderSide;
      if (t2 != null) {
        paint = $.$get$_renderer().createPaint$0();
        paint.set$color(0, t4.color);
        indicator = t3._indicatorRectFor$2(rect, t1);
        t1 = t2.topLeft;
        t3 = t2.topRight;
        t4 = t2.bottomRight;
        canvas.drawRRect$2(A.RRect$fromRectAndCorners(indicator, t2.bottomLeft, t4, t1, t3), paint);
      } else {
        paint = t4.toPaint$0();
        paint.set$strokeCap(C.StrokeCap_20);
        indicator = t3._indicatorRectFor$2(rect, t1).inflate$1(-(t4.width / 2));
        t1 = indicator.bottom;
        canvas.drawLine$3(new A.Offset(indicator.left, t1), new A.Offset(indicator.right, t1), paint);
      }
    }
  };
  B.TabAlignment.prototype = {
    _enumToString$0() {
      return "TabAlignment." + this._name;
    }
  };
  B.TabIndicatorAnimation.prototype = {
    _enumToString$0() {
      return "TabIndicatorAnimation." + this._name;
    }
  };
  B.Tab.prototype = {
    _buildLabelText$0() {
      var _null = null,
        t1 = A.Text$(this.text, _null, _null, _null, C.TextOverflow_1, _null, false, _null, _null, _null, _null, _null, _null, _null);
      return t1;
    },
    build$1(context) {
      var label, t1, _null = null;
      A.debugCheckHasMaterial(context);
      label = this._buildLabelText$0();
      t1 = A.Center$(label, _null, _null, 1);
      return new A.Semantics(A.SemanticsProperties$(_null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, C.SemanticsRole_1, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null), false, false, false, false, new A.SizedBox(_null, 46, t1, _null), _null);
    },
    debugFillProperties$1(properties) {
      this.super$Widget$debugFillProperties(properties);
      properties.add$1(0, A.StringProperty$("text", this.text, null, true, true));
    },
    get$preferredSize() {
      return D.Size_EWx;
    },
    $isPreferredSizeWidget: 1
  };
  B._TabStyle.prototype = {
    _resolveWithLabelColor$2$iconTheme(context, iconTheme) {
      var tabBarTheme, animation, t2, selectedColor, unselectedColor, _null = null, t1 = {};
      A.Theme_of(context);
      tabBarTheme = B.TabBarTheme_of(context);
      animation = type$.Animation_double._as(this.listenable);
      t2 = tabBarTheme.labelColor;
      if (t2 == null)
        t2 = _null;
      if (t2 == null) {
        t2 = tabBarTheme.labelStyle;
        t2 = t2 == null ? _null : t2.color;
        selectedColor = t2;
      } else
        selectedColor = t2;
      if (selectedColor == null)
        selectedColor = this.defaults.get$labelColor();
      t1.selectedColor = selectedColor;
      t1.unselectedColor = null;
      if (selectedColor instanceof A._WidgetStateColor) {
        t2 = type$.Set_WidgetState;
        t1.unselectedColor = selectedColor._resolve.call$1(t2._as(C.Set_empty));
        t1.selectedColor = selectedColor._resolve.call$1(t2._as(D.Set_zpZ11));
      } else {
        t2 = tabBarTheme.unselectedLabelColor;
        if (t2 == null)
          t2 = _null;
        if (t2 == null) {
          t2 = tabBarTheme.unselectedLabelStyle;
          t2 = t2 == null ? _null : t2.color;
        }
        if (t2 == null) {
          t2 = iconTheme == null ? _null : iconTheme.color;
          unselectedColor = t2;
        } else
          unselectedColor = t2;
        if (unselectedColor == null) {
          t2 = this.defaults.get$unselectedLabelColor();
          t2.toString;
          unselectedColor = t2;
        }
        t1.unselectedColor = unselectedColor;
      }
      return A._WidgetStateColor$(new B._TabStyle__resolveWithLabelColor_closure(t1, animation));
    },
    _resolveWithLabelColor$1(context) {
      return this._resolveWithLabelColor$2$iconTheme(context, null);
    },
    build$1(context) {
      var selectedStyle, unselectedStyle, textStyle, _0_0, _this = this, _null = null,
        theme = A.Theme_of(context),
        tabBarTheme = B.TabBarTheme_of(context),
        animation = type$.Animation_double._as(_this.listenable),
        t1 = _this.isSelected,
        states = t1 ? D.Set_zpZ11 : C.Set_empty,
        t2 = _this.labelStyle,
        t3 = tabBarTheme.labelStyle;
      if (t3 == null) {
        t3 = _this.defaults.get$labelStyle();
        t3.toString;
      }
      selectedStyle = t3.copyWith$1$inherit(true);
      t3 = tabBarTheme.unselectedLabelStyle;
      t2 = t3 == null ? t2 : t3;
      if (t2 == null) {
        t2 = _this.defaults.get$unselectedLabelStyle();
        t2.toString;
      }
      unselectedStyle = t2.copyWith$1$inherit(true);
      if (t1) {
        t1 = A.TextStyle_lerp(selectedStyle, unselectedStyle, animation.get$value(animation));
        t1.toString;
        textStyle = t1;
      } else {
        t1 = A.TextStyle_lerp(unselectedStyle, selectedStyle, animation.get$value(animation));
        t1.toString;
        textStyle = t1;
      }
      switch (theme.colorScheme.brightness.index) {
        case 1:
          t1 = $.$get$kDefaultIconDarkColor();
          break;
        case 0:
          t1 = $.$get$kDefaultIconLightColor();
          break;
        default:
          t1 = _null;
      }
      _0_0 = A.IconTheme_of(context);
      $label0$1: {
        t1 = !J.$eq$(_0_0.color, t1);
        if (t1) {
          t1 = _0_0;
          break $label0$1;
        }
        t1 = _null;
        break $label0$1;
      }
      t2 = _this._resolveWithLabelColor$2$iconTheme(context, t1);
      type$.Set_WidgetState._as(states);
      t2 = t2._resolve.call$1(states);
      t3 = textStyle.copyWith$1$color(_this._resolveWithLabelColor$1(context)._resolve.call$1(states));
      t1 = t1 == null ? _null : t1.size;
      return A.DefaultTextStyle$(A.IconTheme_merge(_this.child, A.IconThemeData$(_null, t2, _null, _null, _null, _null, _null, t1 == null ? 24 : t1, _null)), _null, _null, C.TextOverflow_0, true, t3, _null, _null, C.TextWidthBasis_0);
    }
  };
  B._TabLabelBarRenderer.prototype = {
    performLayout$0() {
      var child, xOffsets, t1, t2, _this = this;
      _this.super$RenderFlex$performLayout();
      child = _this.ContainerRenderObjectMixin__firstChild;
      xOffsets = A._setArrayType([], type$.JSArray_double);
      for (t1 = type$.FlexParentData; child != null;) {
        t2 = child.parentData;
        t2.toString;
        t1._as(t2);
        C.JSArray_methods.add$1(xOffsets, t2.offset._dx);
        A.assertHelper(child.parentData === t2);
        child = t2.ContainerParentDataMixin_nextSibling;
      }
      A.assertHelper(_this._flex$_textDirection != null);
      switch (_this._flex$_textDirection.index) {
        case 0:
          C.JSArray_methods.insert$2(xOffsets, 0, _this.get$size(0)._dx);
          break;
        case 1:
          C.JSArray_methods.add$1(xOffsets, _this.get$size(0)._dx);
          break;
      }
      t1 = _this._flex$_textDirection;
      t1.toString;
      t2 = _this.get$size(0);
      _this.onPerformLayout.call$3(xOffsets, t1, t2._dx);
    },
    set$onPerformLayout(onPerformLayout) {
      this.onPerformLayout = type$.void_Function_3_List_double_and_TextDirection_and_double._as(onPerformLayout);
    }
  };
  B._TabLabelBar.prototype = {
    createRenderObject$1(context) {
      var _this = this,
        t1 = _this.getEffectiveTextDirection$1(context);
      t1.toString;
      return B._TabLabelBarRenderer$(_this.crossAxisAlignment, _this.direction, _this.mainAxisAlignment, _this.mainAxisSize, _this.onPerformLayout, t1, _this.verticalDirection);
    },
    updateRenderObject$2(context, renderObject) {
      type$._TabLabelBarRenderer._as(renderObject);
      this.super$Flex$updateRenderObject(context, renderObject);
      renderObject.set$onPerformLayout(this.onPerformLayout);
    }
  };
  B._DividerPainter.prototype = {
    paint$2(canvas, size) {
      var paint,
        t1 = this.dividerHeight;
      if (t1 <= 0)
        return;
      paint = $.$get$_renderer().createPaint$0();
      paint.set$color(0, this.dividerColor);
      paint.set$strokeWidth(t1);
      t1 = size._dy;
      canvas.drawLine$3(new A.Offset(0, t1 - paint.get$strokeWidth() / 2), new A.Offset(size._dx, t1 - paint.get$strokeWidth() / 2), paint);
    },
    shouldRepaint$1(oldDelegate) {
      type$._DividerPainter._as(oldDelegate);
      return !oldDelegate.dividerColor.$eq(0, this.dividerColor) || oldDelegate.dividerHeight !== this.dividerHeight;
    }
  };
  B._IndicatorPainter.prototype = {
    markNeedsPaint$0() {
      this._tabs$_needsPaint = true;
    },
    dispose$0() {
      $.$get$FlutterMemoryAllocations_instance().dispatchObjectDisposed$1$object(this);
      var t1 = this._tabs$_painter;
      if (t1 != null)
        t1.dispose$0();
    },
    indicatorRect$2(tabBarSize, tabIndex) {
      var t1, t2, t3, t4, tabLeft, tabRight, tabWidth, insets, rect, t5, _this = this;
      A.assertHelper(_this._currentTabOffsets != null);
      A.assertHelper(_this._currentTextDirection != null);
      A.assertHelper(_this._currentTabOffsets.length !== 0);
      A.assertHelper(tabIndex >= 0);
      A.assertHelper(tabIndex <= _this._currentTabOffsets.length - 2);
      switch (_this._currentTextDirection.index) {
        case 0:
          t1 = _this._currentTabOffsets;
          t2 = tabIndex + 1;
          t3 = t1.length;
          if (!(t2 >= 0 && t2 < t3))
            return A.ioore(t1, t2);
          t2 = t1[t2];
          if (!(tabIndex >= 0 && tabIndex < t3))
            return A.ioore(t1, tabIndex);
          t1 = new A._Record_2(t2, t1[tabIndex]);
          break;
        case 1:
          t1 = _this._currentTabOffsets;
          t2 = t1.length;
          if (!(tabIndex >= 0 && tabIndex < t2))
            return A.ioore(t1, tabIndex);
          t3 = t1[tabIndex];
          t4 = tabIndex + 1;
          if (!(t4 < t2))
            return A.ioore(t1, t4);
          t4 = new A._Record_2(t3, t1[t4]);
          t1 = t4;
          break;
        default:
          t1 = null;
      }
      tabLeft = t1._0;
      tabRight = t1._1;
      if (_this.indicatorSize === D.TabBarIndicatorSize_1) {
        t1 = _this.tabKeys;
        if (!(tabIndex >= 0 && tabIndex < t1.length))
          return A.ioore(t1, tabIndex);
        t1 = t1[tabIndex];
        tabWidth = A.BindingBase_checkInstance($.WidgetsBinding__instance, type$.WidgetsBinding).WidgetsBinding__buildOwner._globalKeyRegistry.$index(0, t1).get$size(0)._dx;
        t1 = _this.labelPaddings;
        if (!(tabIndex < t1.length))
          return A.ioore(t1, tabIndex);
        insets = t1[tabIndex].resolve$1(_this._currentTextDirection);
        tabLeft += (tabRight - tabLeft - (tabWidth + insets.get$horizontal())) / 2 + insets.left;
        tabRight = tabLeft + tabWidth;
      }
      insets = _this.indicatorPadding;
      t1 = tabLeft + (tabRight - tabLeft);
      t2 = 0 + tabBarSize._dy;
      rect = new A.Rect(tabLeft, 0, t1, t2);
      t3 = insets.get$horizontal();
      t4 = insets.get$_top(0);
      t5 = insets.get$_bottom(0);
      if (!(t1 - tabLeft >= t3 && t2 >= t4 + t5))
        throw A.wrapException(A.FlutterError_FlutterError("indicatorPadding insets should be less than Tab Size\nRect Size : " + rect.get$size(0).toString$0(0) + ", Insets: " + insets.toString$0(0)));
      return insets.deflateRect$1(rect);
    },
    paint$2(canvas, size) {
      var t2, t3, ltr, from, to, t4, t5, t6, dividerPaint, t7, _this = this, _null = null,
        t1 = _this._tabs$_needsPaint = false;
      if (_this._tabs$_painter == null)
        _this._tabs$_painter = _this.indicator.createBoxPainter$1(_this.get$markNeedsPaint());
      t2 = _this.controller;
      t3 = t2.get$animation(0).__AnimationController__value_A;
      t3 === $ && A.throwLateFieldNI("_value");
      switch (_this.indicatorAnimation.index) {
        case 0:
          ltr = t2._tab_controller$_index > t3;
          t2 = ltr ? C.JSNumber_methods.floor$0(t3) : C.JSNumber_methods.ceil$0(t3);
          from = C.JSInt_methods.clamp$2(t2, 0, _this._currentTabOffsets.length - 2);
          t2 = ltr ? from + 1 : from - 1;
          to = C.JSInt_methods.clamp$2(t2, 0, _this._currentTabOffsets.length - 2);
          t3 = A.Rect_lerp(_this.indicatorRect$2(size, from), _this.indicatorRect$2(size, to), Math.abs(t3 - from));
          t2 = t3;
          break;
        case 1:
          t2 = _this._applyElasticEffect$2$size$value(size, t3);
          break;
        default:
          t2 = _null;
      }
      _this._currentRect = t2;
      A.assertHelper(t2 != null);
      t2 = _this._currentRect;
      t3 = t2.right;
      t4 = t2.left;
      t5 = t2.bottom;
      t2 = t2.top;
      t6 = _this._currentTextDirection;
      if (_this.showDivider) {
        t1 = _this.dividerHeight;
        t1.toString;
        t1 = t1 > 0;
      }
      if (t1) {
        dividerPaint = $.$get$_renderer().createPaint$0();
        t1 = _this.dividerColor;
        t1.toString;
        dividerPaint.set$color(0, t1);
        t1 = _this.dividerHeight;
        t1.toString;
        dividerPaint.set$strokeWidth(t1);
        t1 = size._dy;
        canvas.drawLine$3(new A.Offset(0, t1 - dividerPaint.get$strokeWidth() / 2), new A.Offset(size._dx, t1 - dividerPaint.get$strokeWidth() / 2), dividerPaint);
      }
      t1 = _this._tabs$_painter;
      t1.toString;
      t7 = _this._currentRect;
      t1.paint$3(canvas, new A.Offset(t7.left, t7.top), new A.ImageConfiguration(_null, _this.devicePixelRatio, _null, t6, new A.Size(t3 - t4, t5 - t2), _null));
    },
    accelerateInterpolation$1(fraction) {
      return 1 - Math.cos(fraction * 3.141592653589793 / 2);
    },
    _applyElasticEffect$2$size$value(size, value) {
      var t3, to, from, toRect, fromRect, tabsDelta, tabChangeProgress, t4, leftFraction, rightFraction, lerpRectRight, lerpRectLeft, _this = this, _null = null,
        t1 = _this.controller,
        index = t1._tab_controller$_index,
        progressLeft = Math.abs(index - value),
        t2 = progressLeft !== 0;
      if (!t2 || t1._indexIsChangingCount === 0) {
        switch (_this.textDirection.index) {
          case 1:
            t3 = C.JSNumber_methods.ceil$0(value);
            break;
          case 0:
            t3 = C.JSNumber_methods.floor$0(value);
            break;
          default:
            t3 = _null;
        }
        to = J.clamp$2$n(t3, 0, _this._currentTabOffsets.length - 2);
      } else
        to = index;
      if (!t2 || t1._indexIsChangingCount === 0) {
        switch (_this.textDirection.index) {
          case 1:
            t2 = to - 1;
            break;
          case 0:
            t2 = to + 1;
            break;
          default:
            t2 = _null;
        }
        from = J.clamp$2$n(t2, 0, _this._currentTabOffsets.length - 2);
      } else
        from = t1._previousIndex;
      toRect = _this.indicatorRect$2(size, to);
      fromRect = _this.indicatorRect$2(size, from);
      t2 = A.Rect_lerp(fromRect, toRect, Math.abs(value - from));
      t2.toString;
      if (t1.get$animation(0).get$status(0) === C.AnimationStatus_3)
        return t2;
      t3 = t1._indexIsChangingCount !== 0;
      if (t3) {
        tabsDelta = Math.abs(t1._tab_controller$_index - t1._previousIndex);
        tabChangeProgress = 1 - A.clampDouble(tabsDelta !== 0 ? progressLeft / tabsDelta : progressLeft, 0, 1);
      } else
        tabChangeProgress = progressLeft;
      if (tabChangeProgress === 1)
        return t2;
      switch (_this.textDirection.index) {
        case 1:
          t3 = t3 ? index > value : value > index;
          break;
        case 0:
          t3 = t3 ? value > index : index > value;
          break;
        default:
          t3 = _null;
      }
      t4 = tabChangeProgress * 3.141592653589793 / 2;
      if (t3) {
        leftFraction = _this.accelerateInterpolation$1(tabChangeProgress);
        rightFraction = Math.sin(t4);
      } else {
        leftFraction = Math.sin(t4);
        rightFraction = _this.accelerateInterpolation$1(tabChangeProgress);
      }
      if (t1._indexIsChangingCount !== 0) {
        t1 = A.lerpDouble(fromRect.left, toRect.left, leftFraction);
        t1.toString;
        t3 = A.lerpDouble(fromRect.right, toRect.right, rightFraction);
        t3.toString;
        lerpRectRight = t3;
        lerpRectLeft = t1;
      } else {
        switch (t3) {
          case true:
            t1 = A.lerpDouble(fromRect.left, toRect.left, leftFraction);
            t1.toString;
            break;
          case false:
            t1 = A.lerpDouble(toRect.left, fromRect.left, leftFraction);
            t1.toString;
            break;
          default:
            t1 = _null;
        }
        switch (t3) {
          case true:
            t3 = A.lerpDouble(fromRect.right, toRect.right, rightFraction);
            t3.toString;
            break;
          case false:
            t3 = A.lerpDouble(toRect.right, fromRect.right, rightFraction);
            t3.toString;
            break;
          default:
            t3 = _null;
        }
        lerpRectRight = t3;
        lerpRectLeft = t1;
      }
      return new A.Rect(lerpRectLeft, t2.top, lerpRectRight, t2.bottom);
    },
    shouldRepaint$1(old) {
      var _this = this;
      type$._IndicatorPainter._as(old);
      return _this._tabs$_needsPaint || _this.controller !== old.controller || !_this.indicator.$eq(0, old.indicator) || _this.tabKeys.length !== old.tabKeys.length || !A.listEquals(_this._currentTabOffsets, old._currentTabOffsets, type$.double) || _this._currentTextDirection != old._currentTextDirection;
    },
    set$_currentTabOffsets(_currentTabOffsets) {
      this._currentTabOffsets = type$.nullable_List_double._as(_currentTabOffsets);
    }
  };
  B._ChangeAnimation.prototype = {
    get$parent(_) {
      var t1 = this.controller.get$animation(0);
      t1.toString;
      return t1;
    },
    removeStatusListener$1(listener) {
      type$.void_Function_AnimationStatus._as(listener);
      if (this.controller.get$animation(0) != null)
        this.super$AnimationWithParentMixin$removeStatusListener(listener);
    },
    removeListener$1(_, listener) {
      type$.void_Function._as(listener);
      if (this.controller.get$animation(0) != null)
        this.super$AnimationWithParentMixin$removeListener(0, listener);
    },
    get$value(_) {
      return B._indexChangeProgress(this.controller);
    }
  };
  B._DragAnimation.prototype = {
    get$parent(_) {
      var t1 = this.controller.get$animation(0);
      t1.toString;
      return t1;
    },
    removeStatusListener$1(listener) {
      type$.void_Function_AnimationStatus._as(listener);
      if (this.controller.get$animation(0) != null)
        this.super$AnimationWithParentMixin$removeStatusListener(listener);
    },
    removeListener$1(_, listener) {
      type$.void_Function._as(listener);
      if (this.controller.get$animation(0) != null)
        this.super$AnimationWithParentMixin$removeListener(0, listener);
    },
    get$value(_) {
      var t2,
        t1 = this.controller;
      A.assertHelper(t1._indexIsChangingCount === 0);
      t2 = t1.get$animation(0).__AnimationController__value_A;
      t2 === $ && A.throwLateFieldNI("_value");
      return A.clampDouble(Math.abs(A.clampDouble(t2, 0, t1.length - 1) - this.index), 0, 1);
    }
  };
  B._TabBarScrollPosition.prototype = {
    applyContentDimensions$2(minScrollExtent, maxScrollExtent) {
      var t2, t3, t4, result, _this = this,
        t1 = _this._viewportDimensionWasNonZero;
      if (!t1) {
        t1 = _this._viewportDimension;
        t1.toString;
        t1 = _this._viewportDimensionWasNonZero = t1 !== 0;
      }
      t1 = !t1 || _this._needsPixelsCorrection;
      if (t1) {
        _this._needsPixelsCorrection = false;
        t2 = _this.tabBar;
        t3 = _this._viewportDimension;
        t3.toString;
        t4 = t2._currentIndex;
        t4.toString;
        _this._pixels = t2._tabScrollOffset$4(t4, t3, minScrollExtent, maxScrollExtent);
      }
      result = !t1;
      return _this.super$ScrollPosition$applyContentDimensions(minScrollExtent, maxScrollExtent) && result;
    }
  };
  B._TabBarScrollController.prototype = {
    createScrollPosition$3(physics, context, oldPosition) {
      var _null = null,
        t1 = new B._TabBarScrollPosition(this.tabBar, C.ScrollDirection_0, physics, context, true, _null, A.ValueNotifier$(false, type$.bool), $.$get$ChangeNotifier__emptyListeners());
      A.ChangeNotifier_maybeDispatchObjectCreation(t1);
      t1.ScrollPosition$5$context$debugLabel$keepScrollOffset$oldPosition$physics(context, _null, true, oldPosition, physics);
      t1.ScrollPositionWithSingleContext$6$context$debugLabel$initialPixels$keepScrollOffset$oldPosition$physics(context, _null, _null, true, oldPosition, physics);
      return t1;
    }
  };
  B.TabBar.prototype = {
    get$preferredSize() {
      var t1, t2, t3, maxHeight, _i, item;
      for (t1 = this.tabs, t2 = t1.length, t3 = type$.PreferredSizeWidget, maxHeight = 46, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
        item = t1[_i];
        if (t3._is(item))
          maxHeight = Math.max(item.get$preferredSize()._dy, maxHeight);
      }
      return new A.Size(1 / 0, maxHeight + 2);
    },
    get$tabHasTextAndIcon() {
      var t1, t2, t3, _i, item;
      for (t1 = this.tabs, t2 = t1.length, t3 = type$.PreferredSizeWidget, _i = 0; _i < t1.length; t1.length === t2 || (0, A.throwConcurrentModificationError)(t1), ++_i) {
        item = t1[_i];
        if (t3._is(item))
          if (item.get$preferredSize()._dy === 72)
            return true;
      }
      return false;
    },
    createState$0() {
      return new B._TabBarState(C._StateLifecycle_0);
    },
    $isPreferredSizeWidget: 1
  };
  B._TabBarState.prototype = {
    initState$0() {
      var t1, t2, t3, _this = this;
      _this.super$State$initState();
      t1 = _this._widget.tabs;
      t2 = A._arrayInstanceType(t1);
      t3 = t2._eval$1("MappedListIterable<1,GlobalKey<State<StatefulWidget>>>");
      _this.set$___TabBarState__tabKeys_A(type$.List_GlobalKey_State_StatefulWidget._as(A.List_List$of(new A.MappedListIterable(t1, t2._eval$1("GlobalKey<State<StatefulWidget>>(1)")._as(new B._TabBarState_initState_closure()), t3), true, t3._eval$1("ListIterable.E"))));
      _this.set$___TabBarState__labelPaddings_A(type$.List_EdgeInsetsGeometry._as(A.List_List$filled(_this._widget.tabs.length, C.EdgeInsets_0_0_0_0, true, type$.EdgeInsetsGeometry)));
    },
    get$_tabs$_defaults() {
      var t1, _this = this, _null = null;
      A.Theme_of(_this.get$context(0));
      _this._widget.toString;
      t1 = _this.get$context(0);
      _this._widget.toString;
      return new B._TabsPrimaryDefaultsM3(t1, true, _null, _null, D.TabBarIndicatorSize_1, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null);
    },
    _getIndicator$1(indicatorSize) {
      var tabBarTheme, t1, color, t2, effectiveIndicatorWeight, effectiveBorderRadius, _this = this, _null = null;
      A.Theme_of(_this.get$context(0));
      tabBarTheme = B.TabBarTheme_of(_this.get$context(0));
      _this._widget.toString;
      t1 = tabBarTheme.indicator;
      if (t1 != null)
        return t1;
      color = tabBarTheme.indicatorColor;
      if (color == null)
        color = _this.get$_tabs$_defaults().get$indicatorColor();
      _this._widget.toString;
      t1 = color.get$value(color);
      t2 = A.LookupBoundary_findAncestorRenderObjectOfType(_this.get$context(0), type$._RenderInkFeatures);
      if (t2 == null)
        t2 = _null;
      else {
        t2 = t2.color;
        t2 = t2 == null ? _null : t2.get$value(t2);
      }
      t2 = t1 === t2;
      t1 = t2;
      if (t1)
        color = C.Color_wst;
      _this._widget.toString;
      switch (true) {
        case true:
          t1 = B._TabsPrimaryDefaultsM3_indicatorWeight(indicatorSize);
          break;
        case false:
          t1 = 2;
          break;
        default:
          t1 = _null;
      }
      effectiveIndicatorWeight = Math.max(2, A.checkNum(t1));
      switch (indicatorSize.index) {
        case 1:
          t1 = true;
          break;
        case 0:
          t1 = false;
          break;
        default:
          t1 = _null;
      }
      effectiveBorderRadius = t1 ? new A.BorderRadius(new A.Radius(effectiveIndicatorWeight, effectiveIndicatorWeight), new A.Radius(effectiveIndicatorWeight, effectiveIndicatorWeight), C.Radius_0_0, C.Radius_0_0) : _null;
      A.assertHelper(effectiveIndicatorWeight >= 0);
      return new B.UnderlineTabIndicator(effectiveBorderRadius, new A.BorderSide(color, effectiveIndicatorWeight, C.BorderStyle_1, -1), C.EdgeInsets_0_0_0_0);
    },
    get$_controllerIsValid() {
      var t1 = this._tabs$_controller;
      return (t1 == null ? null : t1.get$animation(0)) != null;
    },
    _updateTabController$0() {
      var t1, t2, _this = this,
        newController = _this._widget.controller;
      A.assertHelper(new B._TabBarState__updateTabController_closure(_this, newController).call$0());
      if (newController === _this._tabs$_controller)
        return;
      if (_this.get$_controllerIsValid()) {
        _this._tabs$_controller.get$animation(0).removeListener$1(0, _this.get$_handleTabControllerAnimationTick());
        _this._tabs$_controller.removeListener$1(0, _this.get$_handleTabControllerTick());
      }
      _this._tabs$_controller = newController;
      t1 = newController.get$animation(0);
      t1.toString;
      t2 = type$.void_Function._as(_this.get$_handleTabControllerAnimationTick());
      t1.didRegisterListener$0();
      t1.AnimationLocalListenersMixin__listeners.add$1(0, t2);
      _this._tabs$_controller.addListener$1(0, _this.get$_handleTabControllerTick());
      _this._currentIndex = _this._tabs$_controller._tab_controller$_index;
    },
    _initIndicatorPainter$0() {
      var tabBarTheme, indicatorSize, t1, oldPainter, t2, t3, t4, t5, t6, t7, t8, _this = this;
      A.Theme_of(_this.get$context(0));
      tabBarTheme = B.TabBarTheme_of(_this.get$context(0));
      _this._widget.toString;
      indicatorSize = tabBarTheme.indicatorSize;
      if (indicatorSize == null) {
        t1 = _this.get$_tabs$_defaults().indicatorSize;
        t1.toString;
        indicatorSize = t1;
      }
      oldPainter = _this._indicatorPainter;
      switch (indicatorSize.index) {
        case 1:
          t1 = D.TabIndicatorAnimation_1;
          break;
        case 0:
          t1 = D.TabIndicatorAnimation_0;
          break;
        default:
          t1 = null;
      }
      if (!_this.get$_controllerIsValid())
        t1 = null;
      else {
        t2 = _this._tabs$_controller;
        t2.toString;
        t3 = _this._getIndicator$1(indicatorSize);
        _this._widget.toString;
        t4 = _this.___TabBarState__tabKeys_A;
        t4 === $ && A.throwLateFieldNI("_tabKeys");
        t5 = _this.___TabBarState__labelPaddings_A;
        t5 === $ && A.throwLateFieldNI("_labelPaddings");
        t6 = tabBarTheme.dividerColor;
        if (t6 == null)
          t6 = _this.get$_tabs$_defaults().get$dividerColor();
        _this._widget.toString;
        t7 = _this.get$_tabs$_defaults().get$dividerHeight();
        _this._widget.toString;
        t8 = _this.get$context(0);
        A.debugCheckHasMediaQuery(t8);
        t8 = A.InheritedModel_inheritFrom(t8, C._MediaQueryAspect_2, type$.MediaQuery).data;
        _this._widget.toString;
        t1 = new B._IndicatorPainter(t2, t3, indicatorSize, C.EdgeInsets_0_0_0_0, t4, t5, t6, t7, false, t8.devicePixelRatio, t1, A.Directionality_of(_this.get$context(0)), t2.get$animation(0));
        $.$get$FlutterMemoryAllocations_instance().dispatchObjectCreated$3$className$library$object(D.Type__IndicatorPainter_Ovs.toString$0(0), "package:flutter/material.dart", t1);
        if (oldPainter != null) {
          t2 = oldPainter._currentTabOffsets;
          t3 = oldPainter._currentTextDirection;
          t1.set$_currentTabOffsets(type$.nullable_List_double._as(t2));
          t1._currentTextDirection = t3;
        }
      }
      _this._indicatorPainter = t1;
      if (oldPainter != null)
        oldPainter.dispose$0();
    },
    didChangeDependencies$0() {
      var _this = this;
      _this.super$State$didChangeDependencies();
      A.debugCheckHasMaterial(_this.get$context(0));
      _this._updateTabController$0();
      _this._initIndicatorPainter$0();
    },
    didUpdateWidget$1(oldWidget) {
      var t1, position, t2, t3, delta, _list, n, _this = this,
        _s14_ = "_labelPaddings";
      type$.TabBar._as(oldWidget);
      _this.super$State$didUpdateWidget(oldWidget);
      if (_this._widget.controller !== oldWidget.controller) {
        _this._updateTabController$0();
        _this._initIndicatorPainter$0();
        t1 = _this._tabs$_scrollController;
        if (t1 != null && t1._positions.length !== 0) {
          position = t1.get$position(0);
          if (position instanceof B._TabBarScrollPosition)
            position._needsPixelsCorrection = true;
        }
      } else {
        t1 = true;
        t1 = C.EdgeInsets_0_0_0_0.$eq(0, C.EdgeInsets_0_0_0_0);
        if (t1)
          _this._widget.toString;
        t1 = !t1;
        if (t1)
          _this._initIndicatorPainter$0();
      }
      t1 = _this._widget.tabs.length;
      t2 = _this.___TabBarState__tabKeys_A;
      t2 === $ && A.throwLateFieldNI("_tabKeys");
      t3 = t2.length;
      if (t1 > t3) {
        delta = t1 - t3;
        _list = J.JSArray_JSArray$allocateGrowable(delta, type$.GlobalKey_State_StatefulWidget);
        for (t1 = type$.LabeledGlobalKey_State_StatefulWidget, n = 0; n < delta; ++n)
          _list[n] = new A.LabeledGlobalKey(null, t1);
        C.JSArray_methods.addAll$1(t2, _list);
        t1 = _this.___TabBarState__labelPaddings_A;
        t1 === $ && A.throwLateFieldNI(_s14_);
        C.JSArray_methods.addAll$1(t1, A.List_List$filled(delta, C.EdgeInsets_0_0_0_0, false, type$.EdgeInsetsGeometry));
      } else if (t1 < t3) {
        C.JSArray_methods.removeRange$2(t2, t1, t3);
        t1 = _this.___TabBarState__labelPaddings_A;
        t1 === $ && A.throwLateFieldNI(_s14_);
        C.JSArray_methods.removeRange$2(t1, _this._widget.tabs.length, _this.___TabBarState__tabKeys_A.length);
      }
    },
    dispose$0() {
      var t1, _this = this;
      _this._indicatorPainter.dispose$0();
      if (_this.get$_controllerIsValid()) {
        _this._tabs$_controller.get$animation(0).removeListener$1(0, _this.get$_handleTabControllerAnimationTick());
        _this._tabs$_controller.removeListener$1(0, _this.get$_handleTabControllerTick());
      }
      _this._tabs$_controller = null;
      t1 = _this._tabs$_scrollController;
      if (t1 != null)
        t1.dispose$0();
      _this.super$State$dispose();
    },
    _tabScrollOffset$4(index, viewportWidth, minExtent, maxExtent) {
      var t1, t2, t3, t4, tabCenter, paddingStart, _this = this;
      _this._widget.toString;
      t1 = _this._indicatorPainter;
      A.assertHelper(t1._currentTabOffsets != null);
      A.assertHelper(t1._currentTabOffsets.length !== 0);
      A.assertHelper(index >= 0);
      A.assertHelper(index <= t1._currentTabOffsets.length - 2);
      t1 = t1._currentTabOffsets;
      t2 = t1.length;
      if (!(index >= 0 && index < t2))
        return A.ioore(t1, index);
      t3 = t1[index];
      t4 = index + 1;
      if (!(t4 < t2))
        return A.ioore(t1, t4);
      tabCenter = (t3 + t1[t4]) / 2;
      paddingStart = 0;
      switch (A.Directionality_of(_this.get$context(0)).index) {
        case 0:
          _this._widget.toString;
          t1 = _this.___TabBarState__tabStripWidth_A;
          t1 === $ && A.throwLateFieldNI("_tabStripWidth");
          tabCenter = t1 - tabCenter;
          break;
        case 1:
          _this._widget.toString;
          break;
        default:
          paddingStart = null;
      }
      if (typeof paddingStart !== "number")
        return A.iae(paddingStart);
      return A.clampDouble(tabCenter + paddingStart - viewportWidth / 2, minExtent, maxExtent);
    },
    _tabCenteredScrollOffset$1(index) {
      var t2, t3,
        position = this._tabs$_scrollController.get$position(0),
        t1 = position._viewportDimension;
      t1.toString;
      t2 = position._minScrollExtent;
      t2.toString;
      t3 = position._maxScrollExtent;
      t3.toString;
      return this._tabScrollOffset$4(index, t1, t2, t3);
    },
    _scrollToControllerValue$0() {
      var leadingPosition, middlePosition, trailingPosition, index, _0_0, _this = this,
        t1 = _this._currentIndex;
      t1.toString;
      leadingPosition = t1 > 0 ? _this._tabCenteredScrollOffset$1(t1 - 1) : null;
      t1 = _this._currentIndex;
      t1.toString;
      middlePosition = _this._tabCenteredScrollOffset$1(t1);
      t1 = _this._currentIndex;
      t1.toString;
      trailingPosition = t1 < _this._indicatorPainter._currentTabOffsets.length - 2 ? _this._tabCenteredScrollOffset$1(t1 + 1) : null;
      t1 = _this._tabs$_controller;
      index = t1._tab_controller$_index;
      t1 = t1.get$animation(0).__AnimationController__value_A;
      t1 === $ && A.throwLateFieldNI("_value");
      _0_0 = t1 - index;
      $label0$0: {
        if (-1 === _0_0) {
          t1 = leadingPosition == null ? middlePosition : leadingPosition;
          break $label0$0;
        }
        if (1 === _0_0) {
          t1 = trailingPosition == null ? middlePosition : trailingPosition;
          break $label0$0;
        }
        if (0 === _0_0) {
          t1 = middlePosition;
          break $label0$0;
        }
        if (_0_0 < 0) {
          if (leadingPosition == null)
            t1 = middlePosition;
          else {
            t1 = A.lerpDouble(middlePosition, leadingPosition, index - t1);
            t1.toString;
          }
          break $label0$0;
        }
        if (trailingPosition == null)
          t1 = middlePosition;
        else {
          t1 = A.lerpDouble(middlePosition, trailingPosition, _0_0);
          t1.toString;
        }
        break $label0$0;
      }
      _this._tabs$_scrollController.jumpTo$1(t1);
    },
    _handleTabControllerAnimationTick$0() {
      var t1, t2, _this = this;
      A.assertHelper(_this._framework$_element != null);
      t1 = _this._tabs$_controller;
      t2 = t1._indexIsChangingCount === 0;
      if (t2)
        _this._widget.toString;
      if (t2) {
        _this._currentIndex = t1._tab_controller$_index;
        _this._scrollToControllerValue$0();
      }
    },
    _handleTabControllerTick$0() {
      var offset, _this = this,
        t1 = _this._tabs$_controller._tab_controller$_index;
      if (t1 !== _this._currentIndex) {
        _this._currentIndex = t1;
        _this._widget.toString;
        offset = _this._tabCenteredScrollOffset$1(t1);
        _this._tabs$_scrollController.animateTo$3$curve$duration(offset, C.Cubic_glB, C.Duration_300000);
      }
      _this.setState$1(new B._TabBarState__handleTabControllerTick_closure());
    },
    _saveTabOffsets$3(tabOffsets, textDirection, width) {
      var t1;
      type$.List_double._as(tabOffsets);
      this.___TabBarState__tabStripWidth_A = width;
      t1 = this._indicatorPainter;
      if (t1 != null) {
        t1.set$_currentTabOffsets(type$.nullable_List_double._as(tabOffsets));
        t1._currentTextDirection = textDirection;
      }
    },
    _buildStyledTab$4(child, isSelected, animation, defaults) {
      var _null = null;
      type$.Animation_double._as(animation);
      this._widget.toString;
      return B._TabStyle$(animation, child, defaults, true, isSelected, _null, _null, _null, _null);
    },
    _debugScheduleCheckHasValidTabsCount$0() {
      if (this._debugHasScheduledValidTabsCountCheck)
        return true;
      A.BindingBase_checkInstance($.WidgetsBinding__instance, type$.WidgetsBinding).addPostFrameCallback$2$debugLabel(new B._TabBarState__debugScheduleCheckHasValidTabsCount_closure(this), "TabBar.tabsCountCheck");
      return this._debugHasScheduledValidTabsCountCheck = true;
    },
    _debugTabAlignmentIsValid$1(tabAlignment) {
      A.assertHelper(new B._TabBarState__debugTabAlignmentIsValid_closure(this, tabAlignment).call$0());
      return true;
    },
    build$1(context) {
      var tabBarTheme, effectiveTabAlignment, wrappedTabs, t1, previousIndex, t2, t3, animation, tabIndex, tabCount, t4, t5, t6, t7, t8, t9, index, t10, t11, effectiveMouseCursor, defaultOverlay, t12, t13, t14, effectivePadding, tabBar, dividerColor, _this = this, _null = null;
      A.debugCheckHasMaterialLocalizations(context);
      _this._debugScheduleCheckHasValidTabsCount$0();
      A.Theme_of(context);
      tabBarTheme = B.TabBarTheme_of(context);
      _this._widget.toString;
      effectiveTabAlignment = _this.get$_tabs$_defaults().get$tabAlignment();
      _this._debugTabAlignmentIsValid$1(effectiveTabAlignment);
      A.debugCheckHasMaterialLocalizations(context);
      A.Localizations_of(context, C.Type_MaterialLocalizations_nEU, type$.MaterialLocalizations).toString;
      if (_this._tabs$_controller.length === 0) {
        _this._widget.toString;
        return A.LimitedBox$(new A.SizedBox(1 / 0, 48, _null, _null), 1 / 0, 0);
      }
      wrappedTabs = A.List_List$generate(_this._widget.tabs.length, new B._TabBarState_build_closure(_this, tabBarTheme), true, type$.Widget);
      t1 = _this._tabs$_controller;
      if (t1 != null) {
        previousIndex = t1._previousIndex;
        t2 = t1._indexIsChangingCount;
        t3 = _this._currentIndex;
        if (t2 !== 0) {
          A.assertHelper(t3 !== previousIndex);
          t1 = _this._tabs$_controller;
          t1.toString;
          animation = new B._ChangeAnimation(t1);
          t1 = _this._currentIndex;
          t1.toString;
          if (!(t1 < wrappedTabs.length))
            return A.ioore(wrappedTabs, t1);
          C.JSArray_methods.$indexSet(wrappedTabs, t1, _this._buildStyledTab$4(wrappedTabs[t1], true, animation, _this.get$_tabs$_defaults()));
          if (!(previousIndex < wrappedTabs.length))
            return A.ioore(wrappedTabs, previousIndex);
          C.JSArray_methods.$indexSet(wrappedTabs, previousIndex, _this._buildStyledTab$4(wrappedTabs[previousIndex], false, animation, _this.get$_tabs$_defaults()));
        } else {
          t3.toString;
          if (!(t3 < wrappedTabs.length))
            return A.ioore(wrappedTabs, t3);
          C.JSArray_methods.$indexSet(wrappedTabs, t3, _this._buildStyledTab$4(wrappedTabs[t3], true, new B._DragAnimation(t1, t3), _this.get$_tabs$_defaults()));
          t1 = _this._currentIndex;
          t1.toString;
          if (t1 > 0) {
            tabIndex = t1 - 1;
            t1 = _this._tabs$_controller;
            t1.toString;
            t2 = A._setArrayType([], type$.JSArray_of_void_Function_AnimationStatus);
            if (!(tabIndex < wrappedTabs.length))
              return A.ioore(wrappedTabs, tabIndex);
            C.JSArray_methods.$indexSet(wrappedTabs, tabIndex, _this._buildStyledTab$4(wrappedTabs[tabIndex], false, new A.ReverseAnimation(new B._DragAnimation(t1, tabIndex), new A.ObserverList(t2, type$.ObserverList_of_void_Function_AnimationStatus), 0), _this.get$_tabs$_defaults()));
          }
          t1 = _this._currentIndex;
          t1.toString;
          if (t1 < _this._widget.tabs.length - 1) {
            tabIndex = t1 + 1;
            t1 = _this._tabs$_controller;
            t1.toString;
            t2 = A._setArrayType([], type$.JSArray_of_void_Function_AnimationStatus);
            if (!(tabIndex < wrappedTabs.length))
              return A.ioore(wrappedTabs, tabIndex);
            C.JSArray_methods.$indexSet(wrappedTabs, tabIndex, _this._buildStyledTab$4(wrappedTabs[tabIndex], false, new A.ReverseAnimation(new B._DragAnimation(t1, tabIndex), new A.ObserverList(t2, type$.ObserverList_of_void_Function_AnimationStatus), 0), _this.get$_tabs$_defaults()));
          }
        }
      }
      tabCount = _this._widget.tabs.length;
      for (t1 = type$.JSArray_Widget, t2 = tabBarTheme.splashBorderRadius, t3 = tabBarTheme.overlayColor, t4 = type$._WidgetStatePropertyWith_nullable_Color, t5 = type$.nullable_MouseCursor, t6 = type$.WidgetState, t7 = type$.Set_WidgetState, t8 = t2 == null, t9 = t3 == null, index = 0; index < tabCount; ++index) {
        t10 = A.LinkedHashSet_LinkedHashSet$_empty(t6);
        if (index === _this._currentIndex)
          t10.add$1(0, C.WidgetState_4);
        _this._widget.toString;
        t11 = A.WidgetStateProperty_resolveAs(_null, t10, t5);
        if (t11 == null)
          effectiveMouseCursor = _null;
        else
          effectiveMouseCursor = t11;
        if (effectiveMouseCursor == null)
          effectiveMouseCursor = A.WidgetStateMouseCursor__clickable(t7._as(t10));
        defaultOverlay = new A._WidgetStatePropertyWith(new B._TabBarState_build_closure0(_this, t10), t4);
        _this._widget.toString;
        t10 = t9 ? defaultOverlay : t3;
        t11 = _this.get$_tabs$_defaults().get$splashFactory();
        _this._widget.toString;
        t12 = t8 ? _this.get$_tabs$_defaults().splashBorderRadius : t2;
        _this._widget.toString;
        if (!(index < wrappedTabs.length))
          return A.ioore(wrappedTabs, index);
        t13 = wrappedTabs[index];
        t14 = _this._currentIndex;
        C.JSArray_methods.$indexSet(wrappedTabs, index, A.InkWell$(false, t12, true, new A.Padding(new A.EdgeInsets(0, 0, 0, 2), new A.Stack(C.AlignmentDirectional_m1_m1, _null, C.StackFit_0, C.Clip_1, A._setArrayType([t13, new A.Semantics(A.SemanticsProperties$(_null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, index === t14, _null, _null, _null, _null, _null, _null, _null, _null), false, false, false, false, _null, _null)], t1), _null), _null), _null, true, _null, _null, _null, _null, effectiveMouseCursor, _null, _null, _null, _null, new B._TabBarState_build_closure1(_this, index), t10, _null, _null, t11, _null));
        _this._widget.toString;
      }
      t1 = _this._indicatorPainter;
      _this._widget.toString;
      t2 = _this.get$_tabs$_defaults();
      t3 = effectiveTabAlignment === D.TabAlignment_2 ? C.MainAxisSize_1 : C.MainAxisSize_0;
      t1 = A.CustomPaint$(B._TabStyle$(C.C__AlwaysDismissedAnimation, new B._TabLabelBar(_this.get$_saveTabOffsets(), C.Axis_0, C.MainAxisAlignment_0, t3, C.CrossAxisAlignment_2, _null, C.VerticalDirection_1, _null, 0, wrappedTabs, _null), t2, true, false, _null, _null, _null, _null), _null, _null, t1, C.Size_0_0);
      t2 = A.SemanticsProperties$(_null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null, C.SemanticsRole_2, _null, _null, _null, _null, _null, _null, _null, _null, _null, _null);
      _this._widget.toString;
      if (effectiveTabAlignment === D.TabAlignment_1)
        effectivePadding = D.EdgeInsetsDirectional_52_0_0_0.add$1(0, C.EdgeInsets_0_0_0_0);
      else
        effectivePadding = _null;
      if (_this._tabs$_scrollController == null) {
        t3 = new B._TabBarScrollController(_this, _null, _null, A._setArrayType([], type$.JSArray_ScrollPosition), $.$get$ChangeNotifier__emptyListeners());
        A.ChangeNotifier_maybeDispatchObjectCreation(t3);
        _this._tabs$_scrollController = t3;
      }
      t3 = A.ScrollConfiguration_of(context).copyWith$1$overscroll(false);
      _this._widget.toString;
      tabBar = A.ScrollConfiguration$(t3, A.SingleChildScrollView$(new A.Semantics(t2, false, false, false, false, t1, _null), _this._tabs$_scrollController, C.DragStartBehavior_1, effectivePadding, _null, C.Axis_0));
      $label0$0: {
        if (D.TabAlignment_3 === effectiveTabAlignment) {
          t1 = C.Alignment_0_0;
          break $label0$0;
        }
        if (D.TabAlignment_0 === effectiveTabAlignment || D.TabAlignment_1 === effectiveTabAlignment || D.TabAlignment_2 === effectiveTabAlignment) {
          t1 = C.AlignmentDirectional_m1_0;
          break $label0$0;
        }
        t1 = _null;
      }
      dividerColor = tabBarTheme.dividerColor;
      if (dividerColor == null) {
        t2 = _this.get$_tabs$_defaults().get$dividerColor();
        t2.toString;
        dividerColor = t2;
      }
      _this._widget.toString;
      t2 = _this.get$_tabs$_defaults().get$dividerHeight();
      t2.toString;
      t3 = t2 > 0;
      tabBar = A.Align$(t1, tabBar, 1, _null, t3 ? _null : 1);
      if (!dividerColor.$eq(0, C.Color_Edl) && t3)
        tabBar = A.CustomPaint$(tabBar, _null, _null, new B._DividerPainter(dividerColor, t2, _null), C.Size_0_0);
      A.debugCheckHasMediaQuery(context);
      t1 = A.InheritedModel_inheritFrom(context, _null, type$.MediaQuery).data;
      _this._widget.toString;
      return A.MediaQuery$(tabBar, t1.copyWith$1$textScaler(tabBarTheme.textScaler));
    },
    set$___TabBarState__tabKeys_A(___TabBarState__tabKeys_A) {
      this.___TabBarState__tabKeys_A = type$.List_GlobalKey_State_StatefulWidget._as(___TabBarState__tabKeys_A);
    },
    set$___TabBarState__labelPaddings_A(___TabBarState__labelPaddings_A) {
      this.___TabBarState__labelPaddings_A = type$.List_EdgeInsetsGeometry._as(___TabBarState__labelPaddings_A);
    }
  };
  B._TabsPrimaryDefaultsM3.prototype = {
    get$_tabs$_colors() {
      var t1, _this = this,
        value = _this.___TabsPrimaryDefaultsM3__colors_FI;
      if (value === $) {
        t1 = A.Theme_of(_this.context);
        _this.___TabsPrimaryDefaultsM3__colors_FI !== $ && A.throwLateFieldADI("_colors");
        value = _this.___TabsPrimaryDefaultsM3__colors_FI = t1.colorScheme;
      }
      return value;
    },
    get$_tabs$_textTheme() {
      var t1, _this = this,
        value = _this.___TabsPrimaryDefaultsM3__textTheme_FI;
      if (value === $) {
        t1 = A.Theme_of(_this.context);
        _this.___TabsPrimaryDefaultsM3__textTheme_FI !== $ && A.throwLateFieldADI("_textTheme");
        value = _this.___TabsPrimaryDefaultsM3__textTheme_FI = t1.textTheme;
      }
      return value;
    },
    get$dividerColor() {
      var t1 = this.get$_tabs$_colors(),
        t2 = t1._outlineVariant;
      if (t2 == null) {
        t2 = t1._onBackground;
        t1 = t2 == null ? t1.onSurface : t2;
      } else
        t1 = t2;
      return t1;
    },
    get$dividerHeight() {
      return 1;
    },
    get$indicatorColor() {
      return this.get$_tabs$_colors().primary;
    },
    get$labelColor() {
      return this.get$_tabs$_colors().primary;
    },
    get$labelStyle() {
      return this.get$_tabs$_textTheme().titleSmall;
    },
    get$unselectedLabelColor() {
      var t1 = this.get$_tabs$_colors(),
        t2 = t1._onSurfaceVariant;
      return t2 == null ? t1.onSurface : t2;
    },
    get$unselectedLabelStyle() {
      return this.get$_tabs$_textTheme().titleSmall;
    },
    get$overlayColor() {
      return new A._WidgetStatePropertyWith(new B._TabsPrimaryDefaultsM3_overlayColor_closure(this), type$._WidgetStatePropertyWith_nullable_Color);
    },
    get$splashFactory() {
      return A.Theme_of(this.context).splashFactory;
    },
    get$tabAlignment() {
      return D.TabAlignment_1;
    }
  };
  B.__ChangeAnimation_Animation_AnimationWithParentMixin.prototype = {};
  B.__DragAnimation_Animation_AnimationWithParentMixin.prototype = {};
  var typesOffset = hunkHelpers.updateTypes(["~()", "Future<~>()", "NutritionItem(@)", "double(double,NutritionItem)", "Tab(String)", "bool(ScrollNotification)", "bool(OverscrollIndicatorNotification)", "~(List<double>,TextDirection,double)"]);
  B.__DataPageState_State_TickerProviderStateMixin_dispose_closure.prototype = {
    call$0() {
      var t3, t4,
        t1 = this.$this,
        t2 = t1.TickerProviderStateMixin__tickers;
      if (t2 != null)
        for (t2 = A._LinkedHashSetIterator$(t2, t2._collection$_modifications, A._instanceType(t2)._precomputed1), t3 = t2.$ti._precomputed1; t2.moveNext$0();) {
          t4 = t2._collection$_current;
          if (t4 == null)
            t4 = t3._as(t4);
          if (t4._ticker$_future != null)
            throw A.wrapException(A.FlutterError$fromParts(A._setArrayType([A.ErrorSummary$(t1.toString$0(0) + " was disposed with an active Ticker."), A.ErrorDescription$(A.getRuntimeTypeOfDartObject(t1).toString$0(0) + string$._creat), A.ErrorHint$(string$.Ticker), t4.describeForError$1("The offending ticker was")], type$.JSArray_DiagnosticsNode)));
        }
      return true;
    },
    $signature: 1
  };
  B._DataPageState_initState_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._sC,
        t3 = t2.get$position(0)._pixels;
      t3.toString;
      t2 = t2.get$position(0)._maxScrollExtent;
      t2.toString;
      return t3 >= t2 - 100 && !t1._loading && t1._hasMore ? t1._loadMore$0() : null;
    },
    $signature: 0
  };
  B._DataPageState_initState_closure0.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1.get$_tC()._indexIsChangingCount !== 0)
        return;
      t1.setState$1(new B._DataPageState_initState__closure(t1));
      t1._refresh$0();
    },
    $signature: 0
  };
  B._DataPageState_initState__closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._types,
        t3 = t1.get$_tC()._tab_controller$_index;
      if (!(t3 < 3))
        return A.ioore(t2, t3);
      return t1.___DataPageState__filterType_AI = t2[t3];
    },
    $signature: 0
  };
  B._DataPageState__loadMore_closure.prototype = {
    call$0() {
      return this.$this._loading = true;
    },
    $signature: 0
  };
  B._DataPageState__loadMore_closure0.prototype = {
    call$1(r) {
      var t1, t2;
      type$.Map_String_dynamic._as(r);
      t1 = this.$this;
      if (t1._searchKeyword.length === 0)
        t1 = true;
      else {
        t2 = J.$index$asx(r, "data");
        t1 = t2 == null ? null : C.JSString_methods.contains$1(J.toString$0$(t2).toLowerCase(), t1._searchKeyword.toLowerCase());
        t1 = t1 === true;
      }
      return t1;
    },
    $signature: 307
  };
  B._DataPageState__loadMore_closure1.prototype = {
    call$0() {
      return this.$this._loading = false;
    },
    $signature: 0
  };
  B._DataPageState__refresh_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      C.JSArray_methods.clear$0(t1._data_page$_records);
      t1._data_page$_skip = 0;
      t1._hasMore = true;
    },
    $signature: 0
  };
  B._DataPageState__refreshRecord_closure.prototype = {
    call$0() {
      var t1 = this.$this._data_page$_records,
        index = C.JSArray_methods.indexWhere$1(t1, new B._DataPageState__refreshRecord__closure(this.record));
      if (index !== -1)
        C.JSArray_methods.$indexSet(t1, index, this.newData);
    },
    $signature: 0
  };
  B._DataPageState__refreshRecord__closure.prototype = {
    call$1(r) {
      var _s10_ = "created_at";
      return J.$eq$(J.$index$asx(type$.Map_String_dynamic._as(r), _s10_), J.$index$asx(this.record, _s10_));
    },
    $signature: 307
  };
  B._DataPageState__buildRecordRow_closure.prototype = {
    call$1(e) {
      return E.NutritionItem_NutritionItem$fromJson(type$.Map_String_dynamic._as(e));
    },
    $signature: typesOffset + 2
  };
  B._DataPageState__buildRecordRow_closure0.prototype = {
    call$2(sum, item) {
      return A._asDouble(sum) + type$.NutritionItem._as(item).nutrientAmount$1("\u70ed\u91cf");
    },
    $signature: typesOffset + 3
  };
  B._DataPageState__buildRecordRow_closure1.prototype = {
    call$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1, t2, t3, t4;
      var $async$call$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self.record;
              t2 = J.getInterceptor$asx(t1);
              t3 = type$.String;
              t4 = type$.dynamic;
              A.ExtensionDialog_dialog($.$get$Get(), new E.RecordDetailDialog(A.LinkedHashMap_LinkedHashMap$_literal(["event", "record_status", "data", A.LinkedHashMap_LinkedHashMap$_literal(["type", t2.$index(t1, "_type"), "created_at", t2.$index(t1, "created_at")], t3, t4)], t3, t4), new B._DataPageState__buildRecordRow__closure($async$self.$this, t1), null), t4);
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$0, $async$completer);
    },
    $signature: 14
  };
  B._DataPageState__buildRecordRow__closure.prototype = {
    call$0() {
      return this.$this._refreshRecord$1(this.record);
    },
    $signature: 0
  };
  B._DataPageState_build_closure.prototype = {
    call$1(e) {
      A._asString(e);
      return new B.Tab(e, null);
    },
    $signature: typesOffset + 4
  };
  B._DataPageState_build_closure0.prototype = {
    call$1(v) {
      var t1 = this.$this;
      t1._searchKeyword = v;
      t1._refresh$0();
    },
    $signature: 35
  };
  B._DataPageState_build_closure1.prototype = {
    call$2(context, index) {
      var t1, t2, t3, _null = null;
      type$.BuildContext._as(context);
      A._asInt(index);
      t1 = this.$this;
      t2 = t1._data_page$_records;
      t3 = t2.length;
      if (index >= t3)
        return t1._hasMore ? new A.SizedBox(_null, 60, A.Center$(E.CircularProgressIndicator$(_null, _null, _null, _null, _null, _null, _null, _null, _null, _null), _null, _null, _null), _null) : D.SizedBox_GFq;
      if (t3 === 0)
        return D.SizedBox_0Q1;
      if (!(index >= 0))
        return A.ioore(t2, index);
      return t1._buildRecordRow$1(t2[index]);
    },
    $signature: 137
  };
  B._RefreshProgressIndicatorState__buildAnimation_closure.prototype = {
    call$2(context, child) {
      var t1, t2, t3, t4;
      type$.BuildContext._as(context);
      type$.nullable_Widget._as(child);
      t1 = this.$this;
      t2 = $.$get$_CircularProgressIndicatorState__strokeHeadTween();
      t3 = t1.___CircularProgressIndicatorState__controller_A;
      t3 === $ && A.throwLateFieldNI("_controller");
      t4 = type$.Animation_double;
      t3 = t2.transform$1(0, t4._as(t3).get$value(0));
      if (typeof t3 !== "number")
        return A.iae(t3);
      return t1._buildMaterialIndicator$5(context, 1.05 * t3, $.$get$_CircularProgressIndicatorState__strokeTailTween().transform$1(0, t4._as(t1.___CircularProgressIndicatorState__controller_A).get$value(0)), $.$get$_CircularProgressIndicatorState__offsetTween().transform$1(0, t4._as(t1.___CircularProgressIndicatorState__controller_A).get$value(0)), $.$get$_CircularProgressIndicatorState__rotationTween().transform$1(0, t4._as(t1.___CircularProgressIndicatorState__controller_A).get$value(0)));
    },
    $signature: 72
  };
  B.RefreshIndicatorState__handleScrollNotification_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      t1._refresh_indicator$_status = D.RefreshIndicatorStatus_0;
      t1._widget.toString;
    },
    $signature: 0
  };
  B.RefreshIndicatorState__dismiss_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      t1._refresh_indicator$_status = this.newMode;
      t1._widget.toString;
    },
    $signature: 0
  };
  B.RefreshIndicatorState__dismiss_closure0.prototype = {
    call$0() {
      this.$this._refresh_indicator$_status = null;
    },
    $signature: 0
  };
  B.RefreshIndicatorState__show_closure.prototype = {
    call$1(value) {
      var t1 = this.$this;
      if (t1._framework$_element != null && t1._refresh_indicator$_status === D.RefreshIndicatorStatus_2) {
        t1.setState$1(new B.RefreshIndicatorState__show__closure(t1));
        t1._widget.onRefresh$0().whenComplete$1(new B.RefreshIndicatorState__show__closure0(t1, this.completer));
      }
    },
    $signature: 26
  };
  B.RefreshIndicatorState__show__closure.prototype = {
    call$0() {
      this.$this._refresh_indicator$_status = D.RefreshIndicatorStatus_3;
    },
    $signature: 0
  };
  B.RefreshIndicatorState__show__closure0.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1._framework$_element != null && t1._refresh_indicator$_status === D.RefreshIndicatorStatus_3) {
        this.completer.complete$0(0);
        t1._dismiss$1(D.RefreshIndicatorStatus_4);
      }
    },
    $signature: 11
  };
  B.RefreshIndicatorState_build_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._refresh_indicator$_status,
        t3 = t1._dragOffset == null;
      if (t2 == null) {
        A.assertHelper(t3);
        A.assertHelper(t1._isIndicatorAtTop == null);
      } else {
        A.assertHelper(!t3);
        A.assertHelper(t1._isIndicatorAtTop != null);
      }
      return true;
    },
    $signature: 1
  };
  B.RefreshIndicatorState_build_closure0.prototype = {
    call$2(context, child) {
      var t1, t2, t3, t4, materialIndicator, cupertinoIndicator, _null = null;
      type$.BuildContext._as(context);
      type$.nullable_Widget._as(child);
      t1 = this.$this;
      t1._widget.toString;
      A.debugCheckHasMaterialLocalizations(context);
      t2 = A.Localizations_of(context, C.Type_MaterialLocalizations_nEU, type$.MaterialLocalizations);
      t2.toString;
      t2 = t2.get$refreshIndicatorSemanticLabel();
      t1._widget.toString;
      if (this.showIndeterminateIndicator)
        t3 = _null;
      else {
        t3 = t1.__RefreshIndicatorState__value_A;
        t3 === $ && A.throwLateFieldNI("_value");
        t4 = type$.Animation_double._as(t3.parent);
        t4 = t3._evaluatable.transform$1(0, t4.get$value(t4));
        t3 = t4;
      }
      t4 = t1.__RefreshIndicatorState__valueColor_A;
      t4 === $ && A.throwLateFieldNI("_valueColor");
      t1._widget.toString;
      materialIndicator = new B.RefreshProgressIndicator(2, 2.5, _null, _null, t3, _null, _null, t4, t2, _null, _null);
      cupertinoIndicator = A.CupertinoActivityIndicator$(_null, _null);
      switch (0) {
        case 0:
          return materialIndicator;
      }
    },
    $signature: 72
  };
  B._RefreshIndicatorState_State_TickerProviderStateMixin_dispose_closure.prototype = {
    call$0() {
      var t3, t4,
        t1 = this.$this,
        t2 = t1.TickerProviderStateMixin__tickers;
      if (t2 != null)
        for (t2 = A._LinkedHashSetIterator$(t2, t2._collection$_modifications, A._instanceType(t2)._precomputed1), t3 = t2.$ti._precomputed1; t2.moveNext$0();) {
          t4 = t2._collection$_current;
          if (t4 == null)
            t4 = t3._as(t4);
          if (t4._ticker$_future != null)
            throw A.wrapException(A.FlutterError$fromParts(A._setArrayType([A.ErrorSummary$(t1.toString$0(0) + " was disposed with an active Ticker."), A.ErrorDescription$(A.getRuntimeTypeOfDartObject(t1).toString$0(0) + string$._creat), A.ErrorHint$(string$.Ticker), t4.describeForError$1("The offending ticker was")], type$.JSArray_DiagnosticsNode)));
        }
      return true;
    },
    $signature: 1
  };
  B.TabController__changeIndex_closure.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1._animationController != null) {
        --t1._indexIsChangingCount;
        t1.notifyListeners$0();
      }
    },
    $signature: 0
  };
  B._TabStyle__resolveWithLabelColor_closure.prototype = {
    call$1(states) {
      var t1, t2, _this = this;
      if (type$.Set_WidgetState._as(states).contains$1(0, C.WidgetState_4)) {
        t1 = _this._box_0;
        t2 = _this.animation;
        t2 = A.Color_lerp(t1.selectedColor, t1.unselectedColor, t2.get$value(t2));
        t2.toString;
        return t2;
      }
      t1 = _this._box_0;
      t2 = _this.animation;
      t2 = A.Color_lerp(t1.unselectedColor, t1.selectedColor, t2.get$value(t2));
      t2.toString;
      return t2;
    },
    $signature: 7
  };
  B._TabBarState_initState_closure.prototype = {
    call$1(tab) {
      type$.Widget._as(tab);
      return new A.LabeledGlobalKey(null, type$.LabeledGlobalKey_State_StatefulWidget);
    },
    $signature: 860
  };
  B._TabBarState__updateTabController_closure.prototype = {
    call$0() {
      if (this.newController == null) {
        var t1 = this.$this;
        throw A.wrapException(A.FlutterError_FlutterError("No TabController for " + A.getRuntimeTypeOfDartObject(t1.get$widget()).toString$0(0) + ".\nWhen creating a " + A.getRuntimeTypeOfDartObject(t1.get$widget()).toString$0(0) + ', you must either provide an explicit TabController using the "controller" property, or you must ensure that there is a DefaultTabController above the ' + A.getRuntimeTypeOfDartObject(t1.get$widget()).toString$0(0) + ".\nIn this case, there was neither an explicit controller nor a default controller."));
      }
      return true;
    },
    $signature: 1
  };
  B._TabBarState__handleTabControllerTick_closure.prototype = {
    call$0() {
    },
    $signature: 0
  };
  B._TabBarState__debugScheduleCheckHasValidTabsCount_closure.prototype = {
    call$1(duration) {
      var t1;
      type$.Duration._as(duration);
      t1 = this.$this;
      t1._debugHasScheduledValidTabsCountCheck = false;
      if (t1._framework$_element == null)
        return;
      A.assertHelper(new B._TabBarState__debugScheduleCheckHasValidTabsCount__closure(t1).call$0());
    },
    $signature: 3
  };
  B._TabBarState__debugScheduleCheckHasValidTabsCount__closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = t1._tabs$_controller.length;
      if (t2 !== t1._widget.tabs.length)
        throw A.wrapException(A.FlutterError_FlutterError("Controller's length property (" + t2 + ") does not match the number of tabs (" + t1.get$widget().tabs.length + ") present in TabBar's tabs property."));
      return true;
    },
    $signature: 1
  };
  B._TabBarState__debugTabAlignmentIsValid_closure.prototype = {
    call$0() {
      this.$this._widget.toString;
      var t1 = this.tabAlignment;
      if (t1 === D.TabAlignment_2)
        throw A.wrapException(A.FlutterError_FlutterError(t1.toString$0(0) + " is only valid for non-scrollable tab bars."));
      return true;
    },
    $signature: 1
  };
  B._TabBarState_build_closure.prototype = {
    call$1(index) {
      var padding, tab, t3,
        t1 = this.$this,
        t2 = t1._widget;
      t2.toString;
      padding = this.tabBarTheme.labelPadding;
      if (padding == null)
        padding = C.EdgeInsets_16_0_16_0;
      t2 = t2.tabs;
      if (!(index < t2.length))
        return A.ioore(t2, index);
      tab = t2[index];
      if (type$.PreferredSizeWidget._is(tab) && tab.get$preferredSize()._dy === 46 && t1._widget.get$tabHasTextAndIcon())
        padding = padding.add$1(0, D.EdgeInsets_0_13_0_13);
      t2 = t1.___TabBarState__labelPaddings_A;
      t2 === $ && A.throwLateFieldNI("_labelPaddings");
      C.JSArray_methods.$indexSet(t2, index, padding);
      t2 = t1.___TabBarState__labelPaddings_A;
      if (!(index < t2.length))
        return A.ioore(t2, index);
      t2 = t2[index];
      t3 = t1.___TabBarState__tabKeys_A;
      t3 === $ && A.throwLateFieldNI("_tabKeys");
      if (!(index < t3.length))
        return A.ioore(t3, index);
      t3 = t3[index];
      t1 = t1._widget.tabs;
      if (!(index < t1.length))
        return A.ioore(t1, index);
      return A.Center$(new A.Padding(t2, new A.KeyedSubtree(t1[index], t3), null), 1, null, null);
    },
    $signature: 861
  };
  B._TabBarState_build_closure0.prototype = {
    call$1(states) {
      var t1,
        effectiveStates = this.selectedState;
      effectiveStates.addAll$1(0, type$.Set_WidgetState._as(states));
      t1 = this.$this.get$_tabs$_defaults().get$overlayColor();
      return t1 == null ? null : t1.resolve$1(effectiveStates);
    },
    $signature: 68
  };
  B._TabBarState_build_closure1.prototype = {
    call$0() {
      var t4,
        t1 = this.$this,
        t2 = this.index,
        t3 = t1._widget.tabs.length;
      A.assertHelper(t2 < t3);
      t3 = t1._tabs$_controller;
      t4 = t3._animationDuration;
      t3._changeIndex$3$curve$duration(t2, C.Cubic_glB, t4);
      t1._widget.toString;
    },
    $signature: 0
  };
  B._TabsPrimaryDefaultsM3_overlayColor_closure.prototype = {
    call$1(states) {
      var _this = this;
      type$.Set_WidgetState._as(states);
      if (states.contains$1(0, C.WidgetState_4)) {
        if (states.contains$1(0, C.WidgetState_2))
          return _this.$this.get$_tabs$_colors().primary.withOpacity$1(0.1);
        if (states.contains$1(0, C.WidgetState_0))
          return _this.$this.get$_tabs$_colors().primary.withOpacity$1(0.08);
        if (states.contains$1(0, C.WidgetState_1))
          return _this.$this.get$_tabs$_colors().primary.withOpacity$1(0.1);
        return null;
      }
      if (states.contains$1(0, C.WidgetState_2))
        return _this.$this.get$_tabs$_colors().primary.withOpacity$1(0.1);
      if (states.contains$1(0, C.WidgetState_0))
        return _this.$this.get$_tabs$_colors().onSurface.withOpacity$1(0.08);
      if (states.contains$1(0, C.WidgetState_1))
        return _this.$this.get$_tabs$_colors().onSurface.withOpacity$1(0.1);
      return null;
    },
    $signature: 68
  };
  (function aliases() {
    var _ = B.__DataPageState_State_TickerProviderStateMixin.prototype;
    _.super$__DataPageState_State_TickerProviderStateMixin$dispose = _.dispose$0;
    _ = B._RefreshIndicatorState_State_TickerProviderStateMixin.prototype;
    _.super$_RefreshIndicatorState_State_TickerProviderStateMixin$dispose = _.dispose$0;
  })();
  (function installTearOffs() {
    var _instance_0_u = hunkHelpers._instance_0u,
      _instance_1_u = hunkHelpers._instance_1u,
      _instance = hunkHelpers.installInstanceTearOff;
    _instance_0_u(B._DataPageState.prototype, "get$_refresh", "_refresh$0", 1);
    var _;
    _instance_1_u(_ = B.RefreshIndicatorState.prototype, "get$_refresh_indicator$_handleScrollNotification", "_refresh_indicator$_handleScrollNotification$1", 5);
    _instance_1_u(_, "get$_handleIndicatorNotification", "_handleIndicatorNotification$1", 6);
    _instance_0_u(B.TabController.prototype, "get$dispose", "dispose$0", 0);
    _instance_0_u(B._IndicatorPainter.prototype, "get$markNeedsPaint", "markNeedsPaint$0", 0);
    _instance_0_u(_ = B._TabBarState.prototype, "get$_handleTabControllerAnimationTick", "_handleTabControllerAnimationTick$0", 0);
    _instance_0_u(_, "get$_handleTabControllerTick", "_handleTabControllerTick$0", 0);
    _instance(_, "get$_saveTabOffsets", 0, 3, null, ["call$3"], ["_saveTabOffsets$3"], 7, 0, 0);
  })();
  (function inheritance() {
    var _mixinHard = hunkHelpers.mixinHard,
      _mixin = hunkHelpers.mixin,
      _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(A.Closure0Args, [B.__DataPageState_State_TickerProviderStateMixin_dispose_closure, B._DataPageState_initState_closure, B._DataPageState_initState_closure0, B._DataPageState_initState__closure, B._DataPageState__loadMore_closure, B._DataPageState__loadMore_closure1, B._DataPageState__refresh_closure, B._DataPageState__refreshRecord_closure, B._DataPageState__buildRecordRow_closure1, B._DataPageState__buildRecordRow__closure, B.RefreshIndicatorState__handleScrollNotification_closure, B.RefreshIndicatorState__dismiss_closure, B.RefreshIndicatorState__dismiss_closure0, B.RefreshIndicatorState__show__closure, B.RefreshIndicatorState__show__closure0, B.RefreshIndicatorState_build_closure, B._RefreshIndicatorState_State_TickerProviderStateMixin_dispose_closure, B.TabController__changeIndex_closure, B._TabBarState__updateTabController_closure, B._TabBarState__handleTabControllerTick_closure, B._TabBarState__debugScheduleCheckHasValidTabsCount__closure, B._TabBarState__debugTabAlignmentIsValid_closure, B._TabBarState_build_closure1]);
    _inheritMany(A.StatefulWidget, [B.DataPage, B.RefreshIndicator, B.TabBar]);
    _inheritMany(A.State, [B.__DataPageState_State_TickerProviderStateMixin, B._RefreshIndicatorState_State_TickerProviderStateMixin, B._TabBarState]);
    _inherit(B._DataPageState, B.__DataPageState_State_TickerProviderStateMixin);
    _inheritMany(A.Closure, [B._DataPageState__loadMore_closure0, B._DataPageState__refreshRecord__closure, B._DataPageState__buildRecordRow_closure, B._DataPageState_build_closure, B._DataPageState_build_closure0, B.RefreshIndicatorState__show_closure, B._TabStyle__resolveWithLabelColor_closure, B._TabBarState_initState_closure, B._TabBarState__debugScheduleCheckHasValidTabsCount_closure, B._TabBarState_build_closure, B._TabBarState_build_closure0, B._TabsPrimaryDefaultsM3_overlayColor_closure]);
    _inheritMany(A.Closure2Args, [B._DataPageState__buildRecordRow_closure0, B._DataPageState_build_closure1, B._RefreshProgressIndicatorState__buildAnimation_closure, B.RefreshIndicatorState_build_closure0]);
    _inherit(B._RefreshProgressIndicatorPainter, A._CircularProgressIndicatorPainter);
    _inherit(B.RefreshProgressIndicator, A.CircularProgressIndicator);
    _inherit(B._RefreshProgressIndicatorState, A._CircularProgressIndicatorState);
    _inheritMany(A._Enum, [B.RefreshIndicatorStatus, B.RefreshIndicatorTriggerMode, B._IndicatorType, B.TabAlignment, B.TabIndicatorAnimation]);
    _inherit(B.RefreshIndicatorState, B._RefreshIndicatorState_State_TickerProviderStateMixin);
    _inherit(B.TabController, A.ChangeNotifier);
    _inherit(B.UnderlineTabIndicator, A.Decoration);
    _inherit(B._UnderlinePainter, A.BoxPainter);
    _inherit(B.Tab, A.StatelessWidget);
    _inherit(B._TabStyle, A.AnimatedWidget);
    _inherit(B._TabLabelBarRenderer, A.RenderFlex);
    _inherit(B._TabLabelBar, A.Flex);
    _inheritMany(A.CustomPainter, [B._DividerPainter, B._IndicatorPainter]);
    _inheritMany(A.Animation, [B.__ChangeAnimation_Animation_AnimationWithParentMixin, B.__DragAnimation_Animation_AnimationWithParentMixin]);
    _inherit(B._ChangeAnimation, B.__ChangeAnimation_Animation_AnimationWithParentMixin);
    _inherit(B._DragAnimation, B.__DragAnimation_Animation_AnimationWithParentMixin);
    _inherit(B._TabBarScrollPosition, A.ScrollPositionWithSingleContext);
    _inherit(B._TabBarScrollController, A.ScrollController);
    _inherit(B._TabsPrimaryDefaultsM3, A.TabBarThemeData);
    _mixinHard(B.__DataPageState_State_TickerProviderStateMixin, A.TickerProviderStateMixin);
    _mixinHard(B._RefreshIndicatorState_State_TickerProviderStateMixin, A.TickerProviderStateMixin);
    _mixin(B.__ChangeAnimation_Animation_AnimationWithParentMixin, A.AnimationWithParentMixin);
    _mixin(B.__DragAnimation_Animation_AnimationWithParentMixin, A.AnimationWithParentMixin);
  })();
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"DataPage":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[],"Diagnosticable":[]},"_DataPageState":{"TickerProviderStateMixin":["DataPage"],"State":["DataPage"],"Diagnosticable":[],"TickerProvider":[],"State.T":"DataPage"},"_RefreshProgressIndicatorPainter":{"_CircularProgressIndicatorPainter":[],"CustomPainter":[],"Listenable":[]},"RefreshProgressIndicator":{"CircularProgressIndicator":[],"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[],"Diagnosticable":[]},"_RefreshProgressIndicatorState":{"State":["CircularProgressIndicator"],"Diagnosticable":[],"TickerProvider":[],"State.T":"CircularProgressIndicator"},"RefreshIndicator":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[],"Diagnosticable":[]},"RefreshIndicatorStatus":{"Enum":[]},"RefreshIndicatorTriggerMode":{"Enum":[]},"_IndicatorType":{"Enum":[]},"RefreshIndicatorState":{"TickerProviderStateMixin":["RefreshIndicator"],"State":["RefreshIndicator"],"Diagnosticable":[],"TickerProvider":[],"State.T":"RefreshIndicator"},"TabController":{"ChangeNotifier":[],"Listenable":[]},"UnderlineTabIndicator":{"Decoration":[],"Diagnosticable":[]},"_UnderlinePainter":{"BoxPainter":[]},"Tab":{"StatelessWidget":[],"PreferredSizeWidget":[],"Widget":[],"DiagnosticableTree":[],"Diagnosticable":[]},"_IndicatorPainter":{"CustomPainter":[],"Listenable":[]},"TabBar":{"StatefulWidget":[],"PreferredSizeWidget":[],"Widget":[],"DiagnosticableTree":[],"Diagnosticable":[]},"TabAlignment":{"Enum":[]},"TabIndicatorAnimation":{"Enum":[]},"_TabStyle":{"AnimatedWidget":[],"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[],"Diagnosticable":[]},"_TabLabelBarRenderer":{"RenderFlex":[],"RenderBoxContainerDefaultsMixin":["RenderBox","FlexParentData"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderBox","FlexParentData"],"RenderObject":[],"DiagnosticableTree":[],"Diagnosticable":[],"HitTestTarget":[],"ContainerRenderObjectMixin.0":"RenderBox","ContainerRenderObjectMixin.1":"FlexParentData","RenderBoxContainerDefaultsMixin.1":"FlexParentData","RenderBoxContainerDefaultsMixin.0":"RenderBox"},"_TabLabelBar":{"MultiChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[],"Diagnosticable":[]},"_DividerPainter":{"CustomPainter":[],"Listenable":[]},"_ChangeAnimation":{"Animation":["double"],"ValueListenable":["double"],"Listenable":[]},"_DragAnimation":{"Animation":["double"],"ValueListenable":["double"],"Listenable":[]},"_TabBarScrollPosition":{"ScrollPosition":[],"ViewportOffset":[],"ChangeNotifier":[],"Listenable":[],"ScrollMetrics":[],"ScrollActivityDelegate":[]},"_TabBarScrollController":{"ScrollController":[],"ChangeNotifier":[],"Listenable":[]},"_TabBarState":{"State":["TabBar"],"Diagnosticable":[],"State.T":"TabBar"},"_TabsPrimaryDefaultsM3":{"TabBarThemeData":[],"Diagnosticable":[]}}'));
  var string$ = {
    _creat: " created a Ticker via its TickerProviderStateMixin, but at the time dispose() was called on the mixin, that Ticker was still active. All Tickers must be disposed before calling super.dispose().",
    Ticker: "Tickers used by AnimationControllers should be disposed by calling dispose() on the AnimationController itself. Otherwise, the ticker will leak."
  };
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      AlwaysStoppedAnimation_Color: findType("AlwaysStoppedAnimation<Color>"),
      Animatable_double: findType("Animatable<double>"),
      Animation_double: findType("Animation<double>"),
      Animation_nullable_Color: findType("Animation<Color?>"),
      BuildContext: findType("BuildContext"),
      ClipRectLayer: findType("ClipRectLayer"),
      ColorTween: findType("ColorTween"),
      ContainerLayer: findType("ContainerLayer0"),
      Duration: findType("Duration"),
      EdgeInsetsGeometry: findType("EdgeInsetsGeometry"),
      FlexParentData: findType("FlexParentData"),
      GlobalKey_State_StatefulWidget: findType("GlobalKey<State<StatefulWidget>>"),
      HealthDataController: findType("HealthDataController"),
      JSArray_DiagnosticsNode: findType("JSArray<DiagnosticsNode>"),
      JSArray_Map_String_dynamic: findType("JSArray<Map<String,@>>"),
      JSArray_ScrollPosition: findType("JSArray<ScrollPosition>"),
      JSArray_String: findType("JSArray<String>"),
      JSArray_TweenSequenceItem_double: findType("JSArray<TweenSequenceItem<double>>"),
      JSArray_Widget: findType("JSArray<Widget>"),
      JSArray_double: findType("JSArray<double>"),
      JSArray_of_void_Function_AnimationStatus: findType("JSArray<~(AnimationStatus)>"),
      LabeledGlobalKey_State_StatefulWidget: findType("LabeledGlobalKey<State<StatefulWidget>>"),
      List_EdgeInsetsGeometry: findType("List<EdgeInsetsGeometry>"),
      List_GlobalKey_State_StatefulWidget: findType("List<GlobalKey<State<StatefulWidget>>>"),
      List_double: findType("List<double>"),
      List_dynamic: findType("List<@>"),
      Map_String_dynamic: findType("Map<String,@>"),
      MaterialLocalizations: findType("MaterialLocalizations"),
      MediaQuery: findType("MediaQuery"),
      NotificationListener_OverscrollIndicatorNotification: findType("NotificationListener<OverscrollIndicatorNotification>"),
      NotificationListener_ScrollNotification: findType("NotificationListener<ScrollNotification>"),
      NutritionItem: findType("NutritionItem"),
      ObserverList_of_void_Function_AnimationStatus: findType("ObserverList<~(AnimationStatus)>"),
      OverscrollIndicatorNotification: findType("OverscrollIndicatorNotification"),
      PreferredSizeWidget: findType("PreferredSizeWidget"),
      RefreshIndicator: findType("RefreshIndicator"),
      RefreshProgressIndicator: findType("RefreshProgressIndicator"),
      ScrollNotification: findType("ScrollNotification"),
      Set_Ticker: findType("Set<Ticker>"),
      Set_WidgetState: findType("Set<WidgetState>"),
      String: findType("String"),
      TabBar: findType("TabBar"),
      TabBarTheme: findType("TabBarTheme"),
      TextPainter: findType("TextPainter"),
      TweenSequenceItem_double: findType("TweenSequenceItem<double>"),
      Tween_double: findType("Tween<double>"),
      Widget: findType("Widget"),
      WidgetState: findType("WidgetState"),
      WidgetsBinding: findType("WidgetsBinding"),
      _AsyncCompleter_void: findType("_AsyncCompleter<~>"),
      _DividerPainter: findType("_DividerPainter"),
      _Future_void: findType("_Future<~>"),
      _IndicatorPainter: findType("_IndicatorPainter"),
      _RenderInkFeatures: findType("_RenderInkFeatures"),
      _TabLabelBarRenderer: findType("_TabLabelBarRenderer"),
      _WidgetStatePropertyWith_nullable_Color: findType("_WidgetStatePropertyWith<Color?>"),
      bool: findType("bool"),
      double: findType("double"),
      dynamic: findType("@"),
      nullable_Color: findType("Color?"),
      nullable_List_double: findType("List<double>?"),
      nullable_MouseCursor: findType("MouseCursor?"),
      nullable_Widget: findType("Widget?"),
      nullable_void_Function: findType("~()?"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_3_List_double_and_TextDirection_and_double: findType("~(List<double>,TextDirection,double)"),
      void_Function_AnimationStatus: findType("~(AnimationStatus)")
    };
  })();
  (function constants() {
    D.EdgeInsetsDirectional_52_0_0_0 = new A.EdgeInsetsDirectional(52, 0, 0, 0);
    D.EdgeInsets_0_13_0_13 = new A.EdgeInsets(0, 13, 0, 13);
    D.EdgeInsets_12_12_12_12 = new A.EdgeInsets(12, 12, 12, 12);
    D.IconData_57563_MaterialIcons_null_false = new A.IconData(57563, "MaterialIcons", null, false);
    D.IconData_58121_MaterialIcons_null_true = new A.IconData(58121, "MaterialIcons", null, true);
    D.IconData_58674_MaterialIcons_null_false = new A.IconData(58674, "MaterialIcons", null, false);
    D.IconData_58727_MaterialIcons_null_false = new A.IconData(58727, "MaterialIcons", null, false);
    D.Icon_8Ci = new A.Icon(D.IconData_58727_MaterialIcons_null_false, null, null, null, null);
    D.OutlineInputBorder_kIs = new A.OutlineInputBorder(4, C.BorderRadius_nnp, C.BorderSide_ViT);
    D.InputDecoration_dYY = new A.InputDecoration(null, null, null, null, null, null, null, null, null, null, "\u641c\u7d22\u5173\u952e\u5b57", null, null, null, null, true, null, null, null, null, null, null, null, null, null, D.Icon_8Ci, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, D.OutlineInputBorder_kIs, true, null, null, null);
    D.Interval_uxr = new A.Interval(0.1, 0.33, C.C__Linear);
    D.RefreshIndicatorStatus_0 = new B.RefreshIndicatorStatus(0, "drag");
    D.RefreshIndicatorStatus_1 = new B.RefreshIndicatorStatus(1, "armed");
    D.RefreshIndicatorStatus_2 = new B.RefreshIndicatorStatus(2, "snap");
    D.RefreshIndicatorStatus_3 = new B.RefreshIndicatorStatus(3, "refresh");
    D.RefreshIndicatorStatus_4 = new B.RefreshIndicatorStatus(4, "done");
    D.RefreshIndicatorStatus_5 = new B.RefreshIndicatorStatus(5, "canceled");
    D.RefreshIndicatorTriggerMode_1 = new B.RefreshIndicatorTriggerMode(1, "onEdge");
    D.Set_zpZ11 = new A.GeneralConstantSet([C.WidgetState_4], A.findType("GeneralConstantSet<WidgetState>"));
    D.Size_41_41 = new A.Size(41, 41);
    D.Size_EWx = new A.Size(1 / 0, 46);
    D.Text_w6y = new A.Text("\u6ca1\u6709\u8bb0\u5f55", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    D.Center_YWa = new A.Center(C.Alignment_0_0, null, null, D.Text_w6y, null);
    D.SizedBox_0Q1 = new A.SizedBox(null, 60, D.Center_YWa, null);
    D.Text_SPn = new A.Text("\u6ca1\u6709\u66f4\u591a\u6570\u636e", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null);
    D.Center_HZI = new A.Center(C.Alignment_0_0, null, null, D.Text_SPn, null);
    D.SizedBox_GFq = new A.SizedBox(null, 60, D.Center_HZI, null);
    D.TabAlignment_0 = new B.TabAlignment(0, "start");
    D.TabAlignment_1 = new B.TabAlignment(1, "startOffset");
    D.TabAlignment_2 = new B.TabAlignment(2, "fill");
    D.TabAlignment_3 = new B.TabAlignment(3, "center");
    D.TabBarIndicatorSize_1 = new A.TabBarIndicatorSize(1, "label");
    D.TabIndicatorAnimation_0 = new B.TabIndicatorAnimation(0, "linear");
    D.TabIndicatorAnimation_1 = new B.TabIndicatorAnimation(1, "elastic");
    D.Type__IndicatorPainter_Ovs = A.typeLiteral("_IndicatorPainter");
    D._IndicatorType_0 = new B._IndicatorType(0, "material");
  })();
  (function lazyInitializers() {
    var _lazyFinal = hunkHelpers.lazyFinal;
    _lazyFinal($, "RefreshIndicatorState__threeQuarterTween", "$get$RefreshIndicatorState__threeQuarterTween", () => A.Tween$(0, 0.75, type$.double));
    _lazyFinal($, "RefreshIndicatorState__kDragSizeFactorLimitTween", "$get$RefreshIndicatorState__kDragSizeFactorLimitTween", () => A.Tween$(0, 1.5, type$.double));
    _lazyFinal($, "RefreshIndicatorState__oneToZeroTween", "$get$RefreshIndicatorState__oneToZeroTween", () => A.Tween$(1, 0, type$.double));
  })();
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_7", e: "endPart", h: h});
})($__dart_deferred_initializers__, "NGrDziaeD1rSg3pUj8HFJUtFAmQ=");
;