// Generated by dart2js (NullSafetyMode.sound, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.7.2.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_55", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, A, C,
  B = {
    _AbstractImageStreamCompleter$() {
      return new B._AbstractImageStreamCompleter(A._setArrayType([], type$.JSArray_ImageStreamListener), A._setArrayType([], type$.JSArray_of_void_Function_2_Object_and_nullable_StackTrace), A._setArrayType([], type$.JSArray_of_void_Function));
    },
    ImageProvider: function ImageProvider() {
    },
    ImageProvider_resolve_closure: function ImageProvider_resolve_closure(t0, t1, t2) {
      this.$this = t0;
      this.configuration = t1;
      this.stream = t2;
    },
    ImageProvider_resolve_closure0: function ImageProvider_resolve_closure0(t0, t1) {
      this.$this = t0;
      this.stream = t1;
    },
    ImageProvider__createErrorHandlerAndKey_handleError: function ImageProvider__createErrorHandlerAndKey_handleError(t0, t1) {
      this._box_0 = t0;
      this.errorCallback = t1;
    },
    ImageProvider__createErrorHandlerAndKey_closure: function ImageProvider__createErrorHandlerAndKey_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.successCallback = t2;
      _.handleError = t3;
    },
    ImageProvider_resolveStreamForKey_closure: function ImageProvider_resolveStreamForKey_closure(t0) {
      this.stream = t0;
    },
    ImageProvider_resolveStreamForKey_closure0: function ImageProvider_resolveStreamForKey_closure0(t0, t1) {
      this.$this = t0;
      this.key = t1;
    },
    _AbstractImageStreamCompleter: function _AbstractImageStreamCompleter(t0, t1, t2) {
      var _ = this;
      _._image_stream$_listeners = t0;
      _._ephemeralErrorListeners = t1;
      _.debugLabel = _._currentError = _._currentImage = null;
      _._addingInitialListeners = _._hadAtLeastOneListener = false;
      _._keepAliveHandles = 0;
      _._image_stream$_disposed = false;
      _._onLastListenerRemovedCallbacks = t2;
    },
    _ErrorImageCompleter: function _ErrorImageCompleter(t0, t1, t2) {
      var _ = this;
      _._image_stream$_listeners = t0;
      _._ephemeralErrorListeners = t1;
      _.debugLabel = _._currentError = _._currentImage = null;
      _._addingInitialListeners = _._hadAtLeastOneListener = false;
      _._keepAliveHandles = 0;
      _._image_stream$_disposed = false;
      _._onLastListenerRemovedCallbacks = t2;
    },
    ImageStream: function ImageStream() {
      this._image_stream$_listeners = this._image_stream$_completer = null;
    },
    ImageStreamCompleterHandle: function ImageStreamCompleterHandle(t0) {
      this._image_stream$_completer = t0;
    },
    ImageStreamCompleter: function ImageStreamCompleter() {
    },
    ImageStreamCompleter_reportError_closure: function ImageStreamCompleter_reportError_closure() {
    },
    ImageStreamCompleter_reportImageChunkEvent_closure: function ImageStreamCompleter_reportImageChunkEvent_closure() {
    },
    _ImageStream_Object_Diagnosticable: function _ImageStream_Object_Diagnosticable() {
    },
    _ImageStreamCompleter_Object_Diagnosticable: function _ImageStreamCompleter_Object_Diagnosticable() {
    }
  },
  D;
  J = holdersList[1];
  A = holdersList[0];
  C = holdersList[2];
  B = hunkHelpers.updateHolder(holdersList[88], B);
  D = holdersList[130];
  B.ImageProvider.prototype = {
    resolve$1(configuration) {
      var stream = new B.ImageStream();
      this._createErrorHandlerAndKey$3(configuration, new B.ImageProvider_resolve_closure(this, configuration, stream), new B.ImageProvider_resolve_closure0(this, stream));
      return stream;
    },
    _createErrorHandlerAndKey$3(configuration, successCallback, errorCallback) {
      var handleError, key, error, stackTrace, exception, t1 = {},
        t2 = A._instanceType(this);
      t2._eval$1("~(ImageProvider.T,~(Object,StackTrace?))")._as(successCallback);
      t2._eval$1("Future<~>(ImageProvider.T?,Object,StackTrace?)")._as(errorCallback);
      t1.obtainedKey = null;
      t1.didError = false;
      handleError = new B.ImageProvider__createErrorHandlerAndKey_handleError(t1, errorCallback);
      key = null;
      try {
        key = this.obtainKey$1(configuration);
      } catch (exception) {
        error = A.unwrapException(exception);
        stackTrace = A.getTraceFromException(exception);
        handleError.call$2(error, stackTrace);
        return;
      }
      J.then$1$1$z(key, new B.ImageProvider__createErrorHandlerAndKey_closure(t1, this, successCallback, handleError), type$.void).catchError$1(handleError);
    },
    resolveStreamForKey$4(configuration, stream, key, handleError) {
      var t1, completer,
        _s11_ = "_imageCache";
      A._instanceType(this)._eval$1("ImageProvider.T")._as(key);
      type$.void_Function_2_Object_and_nullable_StackTrace._as(handleError);
      if (stream._image_stream$_completer != null) {
        t1 = $.PaintingBinding__instance.PaintingBinding___PaintingBinding__imageCache_A;
        t1 === $ && A.throwLateFieldNI(_s11_);
        t1.putIfAbsent$3$onError(0, key, new B.ImageProvider_resolveStreamForKey_closure(stream), handleError);
        return;
      }
      t1 = $.PaintingBinding__instance.PaintingBinding___PaintingBinding__imageCache_A;
      t1 === $ && A.throwLateFieldNI(_s11_);
      completer = t1.putIfAbsent$3$onError(0, key, new B.ImageProvider_resolveStreamForKey_closure0(this, key), handleError);
      if (completer != null)
        stream.setCompleter$1(completer);
    },
    evict$0() {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.bool),
        $async$returnValue, $async$self = this, t1, $async$temp1;
      var $async$evict$0 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $.PaintingBinding__instance.PaintingBinding___PaintingBinding__imageCache_A;
              t1 === $ && A.throwLateFieldNI("_imageCache");
              $async$temp1 = t1;
              $async$goto = 3;
              return A._asyncAwait($async$self.obtainKey$1(D.ImageConfiguration_Sfv), $async$evict$0);
            case 3:
              // returning from await.
              $async$returnValue = $async$temp1.evict$1($async$result);
              // goto return
              $async$goto = 1;
              break;
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$evict$0, $async$completer);
    },
    loadBuffer$2(key, decode) {
      A._instanceType(this)._eval$1("ImageProvider.T")._as(key);
      type$.Future_Codec_Function_ImmutableBuffer_$named_allowUpscaling_bool_and_cacheHeight_nullable_int_and_cacheWidth_nullable_int._as(decode);
      return B._AbstractImageStreamCompleter$();
    },
    loadImage$2(key, decode) {
      A._instanceType(this)._eval$1("ImageProvider.T")._as(key);
      type$.Future_Codec_Function_ImmutableBuffer_$named_getTargetSize_nullable_TargetImageSize_Function_int_int._as(decode);
      return B._AbstractImageStreamCompleter$();
    },
    toString$0(_) {
      return "ImageConfiguration()";
    }
  };
  B._AbstractImageStreamCompleter.prototype = {};
  B._ErrorImageCompleter.prototype = {};
  B.ImageStream.prototype = {
    setCompleter$1(value) {
      var t1, t2, _this = this;
      _this._image_stream$_completer = value;
      t1 = _this._image_stream$_listeners;
      if (t1 != null) {
        _this.set$_image_stream$_listeners(null);
        t2 = _this._image_stream$_completer;
        t2._addingInitialListeners = true;
        C.JSArray_methods.forEach$1(t1, t2.get$addListener(t2));
        _this._image_stream$_completer._addingInitialListeners = false;
      }
    },
    addListener$1(_, listener) {
      var t1, _this = this;
      type$.ImageStreamListener._as(listener);
      t1 = _this._image_stream$_completer;
      if (t1 != null)
        return t1.addListener$1(0, listener);
      if (_this._image_stream$_listeners == null)
        _this.set$_image_stream$_listeners(A._setArrayType([], type$.JSArray_ImageStreamListener));
      t1 = _this._image_stream$_listeners;
      t1.toString;
      C.JSArray_methods.add$1(t1, listener);
    },
    removeListener$1(_, listener) {
      var i,
        t1 = this._image_stream$_completer;
      if (t1 != null)
        return t1.removeListener$1(0, listener);
      for (i = 0; t1 = this._image_stream$_listeners, i < t1.length; ++i)
        if (t1[i].$eq(0, listener)) {
          t1 = this._image_stream$_listeners;
          t1.toString;
          C.JSArray_methods.removeAt$1(t1, i);
          break;
        }
    },
    set$_image_stream$_listeners(_listeners) {
      this._image_stream$_listeners = type$.nullable_List_ImageStreamListener._as(_listeners);
    }
  };
  B.ImageStreamCompleterHandle.prototype = {
    ImageStreamCompleterHandle$_$1(_completer) {
      ++this._image_stream$_completer._keepAliveHandles;
    },
    dispose$0() {
      var t1 = this._image_stream$_completer;
      --t1._keepAliveHandles;
      t1._maybeDispose$0();
      this._image_stream$_completer = null;
    }
  };
  B.ImageStreamCompleter.prototype = {
    addListener$1(_, listener) {
      var exception, stack, newException, newStack, t1, exception0, t2, _this = this;
      type$.ImageStreamListener._as(listener);
      if (_this._image_stream$_disposed)
        A.throwExpression(A.StateError$(string$.Stream));
      _this._hadAtLeastOneListener = true;
      C.JSArray_methods.add$1(_this._image_stream$_listeners, listener);
      t1 = _this._currentImage;
      if (t1 != null)
        try {
          listener.onImage.call$2(t1.clone$0(0), !_this._addingInitialListeners);
        } catch (exception0) {
          exception = A.unwrapException(exception0);
          stack = A.getTraceFromException(exception0);
          _this.reportError$3$context$exception$stack(A.ErrorDescription$("by a synchronously-called image listener"), exception, stack);
        }
      t1 = _this._currentError;
      if (t1 != null && listener.onError != null)
        try {
          t2 = listener.onError;
          t2.toString;
          t2.call$2(t1.exception, t1.stack);
        } catch (exception) {
          newException = A.unwrapException(exception);
          newStack = A.getTraceFromException(exception);
          if (!J.$eq$(newException, _this._currentError.exception))
            A.FlutterError_reportError(new A.FlutterErrorDetails(newException, newStack, "image resource service", A.ErrorDescription$("by a synchronously-called image error listener"), null, false));
        }
    },
    keepAlive$0() {
      if (this._image_stream$_disposed)
        A.throwExpression(A.StateError$(string$.Stream));
      ++this._keepAliveHandles;
      return new B.ImageStreamCompleterHandle(this);
    },
    removeListener$1(_, listener) {
      var t1, i, callbacks, t2, _i, _this = this;
      if (_this._image_stream$_disposed)
        A.throwExpression(A.StateError$(string$.Stream));
      for (t1 = _this._image_stream$_listeners, i = 0; i < t1.length; ++i)
        if (t1[i].$eq(0, listener)) {
          C.JSArray_methods.removeAt$1(t1, i);
          break;
        }
      if (t1.length === 0) {
        t1 = _this._onLastListenerRemovedCallbacks;
        callbacks = A._setArrayType(t1.slice(0), A._arrayInstanceType(t1));
        for (t2 = callbacks.length, _i = 0; _i < callbacks.length; callbacks.length === t2 || (0, A.throwConcurrentModificationError)(callbacks), ++_i)
          callbacks[_i].call$0();
        C.JSArray_methods.clear$0(t1);
        _this._maybeDispose$0();
      }
    },
    onDisposed$0() {
    },
    _maybeDispose$0() {
      var t1, _this = this;
      if (!_this._hadAtLeastOneListener || _this._image_stream$_disposed || _this._image_stream$_listeners.length !== 0 || _this._keepAliveHandles !== 0)
        return;
      C.JSArray_methods.clear$0(_this._ephemeralErrorListeners);
      t1 = _this._currentImage;
      if (t1 != null)
        t1.dispose$0();
      _this._currentImage = null;
      _this._image_stream$_disposed = true;
      _this.onDisposed$0();
    },
    addOnLastListenerRemovedCallback$1(callback) {
      type$.void_Function._as(callback);
      if (this._image_stream$_disposed)
        A.throwExpression(A.StateError$(string$.Stream));
      C.JSArray_methods.add$1(this._onLastListenerRemovedCallbacks, callback);
    },
    removeOnLastListenerRemovedCallback$1(callback) {
      type$.void_Function._as(callback);
      if (this._image_stream$_disposed)
        A.throwExpression(A.StateError$(string$.Stream));
      C.JSArray_methods.remove$1(this._onLastListenerRemovedCallbacks, callback);
    },
    setImage$1(image) {
      var listener, exception, stack, t1, localListeners, _i, exception0, _this = this;
      type$.ImageInfo._as(image);
      if (_this._image_stream$_disposed)
        A.throwExpression(A.StateError$(string$.Stream));
      t1 = _this._currentImage;
      if (t1 != null)
        t1.dispose$0();
      _this._currentImage = image;
      C.JSArray_methods.clear$0(_this._ephemeralErrorListeners);
      t1 = _this._image_stream$_listeners;
      if (t1.length === 0)
        return;
      localListeners = A.List_List$of(t1, true, type$.ImageStreamListener);
      for (t1 = localListeners.length, _i = 0; _i < t1; ++_i) {
        listener = localListeners[_i];
        try {
          listener.onImage$2(image.clone$0(0), false);
        } catch (exception0) {
          exception = A.unwrapException(exception0);
          stack = A.getTraceFromException(exception0);
          _this.reportError$3$context$exception$stack(A.ErrorDescription$("by an image listener"), exception, stack);
        }
      }
    },
    reportError$5$context$exception$informationCollector$silent$stack(context, exception, informationCollector, silent, stack) {
      var handled, errorListener, newException, newStack, t1, t2, _i, exception0, t3, t4, _this = this,
        _s22_ = "image resource service";
      type$.nullable_StackTrace._as(stack);
      _this._currentError = new A.FlutterErrorDetails(exception, stack, _s22_, context, type$.nullable_Iterable_DiagnosticsNode_Function._as(informationCollector), silent);
      t1 = _this._image_stream$_listeners;
      t2 = A._arrayInstanceType(t1);
      t2 = A.List_List$of(new A.WhereTypeIterable(new A.MappedListIterable(t1, t2._eval$1("~(Object,StackTrace?)?(1)")._as(new B.ImageStreamCompleter_reportError_closure()), t2._eval$1("MappedListIterable<1,~(Object,StackTrace?)?>")), type$.WhereTypeIterable_of_void_Function_2_Object_and_nullable_StackTrace), true, type$.void_Function_2_Object_and_nullable_StackTrace);
      t1 = _this._ephemeralErrorListeners;
      C.JSArray_methods.addAll$1(t2, t1);
      C.JSArray_methods.clear$0(t1);
      handled = false;
      for (t1 = t2.length, _i = 0; _i < t2.length; t2.length === t1 || (0, A.throwConcurrentModificationError)(t2), ++_i) {
        errorListener = t2[_i];
        try {
          errorListener.call$2(exception, stack);
          handled = true;
        } catch (exception0) {
          newException = A.unwrapException(exception0);
          newStack = A.getTraceFromException(exception0);
          if (!J.$eq$(newException, exception)) {
            t3 = A.ErrorDescription$("when reporting an error to an image listener");
            t4 = $.FlutterError_onError;
            if (t4 != null)
              t4.call$1(new A.FlutterErrorDetails(newException, newStack, _s22_, t3, null, false));
          }
        }
      }
      if (!A.boolConversionCheck(handled)) {
        t1 = _this._currentError;
        t1.toString;
        A.FlutterError_reportError(t1);
      }
    },
    reportError$3$context$exception$stack(context, exception, stack) {
      return this.reportError$5$context$exception$informationCollector$silent$stack(context, exception, null, false, stack);
    },
    reportError$2$exception$stack(exception, stack) {
      return this.reportError$5$context$exception$informationCollector$silent$stack(null, exception, null, false, stack);
    },
    reportImageChunkEvent$1($event) {
      var t1, t2, t3, localListeners, _i;
      type$.ImageChunkEvent._as($event);
      if (this._image_stream$_disposed)
        A.throwExpression(A.StateError$(string$.Stream));
      t1 = this._image_stream$_listeners;
      if (t1.length !== 0) {
        t2 = A._arrayInstanceType(t1);
        t3 = type$.WhereTypeIterable_of_void_Function_ImageChunkEvent;
        localListeners = A.List_List$of(new A.WhereTypeIterable(new A.MappedListIterable(t1, t2._eval$1("~(ImageChunkEvent)?(1)")._as(new B.ImageStreamCompleter_reportImageChunkEvent_closure()), t2._eval$1("MappedListIterable<1,~(ImageChunkEvent)?>")), t3), true, t3._eval$1("Iterable.E"));
        for (t1 = localListeners.length, _i = 0; _i < t1; ++_i)
          localListeners[_i].call$1($event);
      }
    }
  };
  B._ImageStream_Object_Diagnosticable.prototype = {};
  B._ImageStreamCompleter_Object_Diagnosticable.prototype = {};
  var typesOffset = hunkHelpers.updateTypes(["~(ImageStreamListener)", "~(ImageInfo)", "~(ImageChunkEvent)"]);
  B.ImageProvider_resolve_closure.prototype = {
    call$2(key, errorHandler) {
      var t1 = this.$this;
      t1.resolveStreamForKey$4(this.configuration, this.stream, A._instanceType(t1)._eval$1("ImageProvider.T")._as(key), type$.void_Function_2_Object_and_nullable_StackTrace._as(errorHandler));
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("~(ImageProvider.T,~(Object,StackTrace?))");
    }
  };
  B.ImageProvider_resolve_closure0.prototype = {
    call$3(key, exception, stack) {
      return this.$call$body$ImageProvider_resolve_closure(A._instanceType(this.$this)._eval$1("ImageProvider.T?")._as(key), exception, stack);
    },
    $call$body$ImageProvider_resolve_closure(key, exception, stack) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$self = this, t1;
      var $async$call$3 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = A._Future$value(null, type$.Null);
              $async$goto = 2;
              return A._asyncAwait(t1, $async$call$3);
            case 2:
              // returning from await.
              t1 = $async$self.stream;
              if (t1._image_stream$_completer == null)
                t1.setCompleter$1(new B._ErrorImageCompleter(A._setArrayType([], type$.JSArray_ImageStreamListener), A._setArrayType([], type$.JSArray_of_void_Function_2_Object_and_nullable_StackTrace), A._setArrayType([], type$.JSArray_of_void_Function)));
              t1 = t1._image_stream$_completer;
              t1.toString;
              t1.reportError$5$context$exception$informationCollector$silent$stack(A.ErrorDescription$("while resolving an image"), exception, null, true, stack);
              // implicit return
              return A._asyncReturn(null, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$3, $async$completer);
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("Future<~>(ImageProvider.T?,Object,StackTrace?)");
    }
  };
  B.ImageProvider__createErrorHandlerAndKey_handleError.prototype = {
    $call$body$ImageProvider__createErrorHandlerAndKey_handleError(exception, stack) {
      var $async$goto = 0,
        $async$completer = A._makeAsyncAwaitCompleter(type$.void),
        $async$returnValue, $async$self = this, t1;
      var $async$call$2 = A._wrapJsFunctionForAsync(function($async$errorCode, $async$result) {
        if ($async$errorCode === 1)
          return A._asyncRethrow($async$result, $async$completer);
        while (true)
          switch ($async$goto) {
            case 0:
              // Function start
              t1 = $async$self._box_0;
              if (t1.didError) {
                // goto return
                $async$goto = 1;
                break;
              }
              t1.didError = true;
              $async$self.errorCallback.call$3(t1.obtainedKey, exception, stack);
            case 1:
              // return
              return A._asyncReturn($async$returnValue, $async$completer);
          }
      });
      return A._asyncStartSync($async$call$2, $async$completer);
    },
    call$2(exception, stack) {
      return this.$call$body$ImageProvider__createErrorHandlerAndKey_handleError(type$.Object._as(exception), type$.nullable_StackTrace._as(stack));
    },
    $signature: 386
  };
  B.ImageProvider__createErrorHandlerAndKey_closure.prototype = {
    call$1(key) {
      var error, stackTrace, exception, _this = this;
      A._instanceType(_this.$this)._eval$1("ImageProvider.T")._as(key);
      _this._box_0.obtainedKey = key;
      try {
        _this.successCallback.call$2(key, _this.handleError);
      } catch (exception) {
        error = A.unwrapException(exception);
        stackTrace = A.getTraceFromException(exception);
        _this.handleError.call$2(error, stackTrace);
      }
    },
    $signature() {
      return A._instanceType(this.$this)._eval$1("Null(ImageProvider.T)");
    }
  };
  B.ImageProvider_resolveStreamForKey_closure.prototype = {
    call$0() {
      var t1 = this.stream._image_stream$_completer;
      t1.toString;
      return t1;
    },
    $signature: 159
  };
  B.ImageProvider_resolveStreamForKey_closure0.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = this.key,
        result = t1.loadImage$2(t2, $.PaintingBinding__instance.get$instantiateImageCodecWithSize());
      return result instanceof B._AbstractImageStreamCompleter ? t1.loadBuffer$2(t2, $.PaintingBinding__instance.get$instantiateImageCodecFromBuffer()) : result;
    },
    $signature: 159
  };
  B.ImageStreamCompleter_reportError_closure.prototype = {
    call$1(listener) {
      return type$.ImageStreamListener._as(listener).onError;
    },
    $signature: 388
  };
  B.ImageStreamCompleter_reportImageChunkEvent_closure.prototype = {
    call$1(listener) {
      return type$.ImageStreamListener._as(listener).onChunk;
    },
    $signature: 389
  };
  (function aliases() {
    var _ = B.ImageStreamCompleter.prototype;
    _.super$ImageStreamCompleter$addListener = _.addListener$1;
    _.super$ImageStreamCompleter$removeListener = _.removeListener$1;
    _.super$ImageStreamCompleter$onDisposed = _.onDisposed$0;
    _.super$ImageStreamCompleter$_maybeDispose = _._maybeDispose$0;
  })();
  (function installTearOffs() {
    var _instance_1_i = hunkHelpers._instance_1i,
      _instance_1_u = hunkHelpers._instance_1u;
    var _;
    _instance_1_i(_ = B.ImageStreamCompleter.prototype, "get$addListener", "addListener$1", 0);
    _instance_1_u(_, "get$setImage", "setImage$1", 1);
    _instance_1_u(_, "get$reportImageChunkEvent", "reportImageChunkEvent$1", 2);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _inheritMany = hunkHelpers.inheritMany,
      _inherit = hunkHelpers.inherit;
    _inheritMany(A.Object, [B.ImageProvider, B._ImageStreamCompleter_Object_Diagnosticable, B._ImageStream_Object_Diagnosticable, B.ImageStreamCompleterHandle]);
    _inheritMany(A.Closure2Args, [B.ImageProvider_resolve_closure, B.ImageProvider__createErrorHandlerAndKey_handleError]);
    _inheritMany(A.Closure, [B.ImageProvider_resolve_closure0, B.ImageProvider__createErrorHandlerAndKey_closure, B.ImageStreamCompleter_reportError_closure, B.ImageStreamCompleter_reportImageChunkEvent_closure]);
    _inheritMany(A.Closure0Args, [B.ImageProvider_resolveStreamForKey_closure, B.ImageProvider_resolveStreamForKey_closure0]);
    _inherit(B.ImageStreamCompleter, B._ImageStreamCompleter_Object_Diagnosticable);
    _inheritMany(B.ImageStreamCompleter, [B._AbstractImageStreamCompleter, B._ErrorImageCompleter]);
    _inherit(B.ImageStream, B._ImageStream_Object_Diagnosticable);
    _mixin(B._ImageStream_Object_Diagnosticable, A.Diagnosticable);
    _mixin(B._ImageStreamCompleter_Object_Diagnosticable, A.Diagnosticable);
  })();
  A._Universe_addRules(init.typeUniverse, JSON.parse('{"_AbstractImageStreamCompleter":{"ImageStreamCompleter":[]},"_ErrorImageCompleter":{"ImageStreamCompleter":[]}}'));
  var string$ = {
    Stream: "Stream has been disposed.\nAn ImageStream is considered disposed once at least one listener has been added and subsequently all listeners have been removed and no handles are outstanding from the keepAlive method.\nTo resolve this error, maintain at least one listener on the stream, or create an ImageStreamCompleterHandle from the keepAlive method, or create a new stream for the image."
  };
  var type$ = (function rtii() {
    var findType = A.findType;
    return {
      Future_Codec_Function_ImmutableBuffer_$named_allowUpscaling_bool_and_cacheHeight_nullable_int_and_cacheWidth_nullable_int: findType("Future<Codec0>(ImmutableBuffer{allowUpscaling:bool,cacheHeight:int?,cacheWidth:int?})"),
      Future_Codec_Function_ImmutableBuffer_$named_getTargetSize_nullable_TargetImageSize_Function_int_int: findType("Future<Codec0>(ImmutableBuffer{getTargetSize:TargetImageSize(int,int)?})"),
      ImageChunkEvent: findType("ImageChunkEvent"),
      ImageInfo: findType("ImageInfo"),
      ImageStreamListener: findType("ImageStreamListener"),
      JSArray_ImageStreamListener: findType("JSArray<ImageStreamListener>"),
      JSArray_of_void_Function: findType("JSArray<~()>"),
      JSArray_of_void_Function_2_Object_and_nullable_StackTrace: findType("JSArray<~(Object,StackTrace?)>"),
      Null: findType("Null"),
      Object: findType("Object"),
      WhereTypeIterable_of_void_Function_2_Object_and_nullable_StackTrace: findType("WhereTypeIterable<~(Object,StackTrace?)>"),
      WhereTypeIterable_of_void_Function_ImageChunkEvent: findType("WhereTypeIterable<~(ImageChunkEvent)>"),
      bool: findType("bool"),
      nullable_Iterable_DiagnosticsNode_Function: findType("Iterable<DiagnosticsNode>()?"),
      nullable_List_ImageStreamListener: findType("List<ImageStreamListener>?"),
      nullable_StackTrace: findType("StackTrace?"),
      void: findType("~"),
      void_Function: findType("~()"),
      void_Function_2_Object_and_nullable_StackTrace: findType("~(Object,StackTrace?)")
    };
  })();
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_55", e: "endPart", h: h});
})($__dart_deferred_initializers__, "4JXgxl6jnW0CkFScqUgks0BGfr0=");
;
//# sourceMappingURL=main.dart.js_55.part.js.map
