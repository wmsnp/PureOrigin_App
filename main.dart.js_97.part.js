// Generated by dart2js (NullSafetyMode.sound, csp, intern-composite-values), the Dart to JavaScript compiler version: 3.7.2.
((s, d, e) => {
  s[d] = s[d] || {};
  s[d][e] = s[d][e] || [];
  s[d][e].push({p: "main.dart.js_97", e: "beginPart"});
})(self, "$__dart_deferred_initializers__", "eventLog");
$__dart_deferred_initializers__.current = function(hunkHelpers, init, holdersList, $) {
  var J, B, C, D, N, H, O, I, P, Q, F, L, E, K, M,
  A = {
    SplayTreeMap$(compare, $K, $V) {
      var t1 = compare == null ? F._defaultCompare($K) : compare;
      return new A.SplayTreeMap(t1, $K._eval$1("@<0>")._bind$1($V)._eval$1("SplayTreeMap<1,2>"));
    },
    _SplayTreeMapNode: function _SplayTreeMapNode(t0, t1, t2) {
      var _ = this;
      _.value = t0;
      _.key = t1;
      _._collection$_right = _._collection$_left = null;
      _.$ti = t2;
    },
    SplayTreeMap: function SplayTreeMap(t0, t1) {
      var _ = this;
      _._collection$_root = null;
      _._compare = t0;
      _._splayCount = _._modificationCount = _._collection$_count = 0;
      _.$ti = t1;
    },
    _SplayTreeKeyIterable: function _SplayTreeKeyIterable(t0, t1) {
      this._tree = t0;
      this.$ti = t1;
    },
    _SplayTreeValueIterable: function _SplayTreeValueIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _SplayTreeMapEntryIterable: function _SplayTreeMapEntryIterable(t0, t1) {
      this._collection$_map = t0;
      this.$ti = t1;
    },
    _SplayTreeValueIterator: function _SplayTreeValueIterator(t0, t1, t2, t3) {
      var _ = this;
      _._collection$_current = null;
      _._tree = t0;
      _._collection$_path = t1;
      _._modificationCount = null;
      _._splayCount = t2;
      _.$ti = t3;
    },
    _SplayTreeMapEntryIterator: function _SplayTreeMapEntryIterator(t0, t1, t2, t3) {
      var _ = this;
      _._collection$_current = null;
      _._tree = t0;
      _._collection$_path = t1;
      _._modificationCount = null;
      _._splayCount = t2;
      _.$ti = t3;
    },
    _SplayTreeMap__SplayTree_MapMixin: function _SplayTreeMap__SplayTree_MapMixin() {
    },
    IconButtonTheme$(child, data) {
      return new A.IconButtonTheme(data, child, null);
    },
    IconButtonTheme: function IconButtonTheme(t0, t1, t2) {
      this.data = t0;
      this.child = t1;
      this.key = t2;
    },
    RenderIndexedSemantics: function RenderIndexedSemantics(t0, t1, t2, t3) {
      var _ = this;
      _._proxy_box$_index = t0;
      _.RenderObjectWithChildMixin__child = t1;
      _._layoutCacheStorage = t2;
      _.parentData = _._box$_size = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t3;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    applyGrowthDirectionToScrollDirection(scrollDirection, growthDirection) {
      var t1;
      switch (growthDirection.index) {
        case 0:
          t1 = scrollDirection;
          break;
        case 1:
          t1 = A.flipScrollDirection(scrollDirection);
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    SliverGeometry$(cacheExtent, hasVisualOverflow, hitTestExtent, layoutExtent, maxPaintExtent, paintExtent, paintOrigin, scrollExtent, scrollOffsetCorrection) {
      var t1 = layoutExtent == null ? paintExtent : layoutExtent,
        t2 = hitTestExtent == null ? paintExtent : hitTestExtent,
        t3 = cacheExtent == null ? layoutExtent : cacheExtent;
      if (t3 == null)
        t3 = paintExtent;
      return new A.SliverGeometry(scrollExtent, paintOrigin, paintExtent, t1, maxPaintExtent, t2, paintExtent > 0, hasVisualOverflow, scrollOffsetCorrection, t3);
    },
    SliverConstraints: function SliverConstraints(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.axisDirection = t0;
      _.growthDirection = t1;
      _.userScrollDirection = t2;
      _.scrollOffset = t3;
      _.precedingScrollExtent = t4;
      _.overlap = t5;
      _.remainingPaintExtent = t6;
      _.crossAxisExtent = t7;
      _.crossAxisDirection = t8;
      _.viewportMainAxisExtent = t9;
      _.cacheOrigin = t10;
      _.remainingCacheExtent = t11;
    },
    SliverGeometry: function SliverGeometry(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {
      var _ = this;
      _.scrollExtent = t0;
      _.paintOrigin = t1;
      _.paintExtent = t2;
      _.layoutExtent = t3;
      _.maxPaintExtent = t4;
      _.hitTestExtent = t5;
      _.visible = t6;
      _.hasVisualOverflow = t7;
      _.scrollOffsetCorrection = t8;
      _.cacheExtent = t9;
    },
    SliverHitTestResult: function SliverHitTestResult(t0, t1, t2) {
      this._path = t0;
      this._transforms = t1;
      this._localTransforms = t2;
    },
    SliverHitTestEntry: function SliverHitTestEntry(t0, t1, t2) {
      var _ = this;
      _.mainAxisPosition = t0;
      _.crossAxisPosition = t1;
      _.target = t2;
      _._transform = null;
    },
    SliverLogicalParentData: function SliverLogicalParentData() {
    },
    SliverLogicalContainerParentData: function SliverLogicalContainerParentData(t0, t1) {
      this.ContainerParentDataMixin_previousSibling = t0;
      this.ContainerParentDataMixin_nextSibling = t1;
      this.layoutOffset = null;
    },
    SliverPhysicalParentData: function SliverPhysicalParentData(t0) {
      this.paintOffset = t0;
    },
    SliverPhysicalContainerParentData: function SliverPhysicalContainerParentData(t0, t1, t2) {
      this.ContainerParentDataMixin_previousSibling = t0;
      this.ContainerParentDataMixin_nextSibling = t1;
      this.paintOffset = t2;
    },
    RenderSliver: function RenderSliver() {
    },
    RenderSliverHelpers: function RenderSliverHelpers() {
    },
    RenderSliverHelpers_hitTestBoxChild_closure: function RenderSliverHelpers_hitTestBoxChild_closure(t0, t1) {
      this._box_0 = t0;
      this.child = t1;
    },
    _SliverGeometry_Object_Diagnosticable: function _SliverGeometry_Object_Diagnosticable() {
    },
    _SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin: function _SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin() {
    },
    _SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin: function _SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin() {
    },
    RenderSliverList: function RenderSliverList(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _._childManager = t0;
      _._keepAliveBucket = t1;
      _.ContainerRenderObjectMixin__childCount = t2;
      _.ContainerRenderObjectMixin__firstChild = t3;
      _.ContainerRenderObjectMixin__lastChild = t4;
      _.parentData = _._geometry = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t5;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    RenderSliverList_performLayout_advance: function RenderSliverList_performLayout_advance(t0, t1, t2) {
      this._box_0 = t0;
      this.$this = t1;
      this.childConstraints = t2;
    },
    KeepAliveParentDataMixin: function KeepAliveParentDataMixin() {
    },
    RenderSliverWithKeepAliveMixin: function RenderSliverWithKeepAliveMixin() {
    },
    SliverMultiBoxAdaptorParentData: function SliverMultiBoxAdaptorParentData(t0, t1, t2) {
      var _ = this;
      _.index = null;
      _._keptAlive = false;
      _.KeepAliveParentDataMixin_keepAlive = t0;
      _.ContainerParentDataMixin_previousSibling = t1;
      _.ContainerParentDataMixin_nextSibling = t2;
      _.layoutOffset = null;
    },
    RenderSliverMultiBoxAdaptor: function RenderSliverMultiBoxAdaptor() {
    },
    RenderSliverMultiBoxAdaptor__createOrObtainChild_closure: function RenderSliverMultiBoxAdaptor__createOrObtainChild_closure(t0, t1, t2) {
      this.$this = t0;
      this.index = t1;
      this.after = t2;
    },
    RenderSliverMultiBoxAdaptor_collectGarbage_closure: function RenderSliverMultiBoxAdaptor_collectGarbage_closure(t0, t1) {
      this._box_0 = t0;
      this.$this = t1;
    },
    RenderSliverMultiBoxAdaptor_collectGarbage__closure: function RenderSliverMultiBoxAdaptor_collectGarbage__closure() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers() {
    },
    _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin: function _RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin() {
    },
    _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin: function _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin() {
    },
    _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin: function _SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin() {
    },
    RenderSliverEdgeInsetsPadding: function RenderSliverEdgeInsetsPadding() {
    },
    RenderSliverEdgeInsetsPadding_performLayout_paintOffset: function RenderSliverEdgeInsetsPadding_performLayout_paintOffset(t0, t1) {
      this.$this = t0;
      this.constraints = t1;
    },
    RenderSliverEdgeInsetsPadding_performLayout_cacheOffset: function RenderSliverEdgeInsetsPadding_performLayout_cacheOffset(t0, t1) {
      this.$this = t0;
      this.constraints = t1;
    },
    RenderSliverPadding: function RenderSliverPadding(t0, t1, t2, t3) {
      var _ = this;
      _._resolvedPadding = null;
      _._sliver_padding$_padding = t0;
      _._sliver_padding$_textDirection = t1;
      _.RenderObjectWithChildMixin__child = t2;
      _.parentData = _._geometry = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t3;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    _RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin: function _RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin() {
    },
    CacheExtentStyle: function CacheExtentStyle(t0, t1) {
      this.index = t0;
      this._name = t1;
    },
    RenderViewportBase: function RenderViewportBase() {
    },
    RenderViewportBase_visitChildrenForSemantics_closure: function RenderViewportBase_visitChildrenForSemantics_closure() {
    },
    RenderViewportBase_hitTestChildren_closure: function RenderViewportBase_hitTestChildren_closure(t0, t1, t2, t3) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.child = t2;
      _.sliverResult = t3;
    },
    RenderViewport: function RenderViewport(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11, t12) {
      var _ = this;
      _._anchor = t0;
      _._viewport0$_center = null;
      _.__RenderViewport__maxScrollExtent_A = _.__RenderViewport__minScrollExtent_A = $;
      _._viewport0$_hasVisualOverflow = false;
      _._viewport0$_axisDirection = t1;
      _._crossAxisDirection = t2;
      _._viewport0$_offset = t3;
      _._cacheExtent = t4;
      _._calculatedCacheExtent = null;
      _._cacheExtentStyle = t5;
      _._viewport0$_clipBehavior = t6;
      _._viewport0$_clipRectLayer = t7;
      _.ContainerRenderObjectMixin__childCount = t8;
      _.ContainerRenderObjectMixin__firstChild = t9;
      _.ContainerRenderObjectMixin__lastChild = t10;
      _._layoutCacheStorage = t11;
      _.parentData = _._box$_size = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t12;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    RenderShrinkWrappingViewport: function RenderShrinkWrappingViewport(t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, t10, t11) {
      var _ = this;
      _.__RenderShrinkWrappingViewport__shrinkWrapExtent_A = _.__RenderShrinkWrappingViewport__maxScrollExtent_A = $;
      _._viewport0$_hasVisualOverflow = false;
      _._viewport0$_axisDirection = t0;
      _._crossAxisDirection = t1;
      _._viewport0$_offset = t2;
      _._cacheExtent = t3;
      _._calculatedCacheExtent = null;
      _._cacheExtentStyle = t4;
      _._viewport0$_clipBehavior = t5;
      _._viewport0$_clipRectLayer = t6;
      _.ContainerRenderObjectMixin__childCount = t7;
      _.ContainerRenderObjectMixin__firstChild = t8;
      _.ContainerRenderObjectMixin__lastChild = t9;
      _._layoutCacheStorage = t10;
      _.parentData = _._box$_size = null;
      _._depth = 0;
      _._object$_owner = _._object$_parent = null;
      _._needsLayout = true;
      _._relayoutBoundary = null;
      _._doingThisLayoutWithCallback = false;
      _._constraints = null;
      _.__RenderObject__wasRepaintBoundary_A = $;
      _._layerHandle = t11;
      _._needsCompositingBitsUpdate = false;
      _.__RenderObject__needsCompositing_A = $;
      _._needsPaint = true;
      _._needsCompositedLayerUpdate = false;
      _._cachedSemanticsConfiguration = null;
      _._needsSemanticsUpdate = true;
      _._semantics = null;
    },
    _RenderViewportBase_RenderBox_ContainerRenderObjectMixin: function _RenderViewportBase_RenderBox_ContainerRenderObjectMixin() {
    },
    AutomaticKeepAlive: function AutomaticKeepAlive(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    _AutomaticKeepAliveState: function _AutomaticKeepAliveState() {
      var _ = this;
      _._automatic_keep_alive$_handles = null;
      _.___AutomaticKeepAliveState__child_A = $;
      _._keepingAlive = false;
      _._framework$_element = _._widget = null;
    },
    _AutomaticKeepAliveState__addClient_closure: function _AutomaticKeepAliveState__addClient_closure(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__getChildElement_closure: function _AutomaticKeepAliveState__getChildElement_closure(t0) {
      this._box_0 = t0;
    },
    _AutomaticKeepAliveState__createCallback_closure: function _AutomaticKeepAliveState__createCallback_closure(t0, t1, t2) {
      this.$this = t0;
      this.handle = t1;
      this.callback = t2;
    },
    _AutomaticKeepAliveState__createCallback__closure: function _AutomaticKeepAliveState__createCallback__closure(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__createCallback__closure0: function _AutomaticKeepAliveState__createCallback__closure0(t0) {
      this.$this = t0;
    },
    _AutomaticKeepAliveState__createCallback___closure: function _AutomaticKeepAliveState__createCallback___closure() {
    },
    SliverPadding: function SliverPadding(t0, t1, t2) {
      this.padding = t0;
      this.child = t1;
      this.key = t2;
    },
    IndexedSemantics: function IndexedSemantics(t0, t1, t2) {
      this.index = t0;
      this.child = t1;
      this.key = t2;
    },
    _kDefaultSemanticIndexCallback(__wc0_formal, localIndex) {
      return localIndex;
    },
    SliverChildDelegate: function SliverChildDelegate() {
    },
    _SaltedValueKey: function _SaltedValueKey(t0) {
      this.value = t0;
    },
    SliverChildBuilderDelegate: function SliverChildBuilderDelegate(t0, t1, t2, t3, t4, t5, t6) {
      var _ = this;
      _.builder = t0;
      _.childCount = t1;
      _.addAutomaticKeepAlives = t2;
      _.addRepaintBoundaries = t3;
      _.addSemanticIndexes = t4;
      _.semanticIndexCallback = t5;
      _.findChildIndexCallback = t6;
    },
    _SelectionKeepAlive: function _SelectionKeepAlive(t0, t1) {
      this.child = t0;
      this.key = t1;
    },
    _SelectionKeepAliveState: function _SelectionKeepAliveState(t0) {
      var _ = this;
      _._scroll_delegate$_registrar = _._selectableAttachments = _._selectablesWithSelections = null;
      _._wantKeepAlive = false;
      _.AutomaticKeepAliveClientMixin__keepAliveHandle = t0;
      _._framework$_element = _._widget = null;
    },
    _SelectionKeepAliveState_listensTo_closure: function _SelectionKeepAliveState_listensTo_closure(t0, t1) {
      this.$this = t0;
      this.selectable = t1;
    },
    __SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin: function __SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin() {
    },
    AlwaysScrollableScrollPhysics: function AlwaysScrollableScrollPhysics(t0) {
      this.parent = t0;
    },
    ScrollView: function ScrollView() {
    },
    ScrollView_build_closure: function ScrollView_build_closure(t0, t1, t2) {
      this.$this = t0;
      this.axisDirection = t1;
      this.slivers = t2;
    },
    ScrollView_build_closure0: function ScrollView_build_closure0(t0) {
      this.context = t0;
    },
    SliverList$(delegate) {
      return new A.SliverList(delegate, null);
    },
    SliverMultiBoxAdaptorElement$(widget, replaceMovedChildren) {
      return new A.SliverMultiBoxAdaptorElement(replaceMovedChildren, A.SplayTreeMap$(null, type$.int, type$.nullable_Element), widget, C._ElementLifecycle_0);
    },
    SliverMultiBoxAdaptorElement__extrapolateMaxScrollOffset(firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset, childCount) {
      if (lastIndex === childCount - 1)
        return trailingScrollOffset;
      return trailingScrollOffset + (trailingScrollOffset - leadingScrollOffset) / (lastIndex - firstIndex + 1) * (childCount - lastIndex - 1);
    },
    KeepAlive$(child, keepAlive) {
      return new A.KeepAlive(keepAlive, child, null);
    },
    SliverWithKeepAliveWidget: function SliverWithKeepAliveWidget() {
    },
    SliverMultiBoxAdaptorWidget: function SliverMultiBoxAdaptorWidget() {
    },
    SliverList: function SliverList(t0, t1) {
      this.delegate = t0;
      this.key = t1;
    },
    SliverMultiBoxAdaptorElement: function SliverMultiBoxAdaptorElement(t0, t1, t2, t3) {
      var _ = this;
      _._replaceMovedChildren = t0;
      _._childElements = t1;
      _._currentlyUpdatingChildIndex = _._currentBeforeChild = null;
      _._didUnderflow = false;
      _._slot = _._notificationTree = _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _.__Element__depth_A = $;
      _._widget = t2;
      _._parentBuildScope = _._framework$_owner = null;
      _._lifecycleState = t3;
      _._dependencies = _._inheritedElements = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._inDirtyList = false;
    },
    SliverMultiBoxAdaptorElement_performRebuild_processElement: function SliverMultiBoxAdaptorElement_performRebuild_processElement(t0, t1, t2, t3, t4) {
      var _ = this;
      _._box_0 = t0;
      _.$this = t1;
      _.newChildren = t2;
      _.adaptorWidget = t3;
      _.indexToLayoutOffset = t4;
    },
    SliverMultiBoxAdaptorElement_performRebuild_closure: function SliverMultiBoxAdaptorElement_performRebuild_closure() {
    },
    SliverMultiBoxAdaptorElement_performRebuild_closure0: function SliverMultiBoxAdaptorElement_performRebuild_closure0(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    SliverMultiBoxAdaptorElement_createChild_closure: function SliverMultiBoxAdaptorElement_createChild_closure(t0, t1, t2) {
      this.$this = t0;
      this.after = t1;
      this.index = t2;
    },
    SliverMultiBoxAdaptorElement_removeChild_closure: function SliverMultiBoxAdaptorElement_removeChild_closure(t0, t1) {
      this.$this = t0;
      this.index = t1;
    },
    KeepAlive: function KeepAlive(t0, t1, t2) {
      this.keepAlive = t0;
      this.child = t1;
      this.key = t2;
    },
    SlottedMultiChildRenderObjectWidget: function SlottedMultiChildRenderObjectWidget() {
    },
    SlottedMultiChildRenderObjectWidgetMixin: function SlottedMultiChildRenderObjectWidgetMixin() {
    },
    SlottedContainerRenderObjectMixin: function SlottedContainerRenderObjectMixin() {
    },
    SlottedRenderObjectElement: function SlottedRenderObjectElement(t0, t1, t2, t3, t4) {
      var _ = this;
      _._slotToChild = t0;
      _._keyedChildren = t1;
      _._slot = _._notificationTree = _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _.__Element__depth_A = $;
      _._widget = t2;
      _._parentBuildScope = _._framework$_owner = null;
      _._lifecycleState = t3;
      _._dependencies = _._inheritedElements = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._inDirtyList = false;
      _.$ti = t4;
    },
    _SlottedMultiChildRenderObjectWidget_RenderObjectWidget_SlottedMultiChildRenderObjectWidgetMixin: function _SlottedMultiChildRenderObjectWidget_RenderObjectWidget_SlottedMultiChildRenderObjectWidgetMixin() {
    },
    DefaultTextStyle_merge(child, maxLines, overflow, softWrap, style, textAlign, textHeightBehavior) {
      return new D.Builder(new A.DefaultTextStyle_merge_closure(null, style, textAlign, softWrap, overflow, maxLines, null, textHeightBehavior, child), null);
    },
    DefaultTextStyle_merge_closure: function DefaultTextStyle_merge_closure(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.key = t0;
      _.style = t1;
      _.textAlign = t2;
      _.softWrap = t3;
      _.overflow = t4;
      _.maxLines = t5;
      _.textWidthBasis = t6;
      _.textHeightBehavior = t7;
      _.child = t8;
    },
    ScaleTransition$(alignment, child, scale) {
      return new A.ScaleTransition(A.transitions_ScaleTransition__handleScaleMatrix$closure(), alignment, null, child, scale, null);
    },
    ScaleTransition__handleScaleMatrix(value) {
      return B.Matrix4_Matrix4$diagonal3Values(value, value, 1);
    },
    MatrixTransition: function MatrixTransition(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.onTransform = t0;
      _.alignment = t1;
      _.filterQuality = t2;
      _.child = t3;
      _.listenable = t4;
      _.key = t5;
    },
    ScaleTransition: function ScaleTransition(t0, t1, t2, t3, t4, t5) {
      var _ = this;
      _.onTransform = t0;
      _.alignment = t1;
      _.filterQuality = t2;
      _.child = t3;
      _.listenable = t4;
      _.key = t5;
    },
    Viewport$(anchor, axisDirection, cacheExtent, cacheExtentStyle, center, clipBehavior, offset, slivers) {
      return new A.Viewport(axisDirection, anchor, offset, center, cacheExtent, cacheExtentStyle, clipBehavior, slivers, null);
    },
    Viewport_getDefaultCrossAxisDirection(context, axisDirection) {
      switch (axisDirection.index) {
        case 0:
          return F.textDirectionToAxisDirection(context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality).textDirection);
        case 1:
          return C.AxisDirection_2;
        case 2:
          return F.textDirectionToAxisDirection(context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality).textDirection);
        case 3:
          return C.AxisDirection_2;
      }
    },
    Viewport: function Viewport(t0, t1, t2, t3, t4, t5, t6, t7, t8) {
      var _ = this;
      _.axisDirection = t0;
      _.anchor = t1;
      _.offset = t2;
      _.center = t3;
      _.cacheExtent = t4;
      _.cacheExtentStyle = t5;
      _.clipBehavior = t6;
      _.children = t7;
      _.key = t8;
    },
    _ViewportElement: function _ViewportElement(t0, t1, t2) {
      var _ = this;
      _._viewport$_doingMountOrUpdate = false;
      _._centerSlotIndex = null;
      _.__MultiChildRenderObjectElement__children_A = $;
      _._forgottenChildren = t0;
      _._slot = _._notificationTree = _._framework$_parent = _._ancestorRenderObjectElement = _._renderObject = null;
      _.__Element__depth_A = $;
      _._widget = t1;
      _._parentBuildScope = _._framework$_owner = null;
      _._lifecycleState = t2;
      _._dependencies = _._inheritedElements = null;
      _._hadUnsatisfiedDependencies = false;
      _._dirty = true;
      _._inDirtyList = false;
    },
    ShrinkWrappingViewport: function ShrinkWrappingViewport(t0, t1, t2, t3, t4) {
      var _ = this;
      _.axisDirection = t0;
      _.offset = t1;
      _.clipBehavior = t2;
      _.children = t3;
      _.key = t4;
    },
    __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin: function __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin() {
    },
    __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin: function __ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin() {
    },
    flipScrollDirection(direction) {
      var t1;
      switch (direction.index) {
        case 0:
          t1 = K.ScrollDirection_0;
          break;
        case 1:
          t1 = K.ScrollDirection_2;
          break;
        case 2:
          t1 = K.ScrollDirection_1;
          break;
        default:
          t1 = null;
      }
      return t1;
    }
  },
  G;
  J = holdersList[1];
  B = holdersList[0];
  C = holdersList[2];
  D = holdersList[130];
  N = holdersList[122];
  H = holdersList[150];
  O = holdersList[123];
  I = holdersList[135];
  P = holdersList[119];
  Q = holdersList[145];
  F = holdersList[114];
  L = holdersList[172];
  E = holdersList[136];
  K = holdersList[169];
  M = holdersList[137];
  A = hunkHelpers.updateHolder(holdersList[98], A);
  G = holdersList[177];
  A._SplayTreeMapNode.prototype = {
    set$value(_, value) {
      this.value = this.$ti._rest[1]._as(value);
    }
  };
  A.SplayTreeMap.prototype = {
    $index(_, key) {
      var t1 = this._untypedLookup$1(key);
      return t1 == null ? null : t1.value;
    },
    remove$1(_, key) {
      var root = this._untypedLookup$1(key);
      if (root == null)
        return null;
      this._removeRoot$0();
      return root.value;
    },
    $indexSet(_, key, value) {
      var comparison, _this = this,
        t1 = _this.$ti;
      t1._precomputed1._as(key);
      t1._rest[1]._as(value);
      comparison = _this._splay$1(key);
      if (comparison === 0) {
        _this._collection$_root.set$value(0, value);
        return;
      }
      _this._addNewRoot$2(new A._SplayTreeMapNode(value, key, t1._eval$1("_SplayTreeMapNode<1,2>")), comparison);
    },
    putIfAbsent$2(_, key, ifAbsent) {
      var comparison, originalModificationCount, originalSplayCount, value, _this = this,
        t1 = _this.$ti;
      t1._precomputed1._as(key);
      t1._eval$1("2()")._as(ifAbsent);
      comparison = _this._splay$1(key);
      if (comparison === 0)
        return _this._collection$_root.value;
      originalModificationCount = _this._modificationCount;
      originalSplayCount = _this._splayCount;
      value = ifAbsent.call$0();
      if (originalModificationCount !== _this._modificationCount || originalSplayCount !== _this._splayCount) {
        comparison = _this._splay$1(key);
        if (comparison === 0) {
          _this._collection$_root.set$value(0, value);
          return value;
        }
      }
      _this._addNewRoot$2(new A._SplayTreeMapNode(value, key, t1._eval$1("_SplayTreeMapNode<1,2>")), comparison);
      return value;
    },
    get$isEmpty(_) {
      return this._collection$_root == null;
    },
    get$isNotEmpty(_) {
      return this._collection$_root != null;
    },
    forEach$1(_, f) {
      var nodes, node,
        t1 = this.$ti;
      t1._eval$1("~(1,2)")._as(f);
      nodes = new A._SplayTreeMapEntryIterator(this, B._setArrayType([], t1._eval$1("JSArray<_SplayTreeMapNode<1,2>>")), this._splayCount, t1._eval$1("_SplayTreeMapEntryIterator<1,2>"));
      for (; nodes.set$_collection$_current(null), nodes.super$_SplayTreeIterator$moveNext();) {
        node = nodes.get$current(0);
        f.call$2(node.key, node.value);
      }
    },
    get$length(_) {
      return this._collection$_count;
    },
    clear$0(_) {
      this._clear$0(0);
    },
    containsKey$1(_, key) {
      return this._untypedLookup$1(key) != null;
    },
    get$keys(_) {
      return new A._SplayTreeKeyIterable(this, this.$ti._eval$1("_SplayTreeKeyIterable<1,_SplayTreeMapNode<1,2>>"));
    },
    get$values(_) {
      return new A._SplayTreeValueIterable(this, this.$ti._eval$1("_SplayTreeValueIterable<1,2>"));
    },
    get$entries(_) {
      return new A._SplayTreeMapEntryIterable(this, this.$ti._eval$1("_SplayTreeMapEntryIterable<1,2>"));
    },
    firstKey$0() {
      var t1,
        root = this._collection$_root;
      if (root == null)
        return null;
      t1 = this._splayMin$1(root);
      this.set$_collection$_root(t1);
      return t1.key;
    },
    lastKey$0() {
      var t1,
        root = this._collection$_root;
      if (root == null)
        return null;
      t1 = this._splayMax$1(root);
      this.set$_collection$_root(t1);
      return t1.key;
    },
    set$_collection$_root(_root) {
      this._collection$_root = this.$ti._eval$1("_SplayTreeMapNode<1,2>?")._as(_root);
    },
    $isMap: 1,
    _compare$2(arg0, arg1) {
      return this._compare.call$2(arg0, arg1);
    },
    get$_collection$_root() {
      return this._collection$_root;
    },
    get$_compare() {
      return this._compare;
    },
    get$_validKey() {
      return null;
    }
  };
  A._SplayTreeKeyIterable.prototype = {
    get$length(_) {
      return this._tree._collection$_count;
    },
    get$isEmpty(_) {
      return this._tree._collection$_count === 0;
    },
    get$iterator(_) {
      var t1 = this._tree,
        t2 = this.$ti;
      return new F._SplayTreeKeyIterator(t1, B._setArrayType([], t2._eval$1("JSArray<2>")), t1._splayCount, t2._eval$1("_SplayTreeKeyIterator<1,2>"));
    },
    contains$1(_, element) {
      return this._tree._untypedLookup$1(element) != null;
    },
    toSet$0(_) {
      var t1 = this._tree,
        t2 = this.$ti,
        set = F.SplayTreeSet$(t2._eval$1("int(1,1)")._as(t1._compare), null, t2._precomputed1),
        root = t1._collection$_root;
      if (root != null) {
        set.set$_collection$_root(set._copyNode$1$1(root, t2._rest[1]));
        set._collection$_count = t1._collection$_count;
      }
      return set;
    }
  };
  A._SplayTreeValueIterable.prototype = {
    get$length(_) {
      return this._collection$_map._collection$_count;
    },
    get$isEmpty(_) {
      return this._collection$_map._collection$_count === 0;
    },
    get$iterator(_) {
      var t1 = this._collection$_map,
        t2 = this.$ti;
      return new A._SplayTreeValueIterator(t1, B._setArrayType([], t2._eval$1("JSArray<_SplayTreeMapNode<1,2>>")), t1._splayCount, t2._eval$1("_SplayTreeValueIterator<1,2>"));
    }
  };
  A._SplayTreeMapEntryIterable.prototype = {
    get$length(_) {
      return this._collection$_map._collection$_count;
    },
    get$isEmpty(_) {
      return this._collection$_map._collection$_count === 0;
    },
    get$iterator(_) {
      var t1 = this._collection$_map,
        t2 = this.$ti;
      return new A._SplayTreeMapEntryIterator(t1, B._setArrayType([], t2._eval$1("JSArray<_SplayTreeMapNode<1,2>>")), t1._splayCount, t2._eval$1("_SplayTreeMapEntryIterator<1,2>"));
    }
  };
  A._SplayTreeValueIterator.prototype = {
    moveNext$0() {
      var result = this.super$_SplayTreeIterator$moveNext();
      this.set$_collection$_current(result ? C.JSArray_methods.get$last(this._collection$_path).value : null);
      return result;
    },
    _getValue$1(node) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("_SplayTreeMapNode<1,2>")._as(node);
      t2 = this._collection$_current;
      return t2 == null ? t1._rest[1]._as(t2) : t2;
    },
    set$_collection$_current(_current) {
      this._collection$_current = this.$ti._eval$1("2?")._as(_current);
    }
  };
  A._SplayTreeMapEntryIterator.prototype = {
    _getValue$1(node) {
      var t2,
        t1 = this.$ti;
      t1._eval$1("_SplayTreeMapNode<1,2>")._as(node);
      t2 = this._collection$_current;
      if (t2 == null) {
        t1 = new B.MapEntry(node.key, node.value, t1._eval$1("MapEntry<1,2>"));
        this.set$_collection$_current(t1);
      } else
        t1 = t2;
      return t1;
    },
    moveNext$0() {
      this.set$_collection$_current(null);
      return this.super$_SplayTreeIterator$moveNext();
    },
    set$_collection$_current(_current) {
      this._collection$_current = this.$ti._eval$1("MapEntry<1,2>?")._as(_current);
    }
  };
  A._SplayTreeMap__SplayTree_MapMixin.prototype = {};
  A.IconButtonTheme.prototype = {
    wrap$2(_, context, child) {
      return A.IconButtonTheme$(child, this.data);
    },
    updateShouldNotify$1(oldWidget) {
      return !this.data.$eq(0, type$.IconButtonTheme._as(oldWidget).data);
    }
  };
  A.RenderIndexedSemantics.prototype = {
    set$index(_, value) {
      if (value === this._proxy_box$_index)
        return;
      this._proxy_box$_index = value;
      this.markNeedsSemanticsUpdate$0();
    },
    describeSemanticsConfiguration$1(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config._indexInParent = this._proxy_box$_index;
      config._hasBeenAnnotated = true;
    }
  };
  A.SliverConstraints.prototype = {
    get$isTight() {
      return false;
    },
    asBoxConstraints$3$crossAxisExtent$maxExtent$minExtent(crossAxisExtent, maxExtent, minExtent) {
      if (crossAxisExtent == null)
        crossAxisExtent = this.crossAxisExtent;
      switch (B.axisDirectionToAxis(this.axisDirection).index) {
        case 0:
          return new B.BoxConstraints(minExtent, maxExtent, crossAxisExtent, crossAxisExtent);
        case 1:
          return new B.BoxConstraints(crossAxisExtent, crossAxisExtent, minExtent, maxExtent);
      }
    },
    asBoxConstraints$2$maxExtent$minExtent(maxExtent, minExtent) {
      return this.asBoxConstraints$3$crossAxisExtent$maxExtent$minExtent(null, maxExtent, minExtent);
    },
    asBoxConstraints$0() {
      return this.asBoxConstraints$3$crossAxisExtent$maxExtent$minExtent(null, 1 / 0, 0);
    },
    $eq(_, other) {
      var _this = this;
      if (other == null)
        return false;
      if (_this === other)
        return true;
      if (!(other instanceof A.SliverConstraints))
        return false;
      return other.axisDirection === _this.axisDirection && other.growthDirection === _this.growthDirection && other.userScrollDirection === _this.userScrollDirection && other.scrollOffset === _this.scrollOffset && other.precedingScrollExtent === _this.precedingScrollExtent && other.overlap === _this.overlap && other.remainingPaintExtent === _this.remainingPaintExtent && other.crossAxisExtent === _this.crossAxisExtent && other.crossAxisDirection === _this.crossAxisDirection && other.viewportMainAxisExtent === _this.viewportMainAxisExtent && other.remainingCacheExtent === _this.remainingCacheExtent && other.cacheOrigin === _this.cacheOrigin;
    },
    get$hashCode(_) {
      var _this = this;
      return B.Object_hash(_this.axisDirection, _this.growthDirection, _this.userScrollDirection, _this.scrollOffset, _this.precedingScrollExtent, _this.overlap, _this.remainingPaintExtent, _this.crossAxisExtent, _this.crossAxisDirection, _this.viewportMainAxisExtent, _this.remainingCacheExtent, _this.cacheOrigin, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue, C.C_SentinelValue);
    },
    toString$0(_) {
      var _this = this,
        t1 = B._setArrayType([_this.axisDirection.toString$0(0), _this.growthDirection.toString$0(0), _this.userScrollDirection.toString$0(0), "scrollOffset: " + C.JSNumber_methods.toStringAsFixed$1(_this.scrollOffset, 1), "precedingScrollExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.precedingScrollExtent, 1), "remainingPaintExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.remainingPaintExtent, 1)], type$.JSArray_String),
        t2 = _this.overlap;
      if (t2 !== 0)
        t1.push("overlap: " + C.JSNumber_methods.toStringAsFixed$1(t2, 1));
      t1.push("crossAxisExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.crossAxisExtent, 1));
      t1.push("crossAxisDirection: " + _this.crossAxisDirection.toString$0(0));
      t1.push("viewportMainAxisExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.viewportMainAxisExtent, 1));
      t1.push("remainingCacheExtent: " + C.JSNumber_methods.toStringAsFixed$1(_this.remainingCacheExtent, 1));
      t1.push("cacheOrigin: " + C.JSNumber_methods.toStringAsFixed$1(_this.cacheOrigin, 1));
      return "SliverConstraints(" + C.JSArray_methods.join$1(t1, ", ") + ")";
    }
  };
  A.SliverGeometry.prototype = {
    toStringShort$0() {
      return "SliverGeometry";
    }
  };
  A.SliverHitTestResult.prototype = {};
  A.SliverHitTestEntry.prototype = {
    toString$0(_) {
      return B.getRuntimeTypeOfDartObject(this.target).toString$0(0) + "@(mainAxis: " + B.S(this.mainAxisPosition) + ", crossAxis: " + B.S(this.crossAxisPosition) + ")";
    }
  };
  A.SliverLogicalParentData.prototype = {
    toString$0(_) {
      var t1 = this.layoutOffset;
      return "layoutOffset=" + (t1 == null ? "None" : C.JSNumber_methods.toStringAsFixed$1(t1, 1));
    }
  };
  A.SliverLogicalContainerParentData.prototype = {};
  A.SliverPhysicalParentData.prototype = {
    toString$0(_) {
      return "paintOffset=" + this.paintOffset.toString$0(0);
    },
    set$paintOffset(paintOffset) {
      this.paintOffset = type$.Offset._as(paintOffset);
    }
  };
  A.SliverPhysicalContainerParentData.prototype = {};
  A.RenderSliver.prototype = {
    get$constraints() {
      return type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this));
    },
    get$semanticBounds() {
      return this.get$paintBounds();
    },
    get$paintBounds() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection).index) {
        case 0:
          return new B.Rect(0, 0, 0 + _this._geometry.paintExtent, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent);
        case 1:
          return new B.Rect(0, 0, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent, 0 + _this._geometry.paintExtent);
      }
    },
    performResize$0() {
    },
    hitTest$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var t1, _this = this;
      if (mainAxisPosition >= 0 && mainAxisPosition < _this._geometry.hitTestExtent && crossAxisPosition >= 0 && crossAxisPosition < type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)).crossAxisExtent) {
        t1 = _this.hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition);
        if (t1) {
          result.add$1(0, new A.SliverHitTestEntry(mainAxisPosition, crossAxisPosition, _this));
          return true;
        }
      }
      return false;
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      return false;
    },
    calculatePaintOffset$3$from$to(constraints, from, to) {
      var a = constraints.scrollOffset,
        t1 = constraints.remainingPaintExtent,
        b = a + t1;
      return B.clampDouble(B.clampDouble(to, a, b) - B.clampDouble(from, a, b), 0, t1);
    },
    calculateCacheOffset$3$from$to(constraints, from, to) {
      var t1 = constraints.scrollOffset,
        a = t1 + constraints.cacheOrigin,
        t2 = constraints.remainingCacheExtent,
        b = t1 + t2;
      return B.clampDouble(B.clampDouble(to, a, b) - B.clampDouble(from, a, b), 0, t2);
    },
    childMainAxisPosition$1(child) {
      return 0;
    },
    childCrossAxisPosition$1(child) {
      return 0;
    },
    childScrollOffset$1(child) {
      return 0;
    },
    applyPaintTransform$2(child, transform) {
    },
    handleEvent$2($event, entry) {
      type$.SliverHitTestEntry._as(entry);
    }
  };
  A.RenderSliverHelpers.prototype = {
    _getRightWayUp$1(constraints) {
      var t1,
        reversed = D.axisDirectionIsReversed(constraints.axisDirection);
      switch (constraints.growthDirection.index) {
        case 0:
          t1 = !reversed;
          break;
        case 1:
          t1 = reversed;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    hitTestBoxChild$4$crossAxisPosition$mainAxisPosition(result, child, crossAxisPosition, mainAxisPosition) {
      var _this = this, _box_0 = {},
        rightWayUp = _this._getRightWayUp$1(_this.get$constraints()),
        delta = _this.childMainAxisPosition$1(child),
        crossAxisDelta = _this.childCrossAxisPosition$1(child),
        absolutePosition = mainAxisPosition - delta,
        absoluteCrossAxisPosition = crossAxisPosition - crossAxisDelta,
        paintOffset = _box_0.transformedPosition = null;
      switch (B.axisDirectionToAxis(_this.get$constraints().axisDirection).index) {
        case 0:
          if (!rightWayUp) {
            absolutePosition = child.get$size(0)._dx - absolutePosition;
            delta = _this._geometry.paintExtent - child.get$size(0)._dx - delta;
          }
          paintOffset = new B.Offset(delta, crossAxisDelta);
          _box_0.transformedPosition = new B.Offset(absolutePosition, absoluteCrossAxisPosition);
          break;
        case 1:
          if (!rightWayUp) {
            absolutePosition = child.get$size(0)._dy - absolutePosition;
            delta = _this._geometry.paintExtent - child.get$size(0)._dy - delta;
          }
          paintOffset = new B.Offset(crossAxisDelta, delta);
          _box_0.transformedPosition = new B.Offset(absoluteCrossAxisPosition, absolutePosition);
          break;
      }
      return result.addWithOutOfBandPosition$2$hitTest$paintOffset(new A.RenderSliverHelpers_hitTestBoxChild_closure(_box_0, child), paintOffset);
    },
    applyPaintTransformForBoxChild$2(child, transform) {
      var _this = this,
        rightWayUp = _this._getRightWayUp$1(_this.get$constraints()),
        delta = _this.childMainAxisPosition$1(child),
        crossAxisDelta = _this.childCrossAxisPosition$1(child);
      switch (B.axisDirectionToAxis(_this.get$constraints().axisDirection).index) {
        case 0:
          transform.translate$2(0, !rightWayUp ? _this._geometry.paintExtent - child.get$size(0)._dx - delta : delta, crossAxisDelta);
          break;
        case 1:
          transform.translate$2(0, crossAxisDelta, !rightWayUp ? _this._geometry.paintExtent - child.get$size(0)._dy - delta : delta);
          break;
      }
    }
  };
  A._SliverGeometry_Object_Diagnosticable.prototype = {};
  A._SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin.prototype = {
    detach$0(_) {
      this.super$ParentData$detach(0);
    }
  };
  A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin.prototype = {
    detach$0(_) {
      this.super$ParentData$detach(0);
    }
  };
  A.RenderSliverList.prototype = {
    performLayout$0() {
      var t2, scrollOffset, targetEndScrollOffset, childConstraints, earliestUsefulChild, t3, t4, t5, leadingChildrenWithoutLayoutOffset, t6, earliestScrollOffset, leadingChildWithLayout, firstChildScrollOffset, advance, leadingGarbage, extent, reachedEnd, trailingGarbage, child, estimatedMaxScrollOffset, t7, paintExtent, cacheExtent, _this = this, _null = null, _box_0 = {},
        constraints = type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)),
        t1 = _this._childManager;
      t1._didUnderflow = false;
      t2 = constraints.scrollOffset;
      scrollOffset = t2 + constraints.cacheOrigin;
      targetEndScrollOffset = scrollOffset + constraints.remainingCacheExtent;
      childConstraints = constraints.asBoxConstraints$0();
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        if (!_this.addInitialChild$0()) {
          _this._geometry = G.SliverGeometry_QEo;
          t1.didFinishLayout$0();
          return;
        }
      _box_0.trailingChildWithLayout = null;
      earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t4 = type$.SliverMultiBoxAdaptorParentData;
      if (t4._as(t3).layoutOffset == null) {
        t3 = B._instanceType(_this);
        t5 = t3._eval$1("ContainerRenderObjectMixin.0");
        t3 = t3._eval$1("ContainerRenderObjectMixin.1");
        leadingChildrenWithoutLayoutOffset = 0;
        while (true) {
          if (earliestUsefulChild != null) {
            t6 = earliestUsefulChild.parentData;
            t6.toString;
            t6 = t4._as(t6).layoutOffset == null;
          } else
            t6 = false;
          if (!t6)
            break;
          t6 = t5._as(earliestUsefulChild).parentData;
          t6.toString;
          earliestUsefulChild = t3._as(t6).ContainerParentDataMixin_nextSibling;
          ++leadingChildrenWithoutLayoutOffset;
        }
        _this.collectGarbage$2(leadingChildrenWithoutLayoutOffset, 0);
        if (_this.ContainerRenderObjectMixin__firstChild == null)
          if (!_this.addInitialChild$0()) {
            _this._geometry = G.SliverGeometry_QEo;
            t1.didFinishLayout$0();
            return;
          }
      }
      earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      earliestScrollOffset = t3;
      leadingChildWithLayout = _null;
      for (; earliestScrollOffset > scrollOffset; earliestScrollOffset = firstChildScrollOffset, leadingChildWithLayout = earliestUsefulChild) {
        earliestUsefulChild = _this.insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, true);
        if (earliestUsefulChild == null) {
          t3 = _this.ContainerRenderObjectMixin__firstChild;
          t5 = t3.parentData;
          t5.toString;
          t4._as(t5).layoutOffset = 0;
          if (scrollOffset === 0) {
            t3.layout$2$parentUsesSize(childConstraints, true);
            earliestUsefulChild = _this.ContainerRenderObjectMixin__firstChild;
            if (_box_0.trailingChildWithLayout == null)
              _box_0.trailingChildWithLayout = earliestUsefulChild;
            leadingChildWithLayout = earliestUsefulChild;
            break;
          } else {
            _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -scrollOffset);
            return;
          }
        }
        t3 = _this.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        firstChildScrollOffset = earliestScrollOffset - _this.paintExtentOf$1(t3);
        if (firstChildScrollOffset < -1e-10) {
          _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -firstChildScrollOffset);
          t1 = _this.ContainerRenderObjectMixin__firstChild.parentData;
          t1.toString;
          t4._as(t1).layoutOffset = 0;
          return;
        }
        t3 = earliestUsefulChild.parentData;
        t3.toString;
        t4._as(t3).layoutOffset = firstChildScrollOffset;
        if (_box_0.trailingChildWithLayout == null)
          _box_0.trailingChildWithLayout = earliestUsefulChild;
      }
      if (scrollOffset < 1e-10) {
        t3 = type$.RenderBox;
        while (true) {
          t5 = _this.ContainerRenderObjectMixin__firstChild;
          t5.toString;
          t5 = t3._as(t5).parentData;
          t5.toString;
          t4._as(t5);
          t6 = t5.index;
          t6.toString;
          if (!(t6 > 0))
            break;
          t5 = t5.layoutOffset;
          t5.toString;
          earliestUsefulChild = _this.insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, true);
          t6 = _this.ContainerRenderObjectMixin__firstChild;
          t6.toString;
          firstChildScrollOffset = t5 - _this.paintExtentOf$1(t6);
          t6 = _this.ContainerRenderObjectMixin__firstChild.parentData;
          t6.toString;
          t4._as(t6).layoutOffset = 0;
          if (firstChildScrollOffset < -1e-10) {
            _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, -firstChildScrollOffset);
            return;
          }
        }
      }
      if (leadingChildWithLayout == null) {
        earliestUsefulChild.layout$2$parentUsesSize(childConstraints, true);
        _box_0.trailingChildWithLayout = earliestUsefulChild;
      }
      _box_0.inLayoutRange = true;
      _box_0.child = earliestUsefulChild;
      t3 = earliestUsefulChild.parentData;
      t3.toString;
      t4._as(t3);
      t5 = t3.index;
      t5.toString;
      _box_0.index = t5;
      t3 = t3.layoutOffset;
      t3.toString;
      _box_0.endScrollOffset = t3 + _this.paintExtentOf$1(earliestUsefulChild);
      advance = new A.RenderSliverList_performLayout_advance(_box_0, _this, childConstraints);
      for (leadingGarbage = 0; _box_0.endScrollOffset < scrollOffset;) {
        ++leadingGarbage;
        if (!B.boolConversionCheck(advance.call$0())) {
          _this.collectGarbage$2(leadingGarbage - 1, 0);
          t1 = _this.ContainerRenderObjectMixin__lastChild;
          t2 = t1.parentData;
          t2.toString;
          t2 = t4._as(t2).layoutOffset;
          t2.toString;
          extent = t2 + _this.paintExtentOf$1(t1);
          _this._geometry = A.SliverGeometry$(_null, false, _null, _null, extent, 0, 0, extent, _null);
          return;
        }
      }
      while (true) {
        if (!(_box_0.endScrollOffset < targetEndScrollOffset)) {
          reachedEnd = false;
          break;
        }
        if (!B.boolConversionCheck(advance.call$0())) {
          reachedEnd = true;
          break;
        }
      }
      t3 = _box_0.child;
      trailingGarbage = 0;
      if (t3 != null) {
        t5 = B._instanceType(_this);
        t6 = t5._eval$1("ContainerRenderObjectMixin.0");
        t3 = t6._as(t3).parentData;
        t3.toString;
        t5 = t5._eval$1("ContainerRenderObjectMixin.1");
        t3 = _box_0.child = t5._as(t3).ContainerParentDataMixin_nextSibling;
        for (; t3 != null; t3 = child) {
          ++trailingGarbage;
          t3 = t6._as(t3).parentData;
          t3.toString;
          child = t5._as(t3).ContainerParentDataMixin_nextSibling;
          _box_0.child = child;
        }
      }
      _this.collectGarbage$2(leadingGarbage, trailingGarbage);
      estimatedMaxScrollOffset = _box_0.endScrollOffset;
      if (!reachedEnd) {
        t3 = _this.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        t5 = type$.RenderBox;
        t3 = t5._as(t3).parentData;
        t3.toString;
        t4._as(t3);
        t6 = t3.index;
        t6.toString;
        t7 = _this.ContainerRenderObjectMixin__lastChild;
        t7.toString;
        t7 = t5._as(t7).parentData;
        t7.toString;
        t7 = t4._as(t7).index;
        t7.toString;
        estimatedMaxScrollOffset = t1.estimateMaxScrollOffset$5$firstIndex$lastIndex$leadingScrollOffset$trailingScrollOffset(constraints, t6, t7, t3.layoutOffset, estimatedMaxScrollOffset);
      }
      t3 = _this.ContainerRenderObjectMixin__firstChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      paintExtent = _this.calculatePaintOffset$3$from$to(constraints, t3, _box_0.endScrollOffset);
      t3 = _this.ContainerRenderObjectMixin__firstChild.parentData;
      t3.toString;
      t3 = t4._as(t3).layoutOffset;
      t3.toString;
      cacheExtent = _this.calculateCacheOffset$3$from$to(constraints, t3, _box_0.endScrollOffset);
      t3 = _box_0.endScrollOffset;
      _this._geometry = A.SliverGeometry$(cacheExtent, t3 > t2 + constraints.remainingPaintExtent || t2 > 0, _null, _null, estimatedMaxScrollOffset, paintExtent, 0, estimatedMaxScrollOffset, _null);
      if (estimatedMaxScrollOffset === t3)
        t1._didUnderflow = true;
      t1.didFinishLayout$0();
    }
  };
  A.KeepAliveParentDataMixin.prototype = {$isParentData: 1};
  A.RenderSliverWithKeepAliveMixin.prototype = {
    setupParentData$1(child) {
    }
  };
  A.SliverMultiBoxAdaptorParentData.prototype = {
    toString$0(_) {
      var t1 = this.index,
        t2 = this.KeepAliveParentDataMixin_keepAlive ? "keepAlive; " : "";
      return "index=" + B.S(t1) + "; " + t2 + this.super$SliverLogicalParentData$toString(0);
    }
  };
  A.RenderSliverMultiBoxAdaptor.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverMultiBoxAdaptorParentData))
        child.parentData = new A.SliverMultiBoxAdaptorParentData(false, null, null);
    },
    adoptChild$1(child) {
      var t1;
      this.super$RenderObject$adoptChild(child);
      t1 = child.parentData;
      t1.toString;
      if (!type$.SliverMultiBoxAdaptorParentData._as(t1)._keptAlive)
        this._childManager.didAdoptChild$1(type$.RenderBox._as(child));
    },
    insert$2$after(_, child, after) {
      this.super$ContainerRenderObjectMixin$insert(0, type$.RenderBox._as(child), type$.nullable_RenderBox._as(after));
    },
    move$2$after(child, after) {
      var t1, t2, _this = this;
      type$.RenderBox._as(child);
      type$.nullable_RenderBox._as(after);
      t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (!t1._keptAlive) {
        _this.super$ContainerRenderObjectMixin$move(child, after);
        _this._childManager.didAdoptChild$1(child);
        _this.markNeedsLayout$0();
      } else {
        t2 = _this._keepAliveBucket;
        if (t2.$index(0, t1.index) === child)
          t2.remove$1(0, t1.index);
        _this._childManager.didAdoptChild$1(child);
        t1 = t1.index;
        t1.toString;
        t2.$indexSet(0, t1, child);
      }
    },
    remove$1(_, child) {
      var t1;
      type$.RenderBox._as(child);
      t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (!t1._keptAlive) {
        this.super$ContainerRenderObjectMixin$remove(0, child);
        return;
      }
      this._keepAliveBucket.remove$1(0, t1.index);
      this.dropChild$1(child);
    },
    _createOrObtainChild$2$after(index, after) {
      this.invokeLayoutCallback$1$1(new A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure(this, index, after), type$.SliverConstraints);
    },
    _destroyOrCacheChild$1(child) {
      var t2, _this = this,
        t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1);
      if (t1.KeepAliveParentDataMixin_keepAlive) {
        _this.remove$1(0, child);
        t2 = t1.index;
        t2.toString;
        _this._keepAliveBucket.$indexSet(0, t2, child);
        child.parentData = t1;
        _this.super$RenderObject$adoptChild(child);
        t1._keptAlive = true;
      } else
        _this._childManager.removeChild$1(child);
    },
    attach$1(owner) {
      var t1;
      this.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$attach(owner);
      for (t1 = this._keepAliveBucket, t1 = new B.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, B._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")); t1.moveNext$0();)
        t1.__js_helper$_current.attach$1(owner);
    },
    detach$0(_) {
      var t1;
      this.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$detach(0);
      for (t1 = this._keepAliveBucket, t1 = new B.LinkedHashMapValueIterator(t1, t1._modifications, t1._first, B._instanceType(t1)._eval$1("LinkedHashMapValueIterator<2>")); t1.moveNext$0();)
        t1.__js_helper$_current.detach$0(0);
    },
    redepthChildren$0() {
      this.super$ContainerRenderObjectMixin$redepthChildren();
      var t1 = this._keepAliveBucket;
      new B.LinkedHashMapValuesIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")).forEach$1(0, this.get$redepthChild());
    },
    visitChildren$1(visitor) {
      var t1;
      type$.void_Function_RenderObject._as(visitor);
      this.super$ContainerRenderObjectMixin$visitChildren(visitor);
      t1 = this._keepAliveBucket;
      new B.LinkedHashMapValuesIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")).forEach$1(0, visitor);
    },
    visitChildrenForSemantics$1(visitor) {
      this.super$ContainerRenderObjectMixin$visitChildren(type$.void_Function_RenderObject._as(visitor));
    },
    addInitialChild$2$index$layoutOffset(index, layoutOffset) {
      var t1;
      this._createOrObtainChild$2$after(index, null);
      t1 = this.ContainerRenderObjectMixin__firstChild;
      if (t1 != null) {
        t1 = t1.parentData;
        t1.toString;
        type$.SliverMultiBoxAdaptorParentData._as(t1).layoutOffset = layoutOffset;
        return true;
      }
      this._childManager._didUnderflow = true;
      return false;
    },
    addInitialChild$0() {
      return this.addInitialChild$2$index$layoutOffset(0, 0);
    },
    insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, parentUsesSize) {
      var t2, t3, index, _this = this,
        t1 = _this.ContainerRenderObjectMixin__firstChild;
      t1.toString;
      t2 = type$.RenderBox;
      t1 = t2._as(t1).parentData;
      t1.toString;
      t3 = type$.SliverMultiBoxAdaptorParentData;
      t1 = t3._as(t1).index;
      t1.toString;
      index = t1 - 1;
      _this._createOrObtainChild$2$after(index, null);
      t1 = _this.ContainerRenderObjectMixin__firstChild;
      t1.toString;
      t2._as(t1);
      t2 = t1.parentData;
      t2.toString;
      t2 = t3._as(t2).index;
      t2.toString;
      if (t2 === index) {
        t1.layout$2$parentUsesSize(childConstraints, parentUsesSize);
        return _this.ContainerRenderObjectMixin__firstChild;
      }
      _this._childManager._didUnderflow = true;
      return null;
    },
    insertAndLayoutLeadingChild$1(childConstraints) {
      return this.insertAndLayoutLeadingChild$2$parentUsesSize(childConstraints, false);
    },
    insertAndLayoutChild$3$after$parentUsesSize(childConstraints, after, parentUsesSize) {
      var t2, index, t3, child,
        t1 = after.parentData;
      t1.toString;
      t2 = type$.SliverMultiBoxAdaptorParentData;
      t1 = t2._as(t1).index;
      t1.toString;
      index = t1 + 1;
      this._createOrObtainChild$2$after(index, after);
      t1 = B._instanceType(this);
      t3 = t1._eval$1("ContainerRenderObjectMixin.0")._as(after).parentData;
      t3.toString;
      child = t1._eval$1("ContainerRenderObjectMixin.1")._as(t3).ContainerParentDataMixin_nextSibling;
      if (child != null) {
        t1 = child.parentData;
        t1.toString;
        t1 = t2._as(t1).index;
        t1.toString;
        t1 = t1 === index;
      } else
        t1 = false;
      if (t1) {
        child.layout$2$parentUsesSize(childConstraints, parentUsesSize);
        return child;
      }
      this._childManager._didUnderflow = true;
      return null;
    },
    insertAndLayoutChild$2$after(childConstraints, after) {
      return this.insertAndLayoutChild$3$after$parentUsesSize(childConstraints, after, false);
    },
    calculateLeadingGarbage$1$firstIndex(firstIndex) {
      var t3, leadingGarbage, t4,
        walker = this.ContainerRenderObjectMixin__firstChild,
        t1 = B._instanceType(this),
        t2 = t1._eval$1("ContainerRenderObjectMixin.0");
      t1 = t1._eval$1("ContainerRenderObjectMixin.1");
      t3 = type$.SliverMultiBoxAdaptorParentData;
      leadingGarbage = 0;
      while (true) {
        if (walker != null) {
          t4 = walker.parentData;
          t4.toString;
          t4 = t3._as(t4).index;
          t4.toString;
          t4 = t4 < firstIndex;
        } else
          t4 = false;
        if (!t4)
          break;
        ++leadingGarbage;
        t4 = t2._as(walker).parentData;
        t4.toString;
        walker = t1._as(t4).ContainerParentDataMixin_nextSibling;
      }
      return leadingGarbage;
    },
    calculateTrailingGarbage$1$lastIndex(lastIndex) {
      var t3, trailingGarbage, t4,
        walker = this.ContainerRenderObjectMixin__lastChild,
        t1 = B._instanceType(this),
        t2 = t1._eval$1("ContainerRenderObjectMixin.0");
      t1 = t1._eval$1("ContainerRenderObjectMixin.1");
      t3 = type$.SliverMultiBoxAdaptorParentData;
      trailingGarbage = 0;
      while (true) {
        if (walker != null) {
          t4 = walker.parentData;
          t4.toString;
          t4 = t3._as(t4).index;
          t4.toString;
          t4 = t4 > lastIndex;
        } else
          t4 = false;
        if (!t4)
          break;
        ++trailingGarbage;
        t4 = t2._as(walker).parentData;
        t4.toString;
        walker = t1._as(t4).ContainerParentDataMixin_previousSibling;
      }
      return trailingGarbage;
    },
    collectGarbage$2(leadingGarbage, trailingGarbage) {
      var t1 = {};
      t1.leadingGarbage = leadingGarbage;
      t1.trailingGarbage = trailingGarbage;
      this.invokeLayoutCallback$1$1(new A.RenderSliverMultiBoxAdaptor_collectGarbage_closure(t1, this), type$.SliverConstraints);
    },
    paintExtentOf$1(child) {
      var t1;
      type$.RenderBox._as(child);
      switch (B.axisDirectionToAxis(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).axisDirection).index) {
        case 0:
          t1 = child.get$size(0)._dx;
          break;
        case 1:
          t1 = child.get$size(0)._dy;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var t1, t2, t3,
        child = this.ContainerRenderObjectMixin__lastChild,
        boxResult = B.BoxHitTestResult$wrap(result);
      for (t1 = B._instanceType(this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        if (this.hitTestBoxChild$4$crossAxisPosition$mainAxisPosition(boxResult, child, crossAxisPosition, mainAxisPosition))
          return true;
        t3 = t2._as(child).parentData;
        t3.toString;
        child = t1._as(t3).ContainerParentDataMixin_previousSibling;
      }
      return false;
    },
    childMainAxisPosition$1(child) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverMultiBoxAdaptorParentData._as(t1).layoutOffset;
      t1.toString;
      return t1 - type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).scrollOffset;
    },
    childScrollOffset$1(child) {
      var t1 = type$.RenderObject._as(child).parentData;
      t1.toString;
      return type$.SliverMultiBoxAdaptorParentData._as(t1).layoutOffset;
    },
    paintsChild$1(child) {
      var childParentData = type$.nullable_SliverMultiBoxAdaptorParentData._as(type$.RenderBox._as(child).parentData);
      return (childParentData == null ? null : childParentData.index) != null && !this._keepAliveBucket.containsKey$1(0, childParentData.index);
    },
    applyPaintTransform$2(child, transform) {
      type$.RenderBox._as(child);
      if (!this.paintsChild$1(child))
        transform.setZero$0();
      else
        this.applyPaintTransformForBoxChild$2(child, transform);
    },
    paint$2(context, offset) {
      var t1, addExtent, originOffset, mainAxisUnit, crossAxisUnit, child, t2, t3, t4, t5, mainAxisDelta, crossAxisDelta, t6, t7, t8, childOffset, t9, _this = this, _null = null;
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return;
      t1 = type$.SliverConstraints;
      addExtent = true;
      switch (D.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection).index) {
        case 0:
          originOffset = offset.$add(0, new B.Offset(0, _this._geometry.paintExtent));
          mainAxisUnit = C.Offset_0_m1;
          crossAxisUnit = C.Offset_1_0;
          break;
        case 1:
          originOffset = offset;
          mainAxisUnit = C.Offset_1_0;
          crossAxisUnit = C.Offset_0_1;
          addExtent = false;
          break;
        case 2:
          originOffset = offset;
          mainAxisUnit = C.Offset_0_1;
          crossAxisUnit = C.Offset_1_0;
          addExtent = false;
          break;
        case 3:
          originOffset = offset.$add(0, new B.Offset(_this._geometry.paintExtent, 0));
          mainAxisUnit = C.Offset_m1_0;
          crossAxisUnit = C.Offset_0_1;
          break;
        default:
          addExtent = _null;
          originOffset = addExtent;
          crossAxisUnit = originOffset;
          mainAxisUnit = crossAxisUnit;
      }
      child = _this.ContainerRenderObjectMixin__firstChild;
      for (t2 = B._instanceType(_this), t3 = t2._eval$1("ContainerRenderObjectMixin.0"), t2 = t2._eval$1("ContainerRenderObjectMixin.1"), t4 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        t5 = child.parentData;
        t5.toString;
        t5 = t4._as(t5).layoutOffset;
        t5.toString;
        mainAxisDelta = t5 - t1._as(B.RenderObject.prototype.get$constraints.call(_this)).scrollOffset;
        crossAxisDelta = _this.childCrossAxisPosition$1(child);
        t5 = originOffset._dx;
        t6 = mainAxisUnit._dx;
        t5 = t5 + t6 * mainAxisDelta + crossAxisUnit._dx * crossAxisDelta;
        t7 = originOffset._dy;
        t8 = mainAxisUnit._dy;
        t7 = t7 + t8 * mainAxisDelta + crossAxisUnit._dy * crossAxisDelta;
        childOffset = new B.Offset(t5, t7);
        if (B.boolConversionCheck(addExtent)) {
          t9 = _this.paintExtentOf$1(child);
          childOffset = new B.Offset(t5 + t6 * t9, t7 + t8 * t9);
        }
        if (mainAxisDelta < t1._as(B.RenderObject.prototype.get$constraints.call(_this)).remainingPaintExtent && mainAxisDelta + _this.paintExtentOf$1(child) > 0)
          context.paintChild$2(child, childOffset);
        t5 = t3._as(child).parentData;
        t5.toString;
        child = t2._as(t5).ContainerParentDataMixin_nextSibling;
      }
    }
  };
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin.prototype = {
    attach$1(owner) {
      var child, t1, t2;
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        child.attach$1(owner);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0(_) {
      var child, t1, t2;
      this.super$RenderObject$detach(0);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = type$.SliverMultiBoxAdaptorParentData; child != null;) {
        child.detach$0(0);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    }
  };
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers.prototype = {};
  A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin.prototype = {};
  A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin.prototype = {
    detach$0(_) {
      this.super$ParentData$detach(0);
    }
  };
  A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin.prototype = {};
  A.RenderSliverEdgeInsetsPadding.prototype = {
    get$beforePadding() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (D.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection).index) {
        case 0:
          t1 = _this.get$resolvedPadding().bottom;
          break;
        case 1:
          t1 = _this.get$resolvedPadding().left;
          break;
        case 2:
          t1 = _this.get$resolvedPadding().top;
          break;
        case 3:
          t1 = _this.get$resolvedPadding().right;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    get$afterPadding() {
      var _this = this,
        t1 = type$.SliverConstraints;
      switch (D.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(_this)).growthDirection).index) {
        case 0:
          t1 = _this.get$resolvedPadding().top;
          break;
        case 1:
          t1 = _this.get$resolvedPadding().right;
          break;
        case 2:
          t1 = _this.get$resolvedPadding().bottom;
          break;
        case 3:
          t1 = _this.get$resolvedPadding().left;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    get$crossAxisPadding() {
      switch (B.axisDirectionToAxis(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).axisDirection).index) {
        case 0:
          var t1 = this.get$resolvedPadding();
          t1 = t1.get$_top(0) + t1.get$_bottom(0);
          break;
        case 1:
          t1 = this.get$resolvedPadding().get$horizontal();
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverPhysicalParentData))
        child.parentData = new A.SliverPhysicalParentData(C.Offset_0_0);
    },
    performLayout$0() {
      var beforePadding, t3, mainAxisPadding, crossAxisPadding, paintExtent, beforePaddingPaintExtent, overlap, t4, t5, t6, t7, t8, t9, t10, t11, childLayoutGeometry, scrollExtent, beforePaddingCacheExtent, afterPaddingCacheExtent, afterPaddingPaintExtent, mainAxisPaddingPaintExtent, _this = this, _null = null,
        t1 = type$.SliverConstraints,
        constraints = t1._as(B.RenderObject.prototype.get$constraints.call(_this)),
        paintOffset = new A.RenderSliverEdgeInsetsPadding_performLayout_paintOffset(_this, constraints),
        cacheOffset = new A.RenderSliverEdgeInsetsPadding_performLayout_cacheOffset(_this, constraints),
        t2 = _this.get$resolvedPadding();
      t2.toString;
      beforePadding = _this.get$beforePadding();
      _this.get$afterPadding();
      t3 = _this.get$resolvedPadding();
      t3.toString;
      mainAxisPadding = t3.along$1(B.axisDirectionToAxis(t1._as(B.RenderObject.prototype.get$constraints.call(_this)).axisDirection));
      crossAxisPadding = _this.get$crossAxisPadding();
      if (_this.RenderObjectWithChildMixin__child == null) {
        paintExtent = paintOffset.call$2$from$to(0, mainAxisPadding);
        _this._geometry = A.SliverGeometry$(cacheOffset.call$2$from$to(0, mainAxisPadding), false, _null, _null, mainAxisPadding, Math.min(paintExtent, constraints.remainingPaintExtent), 0, mainAxisPadding, _null);
        return;
      }
      beforePaddingPaintExtent = paintOffset.call$2$from$to(0, beforePadding);
      overlap = constraints.overlap;
      if (overlap > 0)
        overlap = Math.max(0, overlap - beforePaddingPaintExtent);
      t1 = _this.RenderObjectWithChildMixin__child;
      t1.toString;
      t3 = Math.max(0, constraints.scrollOffset - beforePadding);
      t4 = Math.min(0, constraints.cacheOrigin + beforePadding);
      t5 = constraints.remainingPaintExtent;
      t6 = paintOffset.call$2$from$to(0, beforePadding);
      if (typeof t6 !== "number")
        return B.iae(t6);
      t7 = constraints.remainingCacheExtent;
      t8 = cacheOffset.call$2$from$to(0, beforePadding);
      if (typeof t8 !== "number")
        return B.iae(t8);
      t9 = Math.max(0, constraints.crossAxisExtent - crossAxisPadding);
      t10 = constraints.axisDirection;
      t11 = constraints.growthDirection;
      t1.layout$2$parentUsesSize(new A.SliverConstraints(t10, t11, constraints.userScrollDirection, t3, beforePadding + constraints.precedingScrollExtent, overlap, t5 - t6, t9, constraints.crossAxisDirection, constraints.viewportMainAxisExtent, t4, t7 - t8), true);
      childLayoutGeometry = _this.RenderObjectWithChildMixin__child._geometry;
      t1 = childLayoutGeometry.scrollOffsetCorrection;
      if (t1 != null) {
        _this._geometry = A.SliverGeometry$(_null, false, _null, _null, 0, 0, 0, 0, t1);
        return;
      }
      scrollExtent = childLayoutGeometry.scrollExtent;
      beforePaddingCacheExtent = cacheOffset.call$2$from$to(0, beforePadding);
      t1 = beforePadding + scrollExtent;
      t3 = mainAxisPadding + scrollExtent;
      afterPaddingCacheExtent = cacheOffset.call$2$from$to(t1, t3);
      afterPaddingPaintExtent = paintOffset.call$2$from$to(t1, t3);
      mainAxisPaddingPaintExtent = beforePaddingPaintExtent + afterPaddingPaintExtent;
      t1 = childLayoutGeometry.paintExtent;
      t4 = childLayoutGeometry.layoutExtent;
      paintExtent = Math.min(beforePaddingPaintExtent + Math.max(t1, t4 + afterPaddingPaintExtent), t5);
      t5 = childLayoutGeometry.paintOrigin;
      t4 = Math.min(mainAxisPaddingPaintExtent + t4, paintExtent);
      t7 = Math.min(beforePaddingCacheExtent + afterPaddingCacheExtent + childLayoutGeometry.cacheExtent, t7);
      t6 = childLayoutGeometry.maxPaintExtent;
      t1 = Math.max(mainAxisPaddingPaintExtent + t1, beforePaddingPaintExtent + childLayoutGeometry.hitTestExtent);
      _this._geometry = A.SliverGeometry$(t7, childLayoutGeometry.hasVisualOverflow, t1, t4, mainAxisPadding + t6, paintExtent, t5, t3, _null);
      switch (D.applyGrowthDirectionToAxisDirection(t10, t11).index) {
        case 0:
          t1 = paintOffset.call$2$from$to(t2.bottom + scrollExtent, t2.get$_top(0) + t2.get$_bottom(0) + scrollExtent);
          break;
        case 3:
          t1 = paintOffset.call$2$from$to(t2.right + scrollExtent, t2.get$horizontal() + scrollExtent);
          break;
        case 1:
          t1 = paintOffset.call$2$from$to(0, t2.left);
          break;
        case 2:
          t1 = paintOffset.call$2$from$to(0, t2.top);
          break;
        default:
          t1 = _null;
      }
      t3 = _this.RenderObjectWithChildMixin__child.parentData;
      t3.toString;
      type$.SliverPhysicalParentData._as(t3);
      switch (B.axisDirectionToAxis(t10).index) {
        case 0:
          t1 = new B.Offset(t1, t2.top);
          break;
        case 1:
          t1 = new B.Offset(t2.left, t1);
          break;
        default:
          t1 = _null;
      }
      t3.set$paintOffset(t1);
    },
    hitTestChildren$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition, mainAxisPosition) {
      var t2, t3, t4, isHit, _this = this,
        t1 = _this.RenderObjectWithChildMixin__child;
      if (t1 != null && t1._geometry.hitTestExtent > 0) {
        t2 = t1.parentData;
        t2.toString;
        type$.SliverPhysicalParentData._as(t2);
        type$.RenderSliver._as(t1);
        t1 = _this.calculatePaintOffset$3$from$to(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(_this)), 0, _this.get$beforePadding());
        t3 = _this.RenderObjectWithChildMixin__child;
        t3.toString;
        t3 = _this.childCrossAxisPosition$1(t3);
        t2 = t2.paintOffset;
        t4 = type$.bool_Function_SliverHitTestResult_$named_$req_crossAxisPosition_double_and_$req_mainAxisPosition_double._as(_this.RenderObjectWithChildMixin__child.get$hitTest());
        C.JSArray_methods.add$1(result._localTransforms, new B._OffsetTransformPart(new B.Offset(-t2._dx, -t2._dy)));
        isHit = t4.call$3$crossAxisPosition$mainAxisPosition(result, crossAxisPosition - t3, mainAxisPosition - t1);
        result.popTransform$0();
        return isHit;
      }
      return false;
    },
    childCrossAxisPosition$1(child) {
      var t1;
      type$.RenderSliver._as(child);
      switch (B.axisDirectionToAxis(type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(this)).axisDirection).index) {
        case 0:
          t1 = this.get$resolvedPadding().top;
          break;
        case 1:
          t1 = this.get$resolvedPadding().left;
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    childScrollOffset$1(child) {
      return this.get$beforePadding();
    },
    applyPaintTransform$2(child, transform) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverPhysicalParentData._as(t1).paintOffset;
      transform.translate$2(0, t1._dx, t1._dy);
    },
    paint$2(context, offset) {
      var t2,
        t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null && t1._geometry.visible) {
        t2 = t1.parentData;
        t2.toString;
        context.paintChild$2(t1, offset.$add(0, type$.SliverPhysicalParentData._as(t2).paintOffset));
      }
    }
  };
  A.RenderSliverPadding.prototype = {
    get$resolvedPadding() {
      return this._resolvedPadding;
    },
    _sliver_padding$_resolve$0() {
      if (this._resolvedPadding != null)
        return;
      this._resolvedPadding = this._sliver_padding$_padding;
    },
    set$padding(_, value) {
      var _this = this;
      if (_this._sliver_padding$_padding.$eq(0, value))
        return;
      _this._sliver_padding$_padding = value;
      _this._resolvedPadding = null;
      _this.markNeedsLayout$0();
    },
    set$textDirection(value) {
      var _this = this;
      if (_this._sliver_padding$_textDirection === value)
        return;
      _this._sliver_padding$_textDirection = value;
      _this._resolvedPadding = null;
      _this.markNeedsLayout$0();
    },
    performLayout$0() {
      this._sliver_padding$_resolve$0();
      this.super$RenderSliverEdgeInsetsPadding$performLayout();
    }
  };
  A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin.prototype = {
    attach$1(owner) {
      var t1;
      this.super$RenderObject$attach(owner);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.attach$1(owner);
    },
    detach$0(_) {
      var t1;
      this.super$RenderObject$detach(0);
      t1 = this.RenderObjectWithChildMixin__child;
      if (t1 != null)
        t1.detach$0(0);
    }
  };
  A.CacheExtentStyle.prototype = {
    _enumToString$0() {
      return "CacheExtentStyle." + this._name;
    }
  };
  A.RenderViewportBase.prototype = {
    describeSemanticsConfiguration$1(config) {
      this.super$RenderObject$describeSemanticsConfiguration(config);
      config.addTagForChildren$1(L.SemanticsTag_C6p);
    },
    visitChildrenForSemantics$1(visitor) {
      var t1, t2;
      type$.void_Function_RenderObject._as(visitor);
      t1 = this.get$childrenInPaintOrder();
      t2 = B._arrayInstanceType(t1);
      new B.WhereIterable(t1, t2._eval$1("bool(1)")._as(new A.RenderViewportBase_visitChildrenForSemantics_closure()), t2._eval$1("WhereIterable<1>")).forEach$1(0, visitor);
    },
    set$axisDirection(value) {
      if (value === this._viewport0$_axisDirection)
        return;
      this._viewport0$_axisDirection = value;
      this.markNeedsLayout$0();
    },
    set$crossAxisDirection(value) {
      if (value === this._crossAxisDirection)
        return;
      this._crossAxisDirection = value;
      this.markNeedsLayout$0();
    },
    set$offset(_, value) {
      var _this = this,
        t1 = _this._viewport0$_offset;
      if (value === t1)
        return;
      if (_this._object$_owner != null)
        t1.removeListener$1(0, _this.get$markNeedsLayout());
      _this._viewport0$_offset = value;
      if (_this._object$_owner != null)
        value.addListener$1(0, _this.get$markNeedsLayout());
      _this.markNeedsLayout$0();
    },
    set$cacheExtent(value) {
      if (value == null)
        value = 250;
      if (value === this._cacheExtent)
        return;
      this._cacheExtent = value;
      this.markNeedsLayout$0();
    },
    set$cacheExtentStyle(value) {
      if (value === this._cacheExtentStyle)
        return;
      this._cacheExtentStyle = value;
      this.markNeedsLayout$0();
    },
    set$clipBehavior(value) {
      var _this = this;
      if (value !== _this._viewport0$_clipBehavior) {
        _this._viewport0$_clipBehavior = value;
        _this.markNeedsPaint$0();
        _this.markNeedsSemanticsUpdate$0();
      }
    },
    attach$1(owner) {
      this.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$attach(owner);
      this._viewport0$_offset.addListener$1(0, this.get$markNeedsLayout());
    },
    detach$0(_) {
      this._viewport0$_offset.removeListener$1(0, this.get$markNeedsLayout());
      this.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$detach(0);
    },
    computeMinIntrinsicWidth$1(height) {
      B._asDouble(height);
      return 0;
    },
    computeMaxIntrinsicWidth$1(height) {
      B._asDouble(height);
      return 0;
    },
    computeMinIntrinsicHeight$1(width) {
      B._asDouble(width);
      return 0;
    },
    computeMaxIntrinsicHeight$1(width) {
      B._asDouble(width);
      return 0;
    },
    get$isRepaintBoundary() {
      return true;
    },
    layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(advance, cacheOrigin, child, crossAxisExtent, growthDirection, layoutOffset, mainAxisExtent, overlap, remainingCacheExtent, remainingPaintExtent, scrollOffset) {
      var adjustedUserScrollDirection, maxPaintOffset, layoutOffset0, precedingScrollExtent, sliverScrollOffset, correctedCacheOrigin, cacheExtentCorrection, childLayoutGeometry, t1, effectiveLayoutOffset, _this = this;
      type$.nullable_RenderSliver._as(child);
      type$.nullable_RenderSliver_Function_RenderSliver._as(advance);
      adjustedUserScrollDirection = A.applyGrowthDirectionToScrollDirection(_this._viewport0$_offset._userScrollDirection, growthDirection);
      maxPaintOffset = layoutOffset + overlap;
      for (layoutOffset0 = layoutOffset, precedingScrollExtent = 0; child != null;) {
        sliverScrollOffset = scrollOffset <= 0 ? 0 : scrollOffset;
        correctedCacheOrigin = Math.max(cacheOrigin, -sliverScrollOffset);
        cacheExtentCorrection = cacheOrigin - correctedCacheOrigin;
        child.layout$2$parentUsesSize(new A.SliverConstraints(_this._viewport0$_axisDirection, growthDirection, adjustedUserScrollDirection, sliverScrollOffset, precedingScrollExtent, maxPaintOffset - layoutOffset0, Math.max(0, remainingPaintExtent - layoutOffset0 + layoutOffset), crossAxisExtent, _this._crossAxisDirection, mainAxisExtent, correctedCacheOrigin, Math.max(0, remainingCacheExtent + cacheExtentCorrection)), true);
        childLayoutGeometry = child._geometry;
        t1 = childLayoutGeometry.scrollOffsetCorrection;
        if (t1 != null)
          return t1;
        effectiveLayoutOffset = layoutOffset0 + childLayoutGeometry.paintOrigin;
        if (childLayoutGeometry.visible || scrollOffset > 0)
          _this.updateChildLayoutOffset$3(child, effectiveLayoutOffset, growthDirection);
        else
          _this.updateChildLayoutOffset$3(child, -scrollOffset + layoutOffset, growthDirection);
        maxPaintOffset = Math.max(effectiveLayoutOffset + childLayoutGeometry.paintExtent, maxPaintOffset);
        t1 = childLayoutGeometry.scrollExtent;
        scrollOffset -= t1;
        precedingScrollExtent += t1;
        layoutOffset0 += childLayoutGeometry.layoutExtent;
        t1 = childLayoutGeometry.cacheExtent;
        if (t1 !== 0) {
          remainingCacheExtent -= t1 - cacheExtentCorrection;
          cacheOrigin = Math.min(correctedCacheOrigin + t1, 0);
        }
        _this.updateOutOfBandData$2(growthDirection, childLayoutGeometry);
        child = advance.call$1(child);
      }
      return 0;
    },
    describeApproximatePaintClip$1(child) {
      var t1, right, bottom, overlapCorrection, left, $top;
      type$.RenderSliver._as(child);
      switch (this._viewport0$_clipBehavior.index) {
        case 0:
          return null;
        case 1:
        case 2:
        case 3:
          break;
      }
      t1 = this.get$size(0);
      right = 0 + t1._dx;
      bottom = 0 + t1._dy;
      t1 = type$.SliverConstraints;
      if (t1._as(B.RenderObject.prototype.get$constraints.call(child)).overlap === 0 || !isFinite(t1._as(B.RenderObject.prototype.get$constraints.call(child)).viewportMainAxisExtent))
        return new B.Rect(0, 0, right, bottom);
      overlapCorrection = t1._as(B.RenderObject.prototype.get$constraints.call(child)).viewportMainAxisExtent - t1._as(B.RenderObject.prototype.get$constraints.call(child)).remainingPaintExtent + t1._as(B.RenderObject.prototype.get$constraints.call(child)).overlap;
      left = 0;
      $top = 0;
      switch (D.applyGrowthDirectionToAxisDirection(this._viewport0$_axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection).index) {
        case 2:
          $top = 0 + overlapCorrection;
          break;
        case 0:
          bottom -= overlapCorrection;
          break;
        case 1:
          left = 0 + overlapCorrection;
          break;
        case 3:
          right -= overlapCorrection;
          break;
      }
      return new B.Rect(left, $top, right, bottom);
    },
    describeSemanticsClip$1(child) {
      var t1, t2, t3, t4, _this = this;
      type$.nullable_RenderSliver._as(child);
      if (_this._calculatedCacheExtent == null) {
        t1 = _this.get$size(0);
        return new B.Rect(0, 0, 0 + t1._dx, 0 + t1._dy);
      }
      switch (B.axisDirectionToAxis(_this._viewport0$_axisDirection).index) {
        case 1:
          _this.get$size(0);
          _this.get$size(0);
          t1 = _this._calculatedCacheExtent;
          t1.toString;
          t2 = _this.get$size(0);
          t3 = _this.get$size(0);
          t4 = _this._calculatedCacheExtent;
          t4.toString;
          return new B.Rect(0, 0 - t1, 0 + t2._dx, 0 + t3._dy + t4);
        case 0:
          _this.get$size(0);
          t1 = _this._calculatedCacheExtent;
          t1.toString;
          _this.get$size(0);
          t2 = _this.get$size(0);
          t3 = _this._calculatedCacheExtent;
          t3.toString;
          return new B.Rect(0 - t1, 0, 0 + t2._dx + t3, 0 + _this.get$size(0)._dy);
      }
    },
    paint$2(context, offset) {
      var t1, t2, t3, _this = this;
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return;
      t1 = _this.get$hasVisualOverflow() && _this._viewport0$_clipBehavior !== C.Clip_0;
      t2 = _this._viewport0$_clipRectLayer;
      if (t1) {
        t1 = _this.__RenderObject__needsCompositing_A;
        t1 === $ && B.throwLateFieldNI("_needsCompositing");
        t3 = _this.get$size(0);
        t2.set$layer(0, context.pushClipRect$6$clipBehavior$oldLayer(t1, offset, new B.Rect(0, 0, 0 + t3._dx, 0 + t3._dy), _this.get$_paintContents(), _this._viewport0$_clipBehavior, t2._layer));
      } else {
        t2.set$layer(0, null);
        _this._paintContents$2(context, offset);
      }
    },
    dispose$0() {
      this._viewport0$_clipRectLayer.set$layer(0, null);
      this.super$RenderObject$dispose();
    },
    _paintContents$2(context, offset) {
      var t1, t2, t3, t4, _i, child, t5;
      for (t1 = this.get$childrenInPaintOrder(), t2 = t1.length, t3 = offset._dx, t4 = offset._dy, _i = 0; _i < t1.length; t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (child._geometry.visible) {
          t5 = this.paintOffsetOf$1(child);
          context.paintChild$2(child, new B.Offset(t3 + t5._dx, t4 + t5._dy));
        }
      }
    },
    hitTestChildren$2$position(result, position) {
      var _0_1, _0_2, sliverResult, t2, _i, child, transform, _this = this, _box_0 = {},
        t1 = _box_0.crossAxisPosition = _box_0.mainAxisPosition = null;
      switch (B.axisDirectionToAxis(_this._viewport0$_axisDirection).index) {
        case 1:
          t1 = new B._Record_2(position._dy, position._dx);
          break;
        case 0:
          t1 = new B._Record_2(position._dx, position._dy);
          break;
      }
      _0_1 = t1._0;
      _box_0.mainAxisPosition = _0_1;
      _0_2 = t1._1;
      _box_0.crossAxisPosition = _0_2;
      sliverResult = new A.SliverHitTestResult(result._path, result._transforms, result._localTransforms);
      for (t1 = _this.get$childrenInHitTestOrder(), t2 = t1.length, _i = 0; _i < t1.length; t1.length === t2 || (0, B.throwConcurrentModificationError)(t1), ++_i) {
        child = t1[_i];
        if (!child._geometry.visible)
          continue;
        transform = new B.Matrix40(new Float64Array(16));
        transform.setIdentity$0();
        _this.applyPaintTransform$2(child, transform);
        if (result.addWithOutOfBandPosition$2$hitTest$paintTransform(new A.RenderViewportBase_hitTestChildren_closure(_box_0, _this, child, sliverResult), transform))
          return true;
      }
      return false;
    },
    getOffsetToReveal$4$axis$rect(target, alignment, axis, rect) {
      var onlySlivers, pivot, child, leadingScrollOffset, t1, t2, growthDirection, rectLocal, pivotExtent, targetRect, extentOfPinnedSlivers, targetOffset, offsetDifference, _this = this, _null = null;
      axis = B.axisDirectionToAxis(_this._viewport0$_axisDirection);
      onlySlivers = target instanceof A.RenderSliver;
      for (pivot = _null, child = target, leadingScrollOffset = 0; child.get$parent(child) !== _this; child = t1) {
        t1 = child.get$parent(child);
        t1.toString;
        if (child instanceof B.RenderBox)
          pivot = child;
        if (t1 instanceof A.RenderSliver) {
          t2 = t1.childScrollOffset$1(child);
          t2.toString;
          leadingScrollOffset += t2;
        } else {
          leadingScrollOffset = 0;
          onlySlivers = false;
        }
      }
      if (pivot != null) {
        t1 = pivot.get$parent(pivot);
        t1.toString;
        type$.RenderSliver._as(t1);
        growthDirection = type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(t1)).growthDirection;
        switch (axis.index) {
          case 0:
            t1 = pivot.get$size(0)._dx;
            break;
          case 1:
            t1 = pivot.get$size(0)._dy;
            break;
          default:
            t1 = _null;
        }
        if (rect == null)
          rect = target.get$paintBounds();
        rectLocal = B.MatrixUtils_transformRect(target.getTransformTo$1(0, pivot), rect);
        pivotExtent = t1;
      } else {
        if (onlySlivers) {
          type$.RenderSliver._as(target);
          t1 = type$.SliverConstraints;
          growthDirection = t1._as(B.RenderObject.prototype.get$constraints.call(target)).growthDirection;
          pivotExtent = target._geometry.scrollExtent;
          if (rect == null)
            switch (axis.index) {
              case 0:
                rect = new B.Rect(0, 0, 0 + pivotExtent, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(target)).crossAxisExtent);
                break;
              case 1:
                rect = new B.Rect(0, 0, 0 + t1._as(B.RenderObject.prototype.get$constraints.call(target)).crossAxisExtent, 0 + target._geometry.scrollExtent);
                break;
            }
        } else {
          t1 = _this._viewport0$_offset._pixels;
          t1.toString;
          rect.toString;
          return new F.RevealedOffset(t1, rect);
        }
        rectLocal = rect;
      }
      type$.RenderSliver._as(child);
      switch (D.applyGrowthDirectionToAxisDirection(_this._viewport0$_axisDirection, growthDirection).index) {
        case 0:
          t1 = pivotExtent - rectLocal.bottom;
          break;
        case 3:
          t1 = pivotExtent - rectLocal.right;
          break;
        case 1:
          t1 = rectLocal.left;
          break;
        case 2:
          t1 = rectLocal.top;
          break;
        default:
          t1 = _null;
      }
      if (typeof t1 !== "number")
        return B.iae(t1);
      child._geometry.toString;
      leadingScrollOffset = _this.scrollOffsetOf$2(child, leadingScrollOffset + t1);
      targetRect = B.MatrixUtils_transformRect(target.getTransformTo$1(0, _this), rect);
      extentOfPinnedSlivers = _this.maxScrollObstructionExtentBefore$1(child);
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          leadingScrollOffset -= extentOfPinnedSlivers;
          break;
        case 1:
          switch (axis.index) {
            case 1:
              t1 = targetRect.bottom - targetRect.top;
              break;
            case 0:
              t1 = targetRect.right - targetRect.left;
              break;
            default:
              t1 = _null;
          }
          if (typeof t1 !== "number")
            return B.iae(t1);
          leadingScrollOffset -= t1;
          break;
      }
      switch (axis.index) {
        case 0:
          t1 = _this.get$size(0)._dx - extentOfPinnedSlivers - (rectLocal.right - rectLocal.left);
          break;
        case 1:
          t1 = _this.get$size(0)._dy - extentOfPinnedSlivers - (rectLocal.bottom - rectLocal.top);
          break;
        default:
          t1 = _null;
      }
      targetOffset = leadingScrollOffset - t1 * alignment;
      t1 = _this._viewport0$_offset._pixels;
      t1.toString;
      offsetDifference = t1 - targetOffset;
      switch (_this._viewport0$_axisDirection.index) {
        case 0:
          t1 = targetRect.translate$2(0, 0, -offsetDifference);
          break;
        case 2:
          t1 = targetRect.translate$2(0, 0, offsetDifference);
          break;
        case 3:
          t1 = targetRect.translate$2(0, -offsetDifference, 0);
          break;
        case 1:
          t1 = targetRect.translate$2(0, offsetDifference, 0);
          break;
        default:
          t1 = _null;
      }
      return new F.RevealedOffset(targetOffset, t1);
    },
    getOffsetToReveal$3$rect(target, alignment, rect) {
      return this.getOffsetToReveal$4$axis$rect(target, alignment, null, rect);
    },
    computeAbsolutePaintOffset$3(child, layoutOffset, growthDirection) {
      var t1;
      switch (D.applyGrowthDirectionToAxisDirection(this._viewport0$_axisDirection, growthDirection).index) {
        case 0:
          t1 = new B.Offset(0, this.get$size(0)._dy - layoutOffset - child._geometry.paintExtent);
          break;
        case 3:
          t1 = new B.Offset(this.get$size(0)._dx - layoutOffset - child._geometry.paintExtent, 0);
          break;
        case 1:
          t1 = new B.Offset(layoutOffset, 0);
          break;
        case 2:
          t1 = new B.Offset(0, layoutOffset);
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    showOnScreen$4$curve$descendant$duration$rect(curve, descendant, duration, rect) {
      var _this = this;
      type$.nullable_RenderObject._as(descendant);
      type$.nullable_Rect._as(rect);
      type$.Duration._as(duration);
      type$.Curve._as(curve);
      if (!_this._viewport0$_offset.physics.get$allowImplicitScrolling())
        return _this.super$RenderObject$showOnScreen(curve, descendant, duration, rect);
      _this.super$RenderObject$showOnScreen(curve, null, duration, F.RenderViewportBase_showInViewport(curve, descendant, duration, _this._viewport0$_offset, rect, _this));
    },
    showOnScreen$0() {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_glB, null, C.Duration_0, null);
    },
    showOnScreen$1$rect(rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_glB, null, C.Duration_0, rect);
    },
    showOnScreen$3$curve$duration$rect(curve, duration, rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(curve, null, duration, rect);
    },
    showOnScreen$2$descendant$rect(descendant, rect) {
      return this.showOnScreen$4$curve$descendant$duration$rect(C.Cubic_glB, descendant, C.Duration_0, rect);
    },
    $isRenderAbstractViewport: 1
  };
  A.RenderViewport.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverPhysicalContainerParentData))
        child.parentData = new A.SliverPhysicalContainerParentData(null, null, C.Offset_0_0);
    },
    set$anchor(value) {
      if (value === this._anchor)
        return;
      this._anchor = value;
      this.markNeedsLayout$0();
    },
    set$center(value) {
      if (value == this._viewport0$_center)
        return;
      this._viewport0$_center = value;
      this.markNeedsLayout$0();
    },
    get$sizedByParent() {
      return true;
    },
    computeDryLayout$1(constraints) {
      return new B.Size(B.clampDouble(1 / 0, constraints.minWidth, constraints.maxWidth), B.clampDouble(1 / 0, constraints.minHeight, constraints.maxHeight));
    },
    performLayout$0() {
      var t1, _0_1, crossAxisExtent, _0_2, mainAxisExtent, maxLayoutCycles, count, correction, t2, t3, t4, _this = this;
      switch (B.axisDirectionToAxis(_this._viewport0$_axisDirection).index) {
        case 1:
          _this._viewport0$_offset.applyViewportDimension$1(_this.get$size(0)._dy);
          break;
        case 0:
          _this._viewport0$_offset.applyViewportDimension$1(_this.get$size(0)._dx);
          break;
      }
      if (_this._viewport0$_center == null) {
        _this.__RenderViewport__maxScrollExtent_A = _this.__RenderViewport__minScrollExtent_A = 0;
        _this._viewport0$_hasVisualOverflow = false;
        _this._viewport0$_offset.applyContentDimensions$2(0, 0);
        return;
      }
      switch (B.axisDirectionToAxis(_this._viewport0$_axisDirection).index) {
        case 1:
          t1 = new B._Record_2(_this.get$size(0)._dy, _this.get$size(0)._dx);
          break;
        case 0:
          t1 = new B._Record_2(_this.get$size(0)._dx, _this.get$size(0)._dy);
          break;
        default:
          t1 = null;
      }
      _0_1 = t1._0;
      crossAxisExtent = null;
      _0_2 = t1._1;
      crossAxisExtent = _0_2;
      mainAxisExtent = _0_1;
      _this._viewport0$_center.toString;
      maxLayoutCycles = 10 * _this.ContainerRenderObjectMixin__childCount;
      count = 0;
      do {
        t1 = _this._viewport0$_offset._pixels;
        t1.toString;
        correction = _this._attemptLayout$3(mainAxisExtent, crossAxisExtent, t1 + 0);
        if (correction !== 0)
          _this._viewport0$_offset.correctBy$1(correction);
        else {
          t1 = _this._viewport0$_offset;
          t2 = _this.__RenderViewport__minScrollExtent_A;
          t2 === $ && B.throwLateFieldNI("_minScrollExtent");
          t3 = _this._anchor;
          if (typeof mainAxisExtent !== "number")
            return mainAxisExtent.$mul();
          t2 = Math.min(0, t2 + mainAxisExtent * t3);
          t4 = _this.__RenderViewport__maxScrollExtent_A;
          t4 === $ && B.throwLateFieldNI("_maxScrollExtent");
          if (t1.applyContentDimensions$2(t2, Math.max(0, t4 - mainAxisExtent * (1 - t3))))
            break;
        }
        ++count;
      } while (count < maxLayoutCycles);
    },
    _attemptLayout$3(mainAxisExtent, crossAxisExtent, correctedOffset) {
      var centerOffset, reverseDirectionRemainingPaintExtent, t1, forwardDirectionRemainingPaintExtent, t2, fullCacheExtent, centerCacheOffset, reverseDirectionRemainingCacheExtent, forwardDirectionRemainingCacheExtent, t3, t4, leadingNegativeChild, result, t5, _this = this;
      _this.__RenderViewport__maxScrollExtent_A = _this.__RenderViewport__minScrollExtent_A = 0;
      _this._viewport0$_hasVisualOverflow = false;
      centerOffset = mainAxisExtent * _this._anchor - correctedOffset;
      reverseDirectionRemainingPaintExtent = B.clampDouble(centerOffset, 0, mainAxisExtent);
      t1 = mainAxisExtent - centerOffset;
      forwardDirectionRemainingPaintExtent = B.clampDouble(t1, 0, mainAxisExtent);
      switch (_this._cacheExtentStyle.index) {
        case 0:
          t2 = _this._cacheExtent;
          break;
        case 1:
          t2 = mainAxisExtent * _this._cacheExtent;
          break;
        default:
          t2 = null;
      }
      _this._calculatedCacheExtent = t2;
      t2.toString;
      fullCacheExtent = mainAxisExtent + 2 * t2;
      centerCacheOffset = centerOffset + t2;
      reverseDirectionRemainingCacheExtent = B.clampDouble(centerCacheOffset, 0, fullCacheExtent);
      forwardDirectionRemainingCacheExtent = B.clampDouble(fullCacheExtent - centerCacheOffset, 0, fullCacheExtent);
      t3 = _this._viewport0$_center;
      t3.toString;
      t4 = B._instanceType(_this);
      t3 = t4._eval$1("ContainerRenderObjectMixin.0")._as(t3).parentData;
      t3.toString;
      leadingNegativeChild = t4._eval$1("ContainerRenderObjectMixin.1")._as(t3).ContainerParentDataMixin_previousSibling;
      t3 = leadingNegativeChild == null;
      if (!t3) {
        t4 = Math.max(mainAxisExtent, centerOffset);
        result = _this.layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(_this.get$childBefore(), B.clampDouble(t1, -t2, 0), leadingNegativeChild, crossAxisExtent, H.GrowthDirection_1, forwardDirectionRemainingPaintExtent, mainAxisExtent, 0, reverseDirectionRemainingCacheExtent, reverseDirectionRemainingPaintExtent, t4 - mainAxisExtent);
        if (result !== 0)
          return -result;
      }
      t1 = _this._viewport0$_center;
      t2 = -centerOffset;
      t4 = Math.max(0, t2);
      t2 = t3 ? Math.min(0, t2) : 0;
      t3 = centerOffset >= mainAxisExtent ? centerOffset : reverseDirectionRemainingPaintExtent;
      t5 = _this._calculatedCacheExtent;
      t5.toString;
      return _this.layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(_this.get$childAfter(), B.clampDouble(centerOffset, -t5, 0), t1, crossAxisExtent, H.GrowthDirection_0, t3, mainAxisExtent, t2, forwardDirectionRemainingCacheExtent, forwardDirectionRemainingPaintExtent, t4);
    },
    get$hasVisualOverflow() {
      return this._viewport0$_hasVisualOverflow;
    },
    updateOutOfBandData$2(growthDirection, childLayoutGeometry) {
      var t1, _this = this;
      switch (growthDirection.index) {
        case 0:
          t1 = _this.__RenderViewport__maxScrollExtent_A;
          t1 === $ && B.throwLateFieldNI("_maxScrollExtent");
          _this.__RenderViewport__maxScrollExtent_A = t1 + childLayoutGeometry.scrollExtent;
          break;
        case 1:
          t1 = _this.__RenderViewport__minScrollExtent_A;
          t1 === $ && B.throwLateFieldNI("_minScrollExtent");
          _this.__RenderViewport__minScrollExtent_A = t1 - childLayoutGeometry.scrollExtent;
          break;
      }
      if (childLayoutGeometry.hasVisualOverflow)
        _this._viewport0$_hasVisualOverflow = true;
    },
    updateChildLayoutOffset$3(child, layoutOffset, growthDirection) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverPhysicalParentData._as(t1).paintOffset = this.computeAbsolutePaintOffset$3(child, layoutOffset, growthDirection);
    },
    paintOffsetOf$1(child) {
      var t1 = child.parentData;
      t1.toString;
      return type$.SliverPhysicalParentData._as(t1).paintOffset;
    },
    scrollOffsetOf$2(child, scrollOffsetWithinChild) {
      var current, t1, t2, scrollOffsetToChild, t3, _this = this;
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          current = _this._viewport0$_center;
          for (t1 = B._instanceType(_this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"), scrollOffsetToChild = 0; current !== child;) {
            scrollOffsetToChild += current._geometry.scrollExtent;
            t3 = t2._as(current).parentData;
            t3.toString;
            current = t1._as(t3).ContainerParentDataMixin_nextSibling;
          }
          return scrollOffsetToChild + scrollOffsetWithinChild;
        case 1:
          t1 = _this._viewport0$_center;
          t1.toString;
          t2 = B._instanceType(_this);
          t3 = t2._eval$1("ContainerRenderObjectMixin.0");
          t1 = t3._as(t1).parentData;
          t1.toString;
          t2 = t2._eval$1("ContainerRenderObjectMixin.1");
          current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          for (scrollOffsetToChild = 0; current !== child;) {
            scrollOffsetToChild -= current._geometry.scrollExtent;
            t1 = t3._as(current).parentData;
            t1.toString;
            current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          }
          return scrollOffsetToChild - scrollOffsetWithinChild;
      }
    },
    maxScrollObstructionExtentBefore$1(child) {
      var current, t1, t2, t3, _this = this;
      switch (type$.SliverConstraints._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection.index) {
        case 0:
          current = _this._viewport0$_center;
          for (t1 = B._instanceType(_this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"); current !== child;) {
            current._geometry.toString;
            t3 = t2._as(current).parentData;
            t3.toString;
            current = t1._as(t3).ContainerParentDataMixin_nextSibling;
          }
          return 0;
        case 1:
          t1 = _this._viewport0$_center;
          t1.toString;
          t2 = B._instanceType(_this);
          t3 = t2._eval$1("ContainerRenderObjectMixin.0");
          t1 = t3._as(t1).parentData;
          t1.toString;
          t2 = t2._eval$1("ContainerRenderObjectMixin.1");
          current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          for (; current !== child;) {
            current._geometry.toString;
            t1 = t3._as(current).parentData;
            t1.toString;
            current = t2._as(t1).ContainerParentDataMixin_previousSibling;
          }
          return 0;
      }
    },
    applyPaintTransform$2(child, transform) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverPhysicalParentData._as(t1).paintOffset;
      transform.translate$2(0, t1._dx, t1._dy);
    },
    computeChildMainAxisPosition$2(child, parentMainAxisPosition) {
      var paintOffset,
        t1 = child.parentData;
      t1.toString;
      paintOffset = type$.SliverPhysicalParentData._as(t1).paintOffset;
      t1 = type$.SliverConstraints;
      switch (D.applyGrowthDirectionToAxisDirection(t1._as(B.RenderObject.prototype.get$constraints.call(child)).axisDirection, t1._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection).index) {
        case 2:
          t1 = parentMainAxisPosition - paintOffset._dy;
          break;
        case 1:
          t1 = parentMainAxisPosition - paintOffset._dx;
          break;
        case 0:
          t1 = child._geometry.paintExtent - (parentMainAxisPosition - paintOffset._dy);
          break;
        case 3:
          t1 = child._geometry.paintExtent - (parentMainAxisPosition - paintOffset._dx);
          break;
        default:
          t1 = null;
      }
      return t1;
    },
    get$childrenInPaintOrder() {
      var t1, t2, t3, _this = this,
        children = B._setArrayType([], type$.JSArray_RenderSliver),
        child = _this.ContainerRenderObjectMixin__firstChild;
      if (child == null)
        return children;
      for (t1 = B._instanceType(_this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"); child != _this._viewport0$_center;) {
        child.toString;
        C.JSArray_methods.add$1(children, child);
        t3 = t2._as(child).parentData;
        t3.toString;
        child = t1._as(t3).ContainerParentDataMixin_nextSibling;
      }
      child = _this.ContainerRenderObjectMixin__lastChild;
      for (; true;) {
        child.toString;
        C.JSArray_methods.add$1(children, child);
        if (child === _this._viewport0$_center)
          return children;
        t3 = t2._as(child).parentData;
        t3.toString;
        child = t1._as(t3).ContainerParentDataMixin_previousSibling;
      }
    },
    get$childrenInHitTestOrder() {
      var child, t1, t2, t3, _this = this,
        children = B._setArrayType([], type$.JSArray_RenderSliver);
      if (_this.ContainerRenderObjectMixin__firstChild == null)
        return children;
      child = _this._viewport0$_center;
      for (t1 = B._instanceType(_this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        C.JSArray_methods.add$1(children, child);
        t3 = t2._as(child).parentData;
        t3.toString;
        child = t1._as(t3).ContainerParentDataMixin_nextSibling;
      }
      t3 = _this._viewport0$_center;
      t3.toString;
      t3 = t2._as(t3).parentData;
      t3.toString;
      child = t1._as(t3).ContainerParentDataMixin_previousSibling;
      for (; child != null;) {
        C.JSArray_methods.add$1(children, child);
        t3 = t2._as(child).parentData;
        t3.toString;
        child = t1._as(t3).ContainerParentDataMixin_previousSibling;
      }
      return children;
    },
    set$_viewport0$_center(_center) {
      this._viewport0$_center = type$.nullable_RenderSliver._as(_center);
    }
  };
  A.RenderShrinkWrappingViewport.prototype = {
    setupParentData$1(child) {
      if (!(child.parentData instanceof A.SliverLogicalContainerParentData))
        child.parentData = new A.SliverLogicalContainerParentData(null, null);
    },
    performLayout$0() {
      var t1, _0_1, crossAxisExtent, _0_2, mainAxisExtent, t2, t3, t4, effectiveExtent, t5, correction, t6, didAcceptViewportDimension, t7, didAcceptContentDimension, _this = this, _null = null,
        _s17_ = "_shrinkWrapExtent",
        constraints = type$.BoxConstraints._as(B.RenderObject.prototype.get$constraints.call(_this));
      if (_this.ContainerRenderObjectMixin__firstChild == null) {
        switch (B.axisDirectionToAxis(_this._viewport0$_axisDirection).index) {
          case 1:
            t1 = new B.Size(constraints.maxWidth, constraints.minHeight);
            break;
          case 0:
            t1 = new B.Size(constraints.minWidth, constraints.maxHeight);
            break;
          default:
            t1 = _null;
        }
        _this._box$_size = type$.Size._as(t1);
        _this._viewport0$_offset.applyViewportDimension$1(0);
        _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A = _this.__RenderShrinkWrappingViewport__maxScrollExtent_A = 0;
        _this._viewport0$_hasVisualOverflow = false;
        _this._viewport0$_offset.applyContentDimensions$2(0, 0);
        return;
      }
      switch (B.axisDirectionToAxis(_this._viewport0$_axisDirection).index) {
        case 1:
          t1 = new B._Record_2(constraints.maxHeight, constraints.maxWidth);
          break;
        case 0:
          t1 = new B._Record_2(constraints.maxWidth, constraints.maxHeight);
          break;
        default:
          t1 = _null;
      }
      _0_1 = t1._0;
      crossAxisExtent = _null;
      _0_2 = t1._1;
      crossAxisExtent = _0_2;
      mainAxisExtent = _0_1;
      for (t1 = constraints.minWidth, t2 = constraints.maxWidth, t3 = constraints.minHeight, t4 = constraints.maxHeight, effectiveExtent = _null; true;) {
        t5 = _this._viewport0$_offset._pixels;
        t5.toString;
        correction = _this._attemptLayout$3(mainAxisExtent, crossAxisExtent, t5);
        if (correction !== 0) {
          t5 = _this._viewport0$_offset;
          t6 = t5._pixels;
          t6.toString;
          t5._pixels = t6 + correction;
          t5._didChangeViewportDimensionOrReceiveCorrection = true;
        } else {
          switch (B.axisDirectionToAxis(_this._viewport0$_axisDirection).index) {
            case 1:
              t5 = _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A;
              t5 === $ && B.throwLateFieldNI(_s17_);
              t5 = B.clampDouble(t5, t3, t4);
              break;
            case 0:
              t5 = _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A;
              t5 === $ && B.throwLateFieldNI(_s17_);
              t5 = B.clampDouble(t5, t1, t2);
              break;
            default:
              t5 = _null;
          }
          didAcceptViewportDimension = _this._viewport0$_offset.applyViewportDimension$1(t5);
          t6 = _this._viewport0$_offset;
          t7 = _this.__RenderShrinkWrappingViewport__maxScrollExtent_A;
          t7 === $ && B.throwLateFieldNI("_maxScrollExtent");
          didAcceptContentDimension = t6.applyContentDimensions$2(0, Math.max(0, t7 - t5));
          if (didAcceptViewportDimension && didAcceptContentDimension) {
            effectiveExtent = t5;
            break;
          }
          effectiveExtent = t5;
        }
      }
      switch (B.axisDirectionToAxis(_this._viewport0$_axisDirection).index) {
        case 1:
          B._asDouble(crossAxisExtent);
          B._asDouble(effectiveExtent);
          t1 = new B.Size(B.clampDouble(crossAxisExtent, t1, t2), B.clampDouble(effectiveExtent, t3, t4));
          break;
        case 0:
          B._asDouble(effectiveExtent);
          B._asDouble(crossAxisExtent);
          t1 = new B.Size(B.clampDouble(effectiveExtent, t1, t2), B.clampDouble(crossAxisExtent, t3, t4));
          break;
        default:
          t1 = _null;
      }
      _this._box$_size = type$.Size._as(t1);
    },
    _attemptLayout$3(mainAxisExtent, crossAxisExtent, correctedOffset) {
      var t1, t2, t3, t4, t5, _this = this;
      _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A = _this.__RenderShrinkWrappingViewport__maxScrollExtent_A = 0;
      _this._viewport0$_hasVisualOverflow = correctedOffset < 0;
      switch (_this._cacheExtentStyle.index) {
        case 0:
          t1 = _this._cacheExtent;
          break;
        case 1:
          t1 = mainAxisExtent * _this._cacheExtent;
          break;
        default:
          t1 = null;
      }
      _this._calculatedCacheExtent = t1;
      t2 = _this.ContainerRenderObjectMixin__firstChild;
      t3 = Math.max(0, correctedOffset);
      t4 = Math.min(0, correctedOffset);
      t5 = Math.max(0, -correctedOffset);
      t1.toString;
      return _this.layoutChildSequence$11$advance$cacheOrigin$child$crossAxisExtent$growthDirection$layoutOffset$mainAxisExtent$overlap$remainingCacheExtent$remainingPaintExtent$scrollOffset(_this.get$childAfter(), -t1, t2, crossAxisExtent, H.GrowthDirection_0, t5, mainAxisExtent, t4, mainAxisExtent + 2 * t1, mainAxisExtent + t4, t3);
    },
    get$hasVisualOverflow() {
      return this._viewport0$_hasVisualOverflow;
    },
    updateOutOfBandData$2(growthDirection, childLayoutGeometry) {
      var _this = this,
        t1 = _this.__RenderShrinkWrappingViewport__maxScrollExtent_A;
      t1 === $ && B.throwLateFieldNI("_maxScrollExtent");
      _this.__RenderShrinkWrappingViewport__maxScrollExtent_A = t1 + childLayoutGeometry.scrollExtent;
      if (childLayoutGeometry.hasVisualOverflow)
        _this._viewport0$_hasVisualOverflow = true;
      t1 = _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A;
      t1 === $ && B.throwLateFieldNI("_shrinkWrapExtent");
      _this.__RenderShrinkWrappingViewport__shrinkWrapExtent_A = t1 + childLayoutGeometry.maxPaintExtent;
    },
    updateChildLayoutOffset$3(child, layoutOffset, growthDirection) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverLogicalParentData._as(t1).layoutOffset = layoutOffset;
    },
    paintOffsetOf$1(child) {
      var t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverLogicalParentData._as(t1).layoutOffset;
      t1.toString;
      return this.computeAbsolutePaintOffset$3(child, t1, H.GrowthDirection_0);
    },
    scrollOffsetOf$2(child, scrollOffsetWithinChild) {
      var t1, t2, scrollOffsetToChild, t3,
        current = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"), scrollOffsetToChild = 0; current !== child;) {
        scrollOffsetToChild += current._geometry.scrollExtent;
        t3 = t2._as(current).parentData;
        t3.toString;
        current = t1._as(t3).ContainerParentDataMixin_nextSibling;
      }
      return scrollOffsetToChild + scrollOffsetWithinChild;
    },
    maxScrollObstructionExtentBefore$1(child) {
      var t1, t2, t3,
        current = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"); current !== child;) {
        current._geometry.toString;
        t3 = t2._as(current).parentData;
        t3.toString;
        current = t1._as(t3).ContainerParentDataMixin_nextSibling;
      }
      return 0;
    },
    applyPaintTransform$2(child, transform) {
      var offset = this.paintOffsetOf$1(type$.RenderSliver._as(child));
      transform.translate$2(0, offset._dx, offset._dy);
    },
    computeChildMainAxisPosition$2(child, parentMainAxisPosition) {
      var t2, _0_0,
        t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverLogicalParentData._as(t1).layoutOffset;
      t1.toString;
      t2 = type$.SliverConstraints;
      _0_0 = D.applyGrowthDirectionToAxisDirection(t2._as(B.RenderObject.prototype.get$constraints.call(child)).axisDirection, t2._as(B.RenderObject.prototype.get$constraints.call(child)).growthDirection);
      $label0$0: {
        if (C.AxisDirection_2 === _0_0 || C.AxisDirection_1 === _0_0) {
          t1 = parentMainAxisPosition - t1;
          break $label0$0;
        }
        if (C.AxisDirection_0 === _0_0) {
          t1 = this.get$size(0)._dy - parentMainAxisPosition - t1;
          break $label0$0;
        }
        if (C.AxisDirection_3 === _0_0) {
          t1 = this.get$size(0)._dx - parentMainAxisPosition - t1;
          break $label0$0;
        }
        t1 = null;
      }
      return t1;
    },
    get$childrenInPaintOrder() {
      var t1, t2, t3,
        children = B._setArrayType([], type$.JSArray_RenderSliver),
        child = this.ContainerRenderObjectMixin__lastChild;
      for (t1 = B._instanceType(this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        C.JSArray_methods.add$1(children, child);
        t3 = t2._as(child).parentData;
        t3.toString;
        child = t1._as(t3).ContainerParentDataMixin_previousSibling;
      }
      return children;
    },
    get$childrenInHitTestOrder() {
      var t1, t2, t3,
        children = B._setArrayType([], type$.JSArray_RenderSliver),
        child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this), t2 = t1._eval$1("ContainerRenderObjectMixin.0"), t1 = t1._eval$1("ContainerRenderObjectMixin.1"); child != null;) {
        C.JSArray_methods.add$1(children, child);
        t3 = t2._as(child).parentData;
        t3.toString;
        child = t1._as(t3).ContainerParentDataMixin_nextSibling;
      }
      return children;
    }
  };
  A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin.prototype = {
    attach$1(owner) {
      var child, t1, t2;
      this.super$RenderObject$attach(owner);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0"); child != null;) {
        child.attach$1(owner);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    },
    detach$0(_) {
      var child, t1, t2;
      this.super$RenderObject$detach(0);
      child = this.ContainerRenderObjectMixin__firstChild;
      for (t1 = B._instanceType(this)._eval$1("_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0"); child != null;) {
        child.detach$0(0);
        t2 = child.parentData;
        t2.toString;
        child = t1._as(t2).ContainerParentDataMixin_nextSibling;
      }
    }
  };
  A.AutomaticKeepAlive.prototype = {
    createState$0() {
      return new A._AutomaticKeepAliveState();
    }
  };
  A._AutomaticKeepAliveState.prototype = {
    initState$0() {
      this.super$State$initState();
      this._automatic_keep_alive$_updateChild$0();
    },
    didUpdateWidget$1(oldWidget) {
      this.super$State$didUpdateWidget(type$.AutomaticKeepAlive._as(oldWidget));
      this._automatic_keep_alive$_updateChild$0();
    },
    _automatic_keep_alive$_updateChild$0() {
      this.___AutomaticKeepAliveState__child_A = new D.NotificationListener(this.get$_addClient(), this._widget.child, null, type$.NotificationListener_KeepAliveNotification);
    },
    dispose$0() {
      var t2, t3,
        t1 = this._automatic_keep_alive$_handles;
      if (t1 != null)
        for (t1 = new B.LinkedHashMapKeyIterator(t1, t1._modifications, t1._first, B._instanceType(t1)._eval$1("LinkedHashMapKeyIterator<1>")); t1.moveNext$0();) {
          t2 = t1.__js_helper$_current;
          t3 = this._automatic_keep_alive$_handles.$index(0, t2);
          t3.toString;
          t2.removeListener$1(0, t3);
        }
      this.super$State$dispose();
    },
    _addClient$1(notification) {
      var t1, childElement, _this = this,
        handle = type$.KeepAliveNotification._as(notification).handle;
      if (_this._automatic_keep_alive$_handles == null)
        _this.set$_automatic_keep_alive$_handles(B.LinkedHashMap_LinkedHashMap$_empty(type$.Listenable, type$.void_Function));
      t1 = _this._automatic_keep_alive$_handles;
      t1.toString;
      t1.$indexSet(0, handle, _this._createCallback$1(handle));
      t1 = _this._automatic_keep_alive$_handles.$index(0, handle);
      t1.toString;
      handle.addListener$1(0, t1);
      if (!_this._keepingAlive) {
        _this._keepingAlive = true;
        childElement = _this._getChildElement$0();
        if (childElement != null)
          _this._updateParentDataOfChild$1(childElement);
        else {
          t1 = $.SchedulerBinding__instance;
          t1.toString;
          C.JSArray_methods.add$1(t1.SchedulerBinding__postFrameCallbacks, type$.void_Function_Duration._as(new A._AutomaticKeepAliveState__addClient_closure(_this)));
        }
      }
      return false;
    },
    _getChildElement$0() {
      var t1 = {},
        t2 = this._framework$_element;
      t2.toString;
      t1.childElement = null;
      t2.visitChildren$1(new A._AutomaticKeepAliveState__getChildElement_closure(t1));
      return type$.nullable_ParentDataElement_KeepAliveParentDataMixin._as(t1.childElement);
    },
    _updateParentDataOfChild$1(childElement) {
      var t1, t2;
      type$.ParentDataElement_KeepAliveParentDataMixin._as(childElement);
      this._framework$_element.toString;
      t1 = this._keepingAlive;
      t2 = this.___AutomaticKeepAliveState__child_A;
      t2 === $ && B.throwLateFieldNI("_child");
      childElement._applyParentData$1(childElement.$ti._eval$1("ParentDataWidget<1>")._as(type$.ParentDataWidget_KeepAliveParentDataMixin._as(A.KeepAlive$(t2, t1))));
    },
    _createCallback$1(handle) {
      var callback = B._Cell$named("callback"),
        t1 = new A._AutomaticKeepAliveState__createCallback_closure(this, handle, callback);
      callback.set$finalLocalValue(t1);
      return t1;
    },
    build$1(context) {
      var t1 = this._keepingAlive,
        t2 = this.___AutomaticKeepAliveState__child_A;
      t2 === $ && B.throwLateFieldNI("_child");
      return new A.KeepAlive(t1, t2, null);
    },
    set$_automatic_keep_alive$_handles(_handles) {
      this._automatic_keep_alive$_handles = type$.nullable_Map_of_Listenable_and_void_Function._as(_handles);
    }
  };
  A.SliverPadding.prototype = {
    createRenderObject$1(context) {
      var t1 = new A.RenderSliverPadding(this.padding, context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality).textDirection, null, B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      type$.RenderSliverPadding._as(renderObject);
      renderObject.set$padding(0, this.padding);
      renderObject.set$textDirection(context.dependOnInheritedWidgetOfExactType$1$0(type$.Directionality).textDirection);
    }
  };
  A.IndexedSemantics.prototype = {
    createRenderObject$1(context) {
      var t1 = new A.RenderIndexedSemantics(this.index, null, new B._LayoutCacheStorage(), B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      t1.set$child(null);
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      type$.RenderIndexedSemantics._as(renderObject).set$index(0, this.index);
    }
  };
  A.SliverChildDelegate.prototype = {
    get$estimatedChildCount() {
      return null;
    },
    findIndexByKey$1(key) {
      return null;
    },
    toString$0(_) {
      var description = B._setArrayType([], type$.JSArray_String);
      this.debugFillDescription$1(description);
      return "<optimized out>#" + B.shortHash(this) + "(" + C.JSArray_methods.join$1(description, ", ") + ")";
    },
    debugFillDescription$1(description) {
      var children, e, exception;
      type$.List_String._as(description);
      try {
        children = this.get$estimatedChildCount();
        if (children != null)
          C.JSArray_methods.add$1(description, "estimated child count: " + B.S(children));
      } catch (exception) {
        e = B.unwrapException(exception);
        C.JSArray_methods.add$1(description, "estimated child count: EXCEPTION (" + J.get$runtimeType$(e).toString$0(0) + ")");
      }
    }
  };
  A._SaltedValueKey.prototype = {};
  A.SliverChildBuilderDelegate.prototype = {
    findIndexByKey$1(key) {
      var t1 = this.findChildIndexCallback;
      if (t1 == null)
        return null;
      return t1.call$1(key instanceof A._SaltedValueKey ? key.value : key);
    },
    build$2(context, index) {
      var child, exception, stackTrace, t1, exception0, details, key, semanticIndex, _null = null;
      if (index >= 0)
        t1 = index >= this.childCount;
      else
        t1 = true;
      if (t1)
        return _null;
      child = null;
      try {
        child = this.builder.call$2(context, index);
      } catch (exception0) {
        exception = B.unwrapException(exception0);
        stackTrace = B.getTraceFromException(exception0);
        details = new B.FlutterErrorDetails(exception, stackTrace, "widgets library", B.ErrorDescription$("building"), _null, false);
        B.FlutterError_reportError(details);
        child = B.ErrorWidget__defaultErrorWidgetBuilder(details);
      }
      if (child == null)
        return _null;
      if (child.key != null) {
        t1 = child.key;
        t1.toString;
        key = new A._SaltedValueKey(t1);
      } else
        key = _null;
      t1 = child;
      child = new D.RepaintBoundary(t1, _null);
      semanticIndex = this.semanticIndexCallback.call$2(child, index);
      if (semanticIndex != null)
        child = new A.IndexedSemantics(semanticIndex, child, _null);
      t1 = child;
      child = new A.AutomaticKeepAlive(new A._SelectionKeepAlive(t1, _null), _null);
      return new N.KeyedSubtree(child, key);
    },
    get$estimatedChildCount() {
      return this.childCount;
    },
    shouldRebuild$1(oldDelegate) {
      type$.SliverChildBuilderDelegate._as(oldDelegate);
      return true;
    }
  };
  A._SelectionKeepAlive.prototype = {
    createState$0() {
      return new A._SelectionKeepAliveState(null);
    }
  };
  A._SelectionKeepAliveState.prototype = {
    get$wantKeepAlive() {
      return this._wantKeepAlive;
    },
    listensTo$1(selectable) {
      return new A._SelectionKeepAliveState_listensTo_closure(this, selectable);
    },
    _updateSelectablesWithSelections$2$add(selectable, add) {
      var t1, _this = this;
      if (add) {
        if (_this._selectablesWithSelections == null)
          _this.set$_selectablesWithSelections(B.LinkedHashSet_LinkedHashSet$_empty(type$.Selectable));
        _this._selectablesWithSelections.add$1(0, selectable);
      } else {
        t1 = _this._selectablesWithSelections;
        if (t1 != null)
          t1.remove$1(0, selectable);
      }
      t1 = _this._selectablesWithSelections;
      t1 = t1 == null ? null : t1._collection$_length !== 0;
      t1 = t1 === true;
      if (_this._wantKeepAlive !== t1) {
        _this._wantKeepAlive = t1;
        _this.updateKeepAlive$0();
      }
    },
    didChangeDependencies$0() {
      var t1, newRegistrar, t2, _this = this;
      _this.super$State$didChangeDependencies();
      t1 = _this._framework$_element;
      t1.toString;
      newRegistrar = I.SelectionContainer_maybeOf(t1);
      t1 = _this._scroll_delegate$_registrar;
      if (t1 != newRegistrar) {
        if (t1 != null) {
          t2 = _this._selectableAttachments;
          if (t2 != null)
            new B.LinkedHashMapKeysIterable(t2, B._instanceType(t2)._eval$1("LinkedHashMapKeysIterable<1>")).forEach$1(0, t1.get$remove(t1));
        }
        _this._scroll_delegate$_registrar = newRegistrar;
        if (newRegistrar != null) {
          t1 = _this._selectableAttachments;
          if (t1 != null)
            new B.LinkedHashMapKeysIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapKeysIterable<1>")).forEach$1(0, newRegistrar.get$add(newRegistrar));
        }
      }
    },
    add$1(_, selectable) {
      var attachment, _this = this,
        t1 = type$.Selectable;
      t1._as(selectable);
      attachment = _this.listensTo$1(selectable);
      selectable.addListener$1(0, attachment);
      if (_this._selectableAttachments == null)
        _this.set$_selectableAttachments(B.LinkedHashMap_LinkedHashMap$_empty(t1, type$.void_Function));
      _this._selectableAttachments.$indexSet(0, selectable, attachment);
      _this._scroll_delegate$_registrar.add$1(0, selectable);
      if (selectable.get$value(selectable).status !== M.SelectionStatus_2)
        _this._updateSelectablesWithSelections$2$add(selectable, true);
    },
    remove$1(_, selectable) {
      var t1;
      type$.Selectable._as(selectable);
      t1 = this._selectableAttachments;
      if (t1 == null)
        return;
      t1 = t1.remove$1(0, selectable);
      t1.toString;
      selectable.removeListener$1(0, t1);
      this._scroll_delegate$_registrar.remove$1(0, selectable);
      this._updateSelectablesWithSelections$2$add(selectable, false);
    },
    dispose$0() {
      var t2, t3, _this = this,
        t1 = _this._selectableAttachments;
      if (t1 != null) {
        for (t1 = new B.LinkedHashMapKeyIterator(t1, t1._modifications, t1._first, B._instanceType(t1)._eval$1("LinkedHashMapKeyIterator<1>")); t1.moveNext$0();) {
          t2 = t1.__js_helper$_current;
          _this._scroll_delegate$_registrar.remove$1(0, t2);
          t3 = _this._selectableAttachments.$index(0, t2);
          t3.toString;
          t2.removeListener$1(0, t3);
        }
        _this.set$_selectableAttachments(null);
      }
      _this.set$_selectablesWithSelections(null);
      _this.super$State$dispose();
    },
    build$1(context) {
      var _this = this;
      _this.super$AutomaticKeepAliveClientMixin$build(context);
      if (_this._scroll_delegate$_registrar == null)
        return _this._widget.child;
      return I.SelectionRegistrarScope$(_this._widget.child, _this);
    },
    set$_selectablesWithSelections(_selectablesWithSelections) {
      this._selectablesWithSelections = type$.nullable_Set_Selectable._as(_selectablesWithSelections);
    },
    set$_selectableAttachments(_selectableAttachments) {
      this._selectableAttachments = type$.nullable_Map_of_Selectable_and_void_Function._as(_selectableAttachments);
    },
    $isSelectionRegistrar: 1
  };
  A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin.prototype = {
    initState$0() {
      this.super$State$initState();
      if (this._wantKeepAlive)
        this._ensureKeepAlive$0();
    },
    deactivate$0() {
      var t1 = this.AutomaticKeepAliveClientMixin__keepAliveHandle;
      if (t1 != null) {
        t1.notifyListeners$0();
        t1.super$ChangeNotifier$dispose();
        this.AutomaticKeepAliveClientMixin__keepAliveHandle = null;
      }
      this.super$State$deactivate();
    }
  };
  A.AlwaysScrollableScrollPhysics.prototype = {
    applyTo$1(ancestor) {
      return new A.AlwaysScrollableScrollPhysics(this.buildParent$1(ancestor));
    },
    shouldAcceptUserOffset$1(position) {
      return true;
    }
  };
  A.ScrollView.prototype = {
    buildViewport$4(context, offset, axisDirection, slivers) {
      var _this = this;
      type$.List_Widget._as(slivers);
      if (_this.shrinkWrap)
        return new A.ShrinkWrappingViewport(axisDirection, offset, _this.clipBehavior, slivers, null);
      return A.Viewport$(_this.anchor, axisDirection, _this.cacheExtent, G.CacheExtentStyle_0, _this.center, _this.clipBehavior, offset, slivers);
    },
    build$1(context) {
      var scrollController, scrollable, scrollableResult, _this = this,
        slivers = _this.buildSlivers$1(context),
        t1 = _this.scrollDirection,
        axisDirection = F.getAxisDirectionFromAxisReverseAndDirectionality(context, t1, false),
        effectivePrimary = _this.primary;
      effectivePrimary = _this.controller == null && F.PrimaryScrollController_shouldInherit(context, t1);
      scrollController = effectivePrimary ? D.PrimaryScrollController_maybeOf(context) : _this.controller;
      scrollable = F.Scrollable$(axisDirection, _this.clipBehavior, scrollController, _this.dragStartBehavior, false, _this.hitTestBehavior, null, _this.physics, _this.restorationId, _this.scrollBehavior, _this.semanticChildCount, new A.ScrollView_build_closure(_this, axisDirection, slivers));
      scrollableResult = effectivePrimary && scrollController != null ? F.PrimaryScrollController$none(scrollable) : scrollable;
      if (_this.keyboardDismissBehavior === L.ScrollViewKeyboardDismissBehavior_1)
        return new D.NotificationListener(new A.ScrollView_build_closure0(context), scrollableResult, null, type$.NotificationListener_ScrollUpdateNotification);
      else
        return scrollableResult;
    }
  };
  A.SliverWithKeepAliveWidget.prototype = {};
  A.SliverMultiBoxAdaptorWidget.prototype = {
    createElement$0(_) {
      return A.SliverMultiBoxAdaptorElement$(this, false);
    },
    estimateMaxScrollOffset$5(constraints, firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset) {
      return null;
    }
  };
  A.SliverList.prototype = {
    createElement$0(_) {
      return A.SliverMultiBoxAdaptorElement$(this, true);
    },
    createRenderObject$1(context) {
      var t1 = new A.RenderSliverList(type$.SliverMultiBoxAdaptorElement._as(context), B.LinkedHashMap_LinkedHashMap$_empty(type$.int, type$.RenderBox), 0, null, null, B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      return t1;
    }
  };
  A.SliverMultiBoxAdaptorElement.prototype = {
    get$renderObject() {
      return type$.RenderSliverMultiBoxAdaptor._as(B.RenderObjectElement.prototype.get$renderObject.call(this));
    },
    update$1(_, newWidget) {
      var t2, newDelegate, oldDelegate,
        t1 = type$.SliverMultiBoxAdaptorWidget;
      t1._as(newWidget);
      t2 = this._widget;
      t2.toString;
      t1._as(t2);
      this.super$RenderObjectElement$update(0, newWidget);
      newDelegate = newWidget.delegate;
      oldDelegate = t2.delegate;
      if (newDelegate !== oldDelegate)
        t1 = B.getRuntimeTypeOfDartObject(newDelegate) !== B.getRuntimeTypeOfDartObject(oldDelegate) || newDelegate.shouldRebuild$1(oldDelegate);
      else
        t1 = false;
      if (t1)
        this.performRebuild$0();
    },
    performRebuild$0() {
      var newChildren, indexToLayoutOffset, adaptorWidget, processElement, index, key, newIndex, childParentData, lastKey, rightBoundary, t1, t2, t3, t4, t5, _i, t6, lastKey0, _this = this, _null = null, _box_0 = {};
      _this.super$RenderObjectElement$performRebuild();
      _this._currentBeforeChild = null;
      _box_0.childrenUpdated = false;
      try {
        t1 = type$.int;
        newChildren = A.SplayTreeMap$(_null, t1, type$.nullable_Element);
        indexToLayoutOffset = B.HashMap_HashMap(_null, _null, _null, t1, type$.double);
        t1 = _this._widget;
        t1.toString;
        adaptorWidget = type$.SliverMultiBoxAdaptorWidget._as(t1);
        processElement = new A.SliverMultiBoxAdaptorElement_performRebuild_processElement(_box_0, _this, newChildren, adaptorWidget, indexToLayoutOffset);
        for (t1 = _this._childElements, t2 = t1.$ti._eval$1("_SplayTreeKeyIterable<1,_SplayTreeMapNode<1,2>>"), t2 = B.List_List$of(new A._SplayTreeKeyIterable(t1, t2), true, t2._eval$1("Iterable.E")), t3 = t2.length, t4 = type$.nullable_SliverMultiBoxAdaptorParentData, t5 = _this._replaceMovedChildren, _i = 0; _i < t3; ++_i) {
          index = t2[_i];
          t6 = t1._untypedLookup$1(index);
          key = (t6 == null ? _null : t6.value).get$widget().key;
          newIndex = key == null ? _null : adaptorWidget.delegate.findIndexByKey$1(key);
          t6 = t1._untypedLookup$1(index);
          t6 = (t6 == null ? _null : t6.value).get$renderObject();
          childParentData = t4._as(t6 == null ? _null : t6.parentData);
          if (childParentData != null && childParentData.layoutOffset != null) {
            t6 = childParentData.layoutOffset;
            t6.toString;
            J.$indexSet$ax(indexToLayoutOffset, index, t6);
          }
          if (newIndex != null && !J.$eq$(newIndex, index)) {
            if (childParentData != null)
              childParentData.layoutOffset = null;
            t6 = t1._untypedLookup$1(index);
            t6 = t6 == null ? _null : t6.value;
            J.$indexSet$ax(newChildren, newIndex, t6);
            if (t5)
              J.putIfAbsent$2$x(newChildren, index, new A.SliverMultiBoxAdaptorElement_performRebuild_closure());
            t1.remove$1(0, index);
          } else
            J.putIfAbsent$2$x(newChildren, index, new A.SliverMultiBoxAdaptorElement_performRebuild_closure0(_this, index));
        }
        _this.get$renderObject();
        t2 = newChildren;
        new A._SplayTreeKeyIterable(t2, t2.$ti._eval$1("_SplayTreeKeyIterable<1,_SplayTreeMapNode<1,2>>")).forEach$1(0, processElement);
        if (!_box_0.childrenUpdated && _this._didUnderflow) {
          lastKey0 = t1.lastKey$0();
          lastKey = lastKey0 == null ? -1 : lastKey0;
          t2 = lastKey;
          if (typeof t2 !== "number")
            return t2.$add();
          rightBoundary = t2 + 1;
          J.$indexSet$ax(newChildren, rightBoundary, t1.$index(0, rightBoundary));
          processElement.call$1(rightBoundary);
        }
      } finally {
        _this._currentlyUpdatingChildIndex = null;
        _this.get$renderObject();
      }
    },
    createChild$2$after(index, after) {
      this._framework$_owner.buildScope$2(this, new A.SliverMultiBoxAdaptorElement_createChild_closure(this, after, index));
    },
    updateChild$3(child, newWidget, newSlot) {
      var t1, t2, newChild, t3, _null = null;
      if (child == null)
        t1 = _null;
      else {
        t1 = child.get$renderObject();
        t1 = t1 == null ? _null : t1.parentData;
      }
      t2 = type$.nullable_SliverMultiBoxAdaptorParentData;
      t2._as(t1);
      newChild = this.super$Element$updateChild(child, newWidget, newSlot);
      if (newChild == null)
        t3 = _null;
      else {
        t3 = newChild.get$renderObject();
        t3 = t3 == null ? _null : t3.parentData;
      }
      t2._as(t3);
      if (t1 != t3 && t1 != null && t3 != null)
        t3.layoutOffset = t1.layoutOffset;
      return newChild;
    },
    forgetChild$1(child) {
      this._childElements.remove$1(0, child._slot);
      this.super$Element$forgetChild(child);
    },
    removeChild$1(child) {
      var t1, _this = this;
      type$.RenderBox._as(child);
      _this.get$renderObject();
      t1 = child.parentData;
      t1.toString;
      t1 = type$.SliverMultiBoxAdaptorParentData._as(t1).index;
      t1.toString;
      _this._framework$_owner.buildScope$2(_this, new A.SliverMultiBoxAdaptorElement_removeChild_closure(_this, t1));
    },
    estimateMaxScrollOffset$5$firstIndex$lastIndex$leadingScrollOffset$trailingScrollOffset(constraints, firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset) {
      var t2, childCount,
        t1 = this._widget;
      t1.toString;
      t2 = type$.SliverMultiBoxAdaptorWidget;
      childCount = t2._as(t1).delegate.get$estimatedChildCount();
      if (childCount == null)
        return 1 / 0;
      t1 = this._widget;
      t1.toString;
      t2._as(t1);
      leadingScrollOffset.toString;
      t1 = t1.estimateMaxScrollOffset$5(constraints, firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset);
      return t1 == null ? A.SliverMultiBoxAdaptorElement__extrapolateMaxScrollOffset(firstIndex, lastIndex, leadingScrollOffset, trailingScrollOffset, childCount) : t1;
    },
    get$childCount() {
      var t2, result, lo, hi, lo0, mid, _this = this,
        t1 = _this._widget;
      t1.toString;
      t2 = type$.SliverMultiBoxAdaptorWidget;
      result = t2._as(t1).delegate.get$estimatedChildCount();
      if (result == null) {
        t1 = _this._widget;
        t1.toString;
        for (t1 = t2._as(t1).delegate, lo = 0, hi = 1; lo0 = hi - 1, t1.build$2(_this, lo0) != null; lo = lo0)
          if (hi < 4503599627370496)
            hi *= 2;
          else {
            if (hi >= 9007199254740992)
              throw B.wrapException(B.FlutterError_FlutterError("Could not find the number of children in " + t1.toString$0(0) + ".\nThe childCount getter was called (implying that the delegate's builder returned null for a positive index), but even building the child with index " + hi + " (the maximum possible integer) did not return null. Consider implementing childCount to avoid the cost of searching for the final child."));
            hi = 9007199254740992;
          }
        for (; t2 = hi - lo, t2 > 1;) {
          mid = C.JSInt_methods._tdivFast$1(t2, 2) + lo;
          if (t1.build$2(_this, mid - 1) == null)
            hi = mid;
          else
            lo = mid;
        }
        result = lo;
      }
      return result;
    },
    didFinishLayout$0() {
      var t1 = this._childElements;
      t1.firstKey$0();
      t1.lastKey$0();
      t1 = this._widget;
      t1.toString;
      type$.SliverMultiBoxAdaptorWidget._as(t1);
    },
    didAdoptChild$1(child) {
      var t1 = child.parentData;
      t1.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t1).index = this._currentlyUpdatingChildIndex;
    },
    insertRenderObjectChild$2(child, slot) {
      B._asInt(slot);
      this.get$renderObject().super$ContainerRenderObjectMixin$insert(0, type$.RenderBox._as(child), this._currentBeforeChild);
    },
    moveRenderObjectChild$3(child, oldSlot, newSlot) {
      B._asInt(oldSlot);
      B._asInt(newSlot);
      this.get$renderObject().move$2$after(type$.RenderBox._as(child), this._currentBeforeChild);
    },
    removeRenderObjectChild$2(child, slot) {
      B._asInt(slot);
      this.get$renderObject().remove$1(0, type$.RenderBox._as(child));
    },
    visitChildren$1(visitor) {
      var t1, t2;
      type$.void_Function_Element._as(visitor);
      t1 = this._childElements;
      t2 = t1.$ti._eval$1("_SplayTreeValueIterable<1,2>");
      t2 = B.CastIterable_CastIterable(new A._SplayTreeValueIterable(t1, t2), t2._eval$1("Iterable.E"), type$.Element);
      C.JSArray_methods.forEach$1(B.List_List$of(t2, true, B._instanceType(t2)._eval$1("Iterable.E")), visitor);
    },
    $isRenderSliverBoxChildManager: 1
  };
  A.KeepAlive.prototype = {
    applyParentData$1(renderObject) {
      var t2,
        t1 = renderObject.parentData;
      t1.toString;
      type$.KeepAliveParentDataMixin._as(t1);
      t2 = this.keepAlive;
      if (t1.KeepAliveParentDataMixin_keepAlive !== t2) {
        t1.KeepAliveParentDataMixin_keepAlive = t2;
        if (!t2) {
          t1 = renderObject.get$parent(renderObject);
          if (t1 != null)
            t1.markNeedsLayout$0();
        }
      }
    }
  };
  A.SlottedMultiChildRenderObjectWidget.prototype = {};
  A.SlottedMultiChildRenderObjectWidgetMixin.prototype = {
    createElement$0(_) {
      var t1 = B._instanceType(this),
        t2 = type$.Element;
      return new A.SlottedRenderObjectElement(B.LinkedHashMap_LinkedHashMap$_empty(t1._eval$1("SlottedMultiChildRenderObjectWidgetMixin.0"), t2), B.LinkedHashMap_LinkedHashMap$_empty(type$.Key, t2), this, C._ElementLifecycle_0, t1._eval$1("SlottedRenderObjectElement<SlottedMultiChildRenderObjectWidgetMixin.0,SlottedMultiChildRenderObjectWidgetMixin.1>"));
    }
  };
  A.SlottedContainerRenderObjectMixin.prototype = {
    get$children(_) {
      var t1 = this.SlottedContainerRenderObjectMixin__slotToChild;
      return new B.LinkedHashMapValuesIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>"));
    },
    redepthChildren$0() {
      J.forEach$1$ax(this.get$children(this), this.get$redepthChild());
    },
    visitChildren$1(visitor) {
      type$.void_Function_RenderObject._as(visitor);
      J.forEach$1$ax(this.get$children(this), visitor);
    },
    _setChild$2(child, slot) {
      var oldChild, _this = this,
        t1 = B._instanceType(_this);
      t1._eval$1("SlottedContainerRenderObjectMixin.1?")._as(child);
      t1._eval$1("SlottedContainerRenderObjectMixin.0")._as(slot);
      t1 = _this.SlottedContainerRenderObjectMixin__slotToChild;
      oldChild = t1.$index(0, slot);
      if (oldChild != null) {
        _this.dropChild$1(oldChild);
        t1.remove$1(0, slot);
      }
      if (child != null) {
        t1.$indexSet(0, slot, child);
        _this.adoptChild$1(child);
      }
    }
  };
  A.SlottedRenderObjectElement.prototype = {
    get$renderObject() {
      return this.$ti._eval$1("SlottedContainerRenderObjectMixin<1,2>")._as(B.RenderObjectElement.prototype.get$renderObject.call(this));
    },
    visitChildren$1(visitor) {
      var t1;
      type$.void_Function_Element._as(visitor);
      t1 = this._slotToChild;
      new B.LinkedHashMapValuesIterable(t1, B._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>")).forEach$1(0, visitor);
    },
    forgetChild$1(child) {
      this._slotToChild.remove$1(0, child._slot);
      this.super$Element$forgetChild(child);
    },
    mount$2($parent, newSlot) {
      this.super$RenderObjectElement$mount($parent, newSlot);
      this._updateChildren$0();
    },
    update$1(_, newWidget) {
      this.super$RenderObjectElement$update(0, this.$ti._eval$1("SlottedMultiChildRenderObjectWidgetMixin<1,2>")._as(newWidget));
      this._updateChildren$0();
    },
    _updateChildren$0() {
      var t2, oldKeyedElements, t3, oldSlotToChild, t4, _i, slot, widget, newWidgetKey, oldSlotChild, oldKeyChild, fromElement, newChild, _this = this,
        t1 = _this._widget;
      t1.toString;
      t2 = _this.$ti;
      t2._eval$1("SlottedMultiChildRenderObjectWidgetMixin<1,2>")._as(t1);
      oldKeyedElements = _this._keyedChildren;
      t3 = type$.Element;
      _this.set$_keyedChildren(B.LinkedHashMap_LinkedHashMap$_empty(type$.Key, t3));
      oldSlotToChild = _this._slotToChild;
      t2 = t2._precomputed1;
      _this.set$_slotToChild(B.LinkedHashMap_LinkedHashMap$_empty(t2, t3));
      for (t3 = t1.get$slots(), t4 = t3.length, _i = 0; _i < t4; ++_i) {
        slot = t3[_i];
        widget = t1.childForSlot$1(slot);
        newWidgetKey = widget == null ? null : widget.key;
        oldSlotChild = oldSlotToChild.$index(0, slot);
        oldKeyChild = oldKeyedElements.$index(0, newWidgetKey);
        if (oldKeyChild != null)
          fromElement = oldSlotToChild.remove$1(0, t2._as(oldKeyChild._slot));
        else
          fromElement = (oldSlotChild == null ? null : oldSlotChild.get$widget().key) == null ? oldSlotToChild.remove$1(0, slot) : null;
        newChild = _this.updateChild$3(fromElement, widget, slot);
        if (newChild != null) {
          _this._slotToChild.$indexSet(0, slot, newChild);
          if (newWidgetKey != null)
            _this._keyedChildren.$indexSet(0, newWidgetKey, newChild);
        }
      }
      new B.LinkedHashMapValuesIterable(oldSlotToChild, B._instanceType(oldSlotToChild)._eval$1("LinkedHashMapValuesIterable<2>")).forEach$1(0, _this.get$deactivateChild());
    },
    insertRenderObjectChild$2(child, slot) {
      var t1 = this.$ti;
      t1._rest[1]._as(child);
      t1._precomputed1._as(slot);
      t1._eval$1("SlottedContainerRenderObjectMixin<1,2>")._as(B.RenderObjectElement.prototype.get$renderObject.call(this))._setChild$2(child, slot);
    },
    removeRenderObjectChild$2(child, slot) {
      var t1 = this.$ti;
      t1._rest[1]._as(child);
      t1._precomputed1._as(slot);
      t1 = t1._eval$1("SlottedContainerRenderObjectMixin<1,2>");
      if (t1._as(B.RenderObjectElement.prototype.get$renderObject.call(this)).SlottedContainerRenderObjectMixin__slotToChild.$index(0, slot) === child)
        t1._as(B.RenderObjectElement.prototype.get$renderObject.call(this))._setChild$2(null, slot);
    },
    moveRenderObjectChild$3(child, oldSlot, newSlot) {
      var t2,
        t1 = this.$ti;
      t1._rest[1]._as(child);
      t2 = t1._precomputed1;
      t2._as(oldSlot);
      t2._as(newSlot);
      t1 = t1._eval$1("SlottedContainerRenderObjectMixin<1,2>")._as(B.RenderObjectElement.prototype.get$renderObject.call(this));
      t2 = B._instanceType(t1);
      t2._eval$1("SlottedContainerRenderObjectMixin.1")._as(child);
      t2 = t2._eval$1("SlottedContainerRenderObjectMixin.0");
      t2._as(newSlot);
      t2._as(oldSlot);
      if (t1.SlottedContainerRenderObjectMixin__slotToChild.$index(0, oldSlot) === child)
        t1._setChild$2(null, oldSlot);
      t1._setChild$2(child, newSlot);
    },
    set$_slotToChild(_slotToChild) {
      this._slotToChild = this.$ti._eval$1("Map<1,Element>")._as(_slotToChild);
    },
    set$_keyedChildren(_keyedChildren) {
      this._keyedChildren = type$.Map_Key_Element._as(_keyedChildren);
    }
  };
  A._SlottedMultiChildRenderObjectWidget_RenderObjectWidget_SlottedMultiChildRenderObjectWidgetMixin.prototype = {
    updateRenderObject$2(context, renderObject) {
      return this.super$RenderObjectWidget$updateRenderObject(context, renderObject);
    }
  };
  A.MatrixTransition.prototype = {
    build$1(context) {
      var _this = this,
        t1 = type$.Animation_double._as(_this.listenable),
        t2 = _this.onTransform.call$1(t1.get$value(t1));
      t1 = t1.get$isAnimating() ? _this.filterQuality : null;
      return E.Transform$(_this.alignment, _this.child, t1, t2, true);
    }
  };
  A.ScaleTransition.prototype = {};
  A.Viewport.prototype = {
    createRenderObject$1(context) {
      var _this = this,
        t1 = _this.axisDirection,
        t2 = A.Viewport_getDefaultCrossAxisDirection(context, t1),
        t3 = _this.cacheExtent,
        t4 = B.LayerHandle$(type$.ClipRectLayer);
      if (t3 == null)
        t3 = 250;
      t4 = new A.RenderViewport(_this.anchor, t1, t2, _this.offset, t3, _this.cacheExtentStyle, _this.clipBehavior, t4, 0, null, null, new B._LayoutCacheStorage(), B.LayerHandle$(type$.ContainerLayer));
      t4.RenderObject$0();
      t4.addAll$1(0, null);
      t1 = t4.ContainerRenderObjectMixin__firstChild;
      if (t1 != null)
        t4.set$_viewport0$_center(t1);
      return t4;
    },
    updateRenderObject$2(context, renderObject) {
      var t1, _this = this;
      type$.RenderViewport._as(renderObject);
      t1 = _this.axisDirection;
      renderObject.set$axisDirection(t1);
      t1 = A.Viewport_getDefaultCrossAxisDirection(context, t1);
      renderObject.set$crossAxisDirection(t1);
      renderObject.set$anchor(_this.anchor);
      renderObject.set$offset(0, _this.offset);
      renderObject.set$cacheExtent(_this.cacheExtent);
      renderObject.set$cacheExtentStyle(_this.cacheExtentStyle);
      renderObject.set$clipBehavior(_this.clipBehavior);
    },
    createElement$0(_) {
      return new A._ViewportElement(B.HashSet_HashSet(type$.Element), this, C._ElementLifecycle_0);
    }
  };
  A._ViewportElement.prototype = {
    get$renderObject() {
      return type$.RenderViewport._as(E.MultiChildRenderObjectElement.prototype.get$renderObject.call(this));
    },
    mount$2($parent, newSlot) {
      var _this = this;
      _this._viewport$_doingMountOrUpdate = true;
      _this.super$MultiChildRenderObjectElement$mount($parent, newSlot);
      _this._updateCenter$0();
      _this._viewport$_doingMountOrUpdate = false;
    },
    update$1(_, newWidget) {
      var _this = this;
      type$.MultiChildRenderObjectWidget._as(newWidget);
      _this._viewport$_doingMountOrUpdate = true;
      _this.super$MultiChildRenderObjectElement$update(0, newWidget);
      _this._updateCenter$0();
      _this._viewport$_doingMountOrUpdate = false;
    },
    _updateCenter$0() {
      var _this = this,
        t1 = _this._widget;
      t1.toString;
      type$.Viewport._as(t1);
      t1 = type$.RenderViewport;
      if (!_this.get$children(0).get$isEmpty(0)) {
        t1._as(E.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(type$.nullable_RenderSliver._as(_this.get$children(0).get$first(0).get$renderObject()));
        _this._centerSlotIndex = 0;
      } else {
        t1._as(E.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(null);
        _this._centerSlotIndex = null;
      }
    },
    insertRenderObjectChild$2(child, slot) {
      var _this = this;
      type$.IndexedSlot_nullable_Element._as(slot);
      _this.super$MultiChildRenderObjectElement$insertRenderObjectChild(child, slot);
      if (!_this._viewport$_doingMountOrUpdate && slot.index === _this._centerSlotIndex)
        type$.RenderViewport._as(E.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(type$.nullable_RenderSliver._as(child));
    },
    moveRenderObjectChild$3(child, oldSlot, newSlot) {
      var t1 = type$.IndexedSlot_nullable_Element;
      this.super$MultiChildRenderObjectElement$moveRenderObjectChild(child, t1._as(oldSlot), t1._as(newSlot));
    },
    removeRenderObjectChild$2(child, slot) {
      var _this = this;
      _this.super$MultiChildRenderObjectElement$removeRenderObjectChild(child, slot);
      if (!_this._viewport$_doingMountOrUpdate && type$.RenderViewport._as(E.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this))._viewport0$_center === child)
        type$.RenderViewport._as(E.MultiChildRenderObjectElement.prototype.get$renderObject.call(_this)).set$center(null);
    }
  };
  A.ShrinkWrappingViewport.prototype = {
    createRenderObject$1(context) {
      var t1 = this.axisDirection,
        t2 = A.Viewport_getDefaultCrossAxisDirection(context, t1),
        t3 = B.LayerHandle$(type$.ClipRectLayer);
      t1 = new A.RenderShrinkWrappingViewport(t1, t2, this.offset, 250, G.CacheExtentStyle_0, this.clipBehavior, t3, 0, null, null, new B._LayoutCacheStorage(), B.LayerHandle$(type$.ContainerLayer));
      t1.RenderObject$0();
      t1.addAll$1(0, null);
      return t1;
    },
    updateRenderObject$2(context, renderObject) {
      var t1;
      type$.RenderShrinkWrappingViewport._as(renderObject);
      t1 = this.axisDirection;
      renderObject.set$axisDirection(t1);
      t1 = A.Viewport_getDefaultCrossAxisDirection(context, t1);
      renderObject.set$crossAxisDirection(t1);
      renderObject.set$offset(0, this.offset);
      renderObject.set$clipBehavior(this.clipBehavior);
    }
  };
  A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin.prototype = {};
  A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin.prototype = {};
  var typesOffset = hunkHelpers.updateTypes(["double(double)", "~(SliverConstraints)", "~(Selectable0)", "bool(SliverHitTestResult{crossAxisPosition!double,mainAxisPosition!double})", "~(PaintingContext,Offset)", "~({curve:Curve,descendant:RenderObject?,duration:Duration,rect:Rect?})", "bool(RenderSliver)", "bool(KeepAliveNotification)", "Widget(BuildContext,ViewportOffset)", "bool(ScrollUpdateNotification)", "~(RenderBox)", "DefaultTextStyle(BuildContext)", "int(Widget,int)", "Matrix40(double)"]);
  A.RenderSliverHelpers_hitTestBoxChild_closure.prototype = {
    call$1(result) {
      return this.child.hitTest$2$position(result, this._box_0.transformedPosition);
    },
    $signature: 138
  };
  A.RenderSliverList_performLayout_advance.prototype = {
    call$0() {
      var t4, t5, child,
        t1 = this._box_0,
        t2 = t1.child,
        t3 = t1.trailingChildWithLayout;
      if (t2 == t3)
        t1.inLayoutRange = false;
      t4 = this.$this;
      t2.toString;
      t5 = B._instanceType(t4);
      t2 = t5._eval$1("ContainerRenderObjectMixin.0")._as(t2).parentData;
      t2.toString;
      child = t1.child = t5._eval$1("ContainerRenderObjectMixin.1")._as(t2).ContainerParentDataMixin_nextSibling;
      t2 = child == null;
      if (t2)
        t1.inLayoutRange = false;
      t5 = ++t1.index;
      if (!t1.inLayoutRange) {
        if (!t2) {
          t2 = child.parentData;
          t2.toString;
          t2 = type$.SliverMultiBoxAdaptorParentData._as(t2).index;
          t2.toString;
          t5 = t2 !== t5;
          t2 = t5;
        } else
          t2 = true;
        t5 = this.childConstraints;
        if (t2) {
          child = t4.insertAndLayoutChild$3$after$parentUsesSize(t5, t3, true);
          t1.child = child;
          if (child == null)
            return false;
        } else
          child.layout$2$parentUsesSize(t5, true);
        t2 = t1.trailingChildWithLayout = t1.child;
      } else
        t2 = child;
      t3 = t2.parentData;
      t3.toString;
      type$.SliverMultiBoxAdaptorParentData._as(t3);
      t5 = t1.endScrollOffset;
      t3.layoutOffset = t5;
      t1.endScrollOffset = t5 + t4.paintExtentOf$1(t2);
      return true;
    },
    $signature: 43
  };
  A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure.prototype = {
    call$1(constraints) {
      var t1, t2, t3, t4, child;
      type$.SliverConstraints._as(constraints);
      t1 = this.$this;
      t2 = t1._keepAliveBucket;
      t3 = this.index;
      t4 = this.after;
      if (t2.containsKey$1(0, t3)) {
        child = t2.remove$1(0, t3);
        t2 = child.parentData;
        t2.toString;
        type$.SliverMultiBoxAdaptorParentData._as(t2);
        t1.dropChild$1(child);
        child.parentData = t2;
        t1.super$ContainerRenderObjectMixin$insert(0, child, t4);
        t2._keptAlive = false;
      } else
        t1._childManager.createChild$2$after(t3, t4);
    },
    $signature: typesOffset + 1
  };
  A.RenderSliverMultiBoxAdaptor_collectGarbage_closure.prototype = {
    call$1(constraints) {
      var t1, t2, t3, t4;
      type$.SliverConstraints._as(constraints);
      for (t1 = this._box_0, t2 = this.$this; t1.leadingGarbage > 0;) {
        t3 = t2.ContainerRenderObjectMixin__firstChild;
        t3.toString;
        t2._destroyOrCacheChild$1(t3);
        --t1.leadingGarbage;
      }
      for (; t1.trailingGarbage > 0;) {
        t3 = t2.ContainerRenderObjectMixin__lastChild;
        t3.toString;
        t2._destroyOrCacheChild$1(t3);
        --t1.trailingGarbage;
      }
      t1 = t2._keepAliveBucket;
      t3 = B._instanceType(t1)._eval$1("LinkedHashMapValuesIterable<2>");
      t4 = t3._eval$1("WhereIterable<Iterable.E>");
      C.JSArray_methods.forEach$1(B.List_List$of(new B.WhereIterable(new B.LinkedHashMapValuesIterable(t1, t3), t3._eval$1("bool(Iterable.E)")._as(new A.RenderSliverMultiBoxAdaptor_collectGarbage__closure()), t4), true, t4._eval$1("Iterable.E")), t2._childManager.get$removeChild());
    },
    $signature: typesOffset + 1
  };
  A.RenderSliverMultiBoxAdaptor_collectGarbage__closure.prototype = {
    call$1(child) {
      var t1 = type$.RenderBox._as(child).parentData;
      t1.toString;
      return !type$.SliverMultiBoxAdaptorParentData._as(t1).KeepAliveParentDataMixin_keepAlive;
    },
    $signature: 350
  };
  A.RenderSliverEdgeInsetsPadding_performLayout_paintOffset.prototype = {
    call$2$from$to(from, to) {
      return this.$this.calculatePaintOffset$3$from$to(this.constraints, from, to);
    },
    $signature: 139
  };
  A.RenderSliverEdgeInsetsPadding_performLayout_cacheOffset.prototype = {
    call$2$from$to(from, to) {
      return this.$this.calculateCacheOffset$3$from$to(this.constraints, from, to);
    },
    $signature: 139
  };
  A.RenderViewportBase_visitChildrenForSemantics_closure.prototype = {
    call$1(sliver) {
      var t1 = type$.RenderSliver._as(sliver)._geometry;
      return t1.visible || t1.cacheExtent > 0;
    },
    $signature: typesOffset + 6
  };
  A.RenderViewportBase_hitTestChildren_closure.prototype = {
    call$1(result) {
      var _this = this,
        t1 = _this.child,
        t2 = _this._box_0,
        t3 = _this.$this.computeChildMainAxisPosition$2(t1, t2.mainAxisPosition);
      return t1.hitTest$3$crossAxisPosition$mainAxisPosition(_this.sliverResult, t2.crossAxisPosition, t3);
    },
    $signature: 138
  };
  A._AutomaticKeepAliveState__addClient_closure.prototype = {
    call$1(timeStamp) {
      var t1, childElement;
      type$.Duration._as(timeStamp);
      t1 = this.$this;
      if (t1._framework$_element == null)
        return;
      childElement = t1._getChildElement$0();
      childElement.toString;
      t1._updateParentDataOfChild$1(childElement);
    },
    $signature: 2
  };
  A._AutomaticKeepAliveState__getChildElement_closure.prototype = {
    call$1(child) {
      this._box_0.childElement = child;
    },
    $signature: 11
  };
  A._AutomaticKeepAliveState__createCallback_closure.prototype = {
    call$0() {
      var t1 = this.$this,
        t2 = this.handle;
      t1._automatic_keep_alive$_handles.remove$1(0, t2);
      t2.removeListener$1(0, this.callback._readLocal$0());
      if (t1._automatic_keep_alive$_handles.__js_helper$_length === 0)
        if ($.SchedulerBinding__instance.SchedulerBinding__schedulerPhase.index < 3)
          t1.setState$1(new A._AutomaticKeepAliveState__createCallback__closure(t1));
        else {
          t1._keepingAlive = false;
          B.scheduleMicrotask(new A._AutomaticKeepAliveState__createCallback__closure0(t1));
        }
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback__closure.prototype = {
    call$0() {
      this.$this._keepingAlive = false;
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback__closure0.prototype = {
    call$0() {
      var t1 = this.$this;
      if (t1._framework$_element != null && t1._automatic_keep_alive$_handles.__js_helper$_length === 0)
        t1.setState$1(new A._AutomaticKeepAliveState__createCallback___closure());
    },
    $signature: 0
  };
  A._AutomaticKeepAliveState__createCallback___closure.prototype = {
    call$0() {
    },
    $signature: 0
  };
  A._SelectionKeepAliveState_listensTo_closure.prototype = {
    call$0() {
      var t1 = this.selectable,
        t2 = this.$this;
      if (t1.get$value(t1).status !== M.SelectionStatus_2)
        t2._updateSelectablesWithSelections$2$add(t1, true);
      else
        t2._updateSelectablesWithSelections$2$add(t1, false);
    },
    $signature: 0
  };
  A.ScrollView_build_closure.prototype = {
    call$2(context, offset) {
      return this.$this.buildViewport$4(type$.BuildContext._as(context), type$.ViewportOffset._as(offset), this.axisDirection, this.slivers);
    },
    $signature: typesOffset + 8
  };
  A.ScrollView_build_closure0.prototype = {
    call$1(notification) {
      var currentScope, t1;
      type$.ScrollUpdateNotification._as(notification);
      currentScope = B.FocusScope_of(this.context);
      if (notification.dragDetails != null && !currentScope.get$hasPrimaryFocus() && currentScope.get$hasFocus()) {
        t1 = $.WidgetsBinding__instance.WidgetsBinding__buildOwner.focusManager._primaryFocus;
        if (t1 != null)
          t1.unfocus$0();
      }
      return false;
    },
    $signature: typesOffset + 9
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_processElement.prototype = {
    call$1(index) {
      var newChild, parentData, t1, t2, t3, _this = this;
      B._asInt(index);
      t1 = _this.$this;
      t1._currentlyUpdatingChildIndex = index;
      t2 = t1._childElements;
      if (t2.$index(0, index) != null && !J.$eq$(t2.$index(0, index), _this.newChildren.$index(0, index))) {
        t2.$indexSet(0, index, t1.updateChild$3(t2.$index(0, index), null, index));
        _this._box_0.childrenUpdated = true;
      }
      newChild = t1.updateChild$3(_this.newChildren.$index(0, index), _this.adaptorWidget.delegate.build$2(t1, index), index);
      if (newChild != null) {
        t3 = _this._box_0;
        t3.childrenUpdated = t3.childrenUpdated || !J.$eq$(t2.$index(0, index), newChild);
        t2.$indexSet(0, index, newChild);
        t2 = newChild.get$renderObject().parentData;
        t2.toString;
        parentData = type$.SliverMultiBoxAdaptorParentData._as(t2);
        if (index === 0)
          parentData.layoutOffset = 0;
        else {
          t2 = _this.indexToLayoutOffset;
          if (t2.containsKey$1(0, index))
            parentData.layoutOffset = t2.$index(0, index);
        }
        if (!parentData._keptAlive)
          t1._currentBeforeChild = type$.nullable_RenderBox._as(newChild.get$renderObject());
      } else {
        _this._box_0.childrenUpdated = true;
        t2.remove$1(0, index);
      }
    },
    $signature: 22
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_closure.prototype = {
    call$0() {
      return null;
    },
    $signature: 3
  };
  A.SliverMultiBoxAdaptorElement_performRebuild_closure0.prototype = {
    call$0() {
      return this.$this._childElements.$index(0, this.index);
    },
    $signature: 282
  };
  A.SliverMultiBoxAdaptorElement_createChild_closure.prototype = {
    call$0() {
      var newChild, adaptorWidget, t2, t3, _this = this,
        t1 = _this.$this;
      t1._currentBeforeChild = _this.after == null ? null : type$.nullable_RenderBox._as(t1._childElements.$index(0, _this.index - 1).get$renderObject());
      newChild = null;
      try {
        t2 = t1._widget;
        t2.toString;
        t3 = type$.SliverMultiBoxAdaptorWidget;
        adaptorWidget = t3._as(t2);
        t2 = t1._currentlyUpdatingChildIndex = _this.index;
        newChild = t1.updateChild$3(t1._childElements.$index(0, t2), t3._as(adaptorWidget).delegate.build$2(t1, t2), t2);
      } finally {
        t1._currentlyUpdatingChildIndex = null;
      }
      t2 = _this.index;
      t1 = t1._childElements;
      if (newChild != null)
        t1.$indexSet(0, t2, newChild);
      else
        t1.remove$1(0, t2);
    },
    $signature: 0
  };
  A.SliverMultiBoxAdaptorElement_removeChild_closure.prototype = {
    call$0() {
      var t1, t2, _this = this;
      try {
        t1 = _this.$this;
        t2 = t1._currentlyUpdatingChildIndex = _this.index;
        t1.updateChild$3(t1._childElements.$index(0, t2), null, t2);
      } finally {
        _this.$this._currentlyUpdatingChildIndex = null;
      }
      _this.$this._childElements.remove$1(0, _this.index);
    },
    $signature: 0
  };
  A.DefaultTextStyle_merge_closure.prototype = {
    call$1(context) {
      var t1, t2, t3, t4, t5, t6, _this = this,
        $parent = type$.BuildContext._as(context).dependOnInheritedWidgetOfExactType$1$0(type$.DefaultTextStyle);
      if ($parent == null)
        $parent = Q.DefaultTextStyle_4Wa;
      t1 = $parent.style.merge$1(_this.style);
      t2 = _this.textAlign;
      if (t2 == null)
        t2 = $parent.textAlign;
      t3 = _this.softWrap;
      if (t3 == null)
        t3 = $parent.softWrap;
      t4 = _this.overflow;
      if (t4 == null)
        t4 = $parent.overflow;
      t5 = _this.maxLines;
      if (t5 == null)
        t5 = $parent.maxLines;
      t6 = _this.textHeightBehavior;
      if (t6 == null)
        t6 = $parent.textHeightBehavior;
      return E.DefaultTextStyle$(_this.child, _this.key, t5, t4, t3, t1, t2, t6, $parent.textWidthBasis);
    },
    $signature: typesOffset + 11
  };
  (function aliases() {
    var _ = A.SliverLogicalParentData.prototype;
    _.super$SliverLogicalParentData$toString = _.toString$0;
    _ = A.SliverMultiBoxAdaptorParentData.prototype;
    _.super$SliverMultiBoxAdaptorParentData$toString = _.toString$0;
    _ = A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin.prototype;
    _.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$attach = _.attach$1;
    _.super$_RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin$detach = _.detach$0;
    _ = A.RenderSliverEdgeInsetsPadding.prototype;
    _.super$RenderSliverEdgeInsetsPadding$performLayout = _.performLayout$0;
    _ = A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin.prototype;
    _.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$attach = _.attach$1;
    _.super$_RenderViewportBase_RenderBox_ContainerRenderObjectMixin$detach = _.detach$0;
    _ = A.SliverMultiBoxAdaptorWidget.prototype;
    _.super$SliverMultiBoxAdaptorWidget$estimateMaxScrollOffset = _.estimateMaxScrollOffset$5;
  })();
  (function installTearOffs() {
    var _instance = hunkHelpers.installInstanceTearOff,
      _instance_1_u = hunkHelpers._instance_1u,
      _instance_2_u = hunkHelpers._instance_2u,
      _static_2 = hunkHelpers._static_2,
      _instance_1_i = hunkHelpers._instance_1i,
      _static_1 = hunkHelpers._static_1;
    _instance(A.RenderSliver.prototype, "get$hitTest", 0, 1, null, ["call$3$crossAxisPosition$mainAxisPosition"], ["hitTest$3$crossAxisPosition$mainAxisPosition"], 3, 0, 0);
    var _;
    _instance_1_u(_ = A.RenderViewportBase.prototype, "get$computeMinIntrinsicWidth", "computeMinIntrinsicWidth$1", 0);
    _instance_1_u(_, "get$computeMaxIntrinsicWidth", "computeMaxIntrinsicWidth$1", 0);
    _instance_1_u(_, "get$computeMinIntrinsicHeight", "computeMinIntrinsicHeight$1", 0);
    _instance_1_u(_, "get$computeMaxIntrinsicHeight", "computeMaxIntrinsicHeight$1", 0);
    _instance_2_u(_, "get$_paintContents", "_paintContents$2", 4);
    _instance(_, "get$showOnScreen", 0, 0, null, ["call$4$curve$descendant$duration$rect", "call$0", "call$1$rect", "call$3$curve$duration$rect", "call$2$descendant$rect"], ["showOnScreen$4$curve$descendant$duration$rect", "showOnScreen$0", "showOnScreen$1$rect", "showOnScreen$3$curve$duration$rect", "showOnScreen$2$descendant$rect"], 5, 0, 0);
    _instance_1_u(A._AutomaticKeepAliveState.prototype, "get$_addClient", "_addClient$1", 7);
    _static_2(A, "scroll_delegate___kDefaultSemanticIndexCallback$closure", "_kDefaultSemanticIndexCallback", 12);
    _instance_1_i(_ = A._SelectionKeepAliveState.prototype, "get$add", "add$1", 2);
    _instance_1_i(_, "get$remove", "remove$1", 2);
    _instance_1_u(A.SliverMultiBoxAdaptorElement.prototype, "get$removeChild", "removeChild$1", 10);
    _static_1(A, "transitions_ScaleTransition__handleScaleMatrix$closure", "ScaleTransition__handleScaleMatrix", 13);
  })();
  (function inheritance() {
    var _mixin = hunkHelpers.mixin,
      _mixinHard = hunkHelpers.mixinHard,
      _inherit = hunkHelpers.inherit,
      _inheritMany = hunkHelpers.inheritMany;
    _inherit(A._SplayTreeMapNode, F._SplayTreeNode);
    _inherit(A._SplayTreeMap__SplayTree_MapMixin, F._SplayTree);
    _inherit(A.SplayTreeMap, A._SplayTreeMap__SplayTree_MapMixin);
    _inheritMany(B.EfficientLengthIterable, [A._SplayTreeKeyIterable, A._SplayTreeValueIterable, A._SplayTreeMapEntryIterable]);
    _inheritMany(F._SplayTreeIterator, [A._SplayTreeValueIterator, A._SplayTreeMapEntryIterator]);
    _inherit(A.IconButtonTheme, E.InheritedTheme);
    _inherit(A.RenderIndexedSemantics, B.RenderProxyBox);
    _inherit(A.SliverConstraints, B.Constraints);
    _inheritMany(B.Object, [A._SliverGeometry_Object_Diagnosticable, A.RenderSliverHelpers, A.KeepAliveParentDataMixin, A.RenderSliverWithKeepAliveMixin, A.SliverChildDelegate, A.SlottedMultiChildRenderObjectWidgetMixin, A.SlottedContainerRenderObjectMixin]);
    _inherit(A.SliverGeometry, A._SliverGeometry_Object_Diagnosticable);
    _inherit(A.SliverHitTestResult, B.HitTestResult);
    _inherit(A.SliverHitTestEntry, B.HitTestEntry);
    _inheritMany(B.ParentData, [A.SliverLogicalParentData, A.SliverPhysicalParentData]);
    _inheritMany(A.SliverLogicalParentData, [A._SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin, A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin]);
    _inherit(A.SliverLogicalContainerParentData, A._SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin);
    _inherit(A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin, A.SliverPhysicalParentData);
    _inherit(A.SliverPhysicalContainerParentData, A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin);
    _inherit(A.RenderSliver, B.RenderObject);
    _inheritMany(B.Closure, [A.RenderSliverHelpers_hitTestBoxChild_closure, A.RenderSliverMultiBoxAdaptor__createOrObtainChild_closure, A.RenderSliverMultiBoxAdaptor_collectGarbage_closure, A.RenderSliverMultiBoxAdaptor_collectGarbage__closure, A.RenderSliverEdgeInsetsPadding_performLayout_paintOffset, A.RenderSliverEdgeInsetsPadding_performLayout_cacheOffset, A.RenderViewportBase_visitChildrenForSemantics_closure, A.RenderViewportBase_hitTestChildren_closure, A._AutomaticKeepAliveState__addClient_closure, A._AutomaticKeepAliveState__getChildElement_closure, A.ScrollView_build_closure0, A.SliverMultiBoxAdaptorElement_performRebuild_processElement, A.DefaultTextStyle_merge_closure]);
    _inheritMany(A.RenderSliver, [A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin, A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin]);
    _inherit(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin);
    _inherit(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers);
    _inherit(A.RenderSliverMultiBoxAdaptor, A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin);
    _inherit(A.RenderSliverList, A.RenderSliverMultiBoxAdaptor);
    _inheritMany(B.Closure0Args, [A.RenderSliverList_performLayout_advance, A._AutomaticKeepAliveState__createCallback_closure, A._AutomaticKeepAliveState__createCallback__closure, A._AutomaticKeepAliveState__createCallback__closure0, A._AutomaticKeepAliveState__createCallback___closure, A._SelectionKeepAliveState_listensTo_closure, A.SliverMultiBoxAdaptorElement_performRebuild_closure, A.SliverMultiBoxAdaptorElement_performRebuild_closure0, A.SliverMultiBoxAdaptorElement_createChild_closure, A.SliverMultiBoxAdaptorElement_removeChild_closure]);
    _inherit(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin, A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin);
    _inherit(A.SliverMultiBoxAdaptorParentData, A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin);
    _inherit(A.RenderSliverEdgeInsetsPadding, A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin);
    _inherit(A.RenderSliverPadding, A.RenderSliverEdgeInsetsPadding);
    _inherit(A.CacheExtentStyle, B._Enum);
    _inherit(A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin, B.RenderBox);
    _inherit(A.RenderViewportBase, A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin);
    _inheritMany(A.RenderViewportBase, [A.RenderViewport, A.RenderShrinkWrappingViewport]);
    _inheritMany(B.StatefulWidget, [A.AutomaticKeepAlive, A._SelectionKeepAlive]);
    _inheritMany(B.State, [A._AutomaticKeepAliveState, A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin]);
    _inheritMany(B.SingleChildRenderObjectWidget, [A.SliverPadding, A.IndexedSemantics]);
    _inherit(A._SaltedValueKey, P.ValueKey);
    _inherit(A.SliverChildBuilderDelegate, A.SliverChildDelegate);
    _inherit(A._SelectionKeepAliveState, A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin);
    _inherit(A.AlwaysScrollableScrollPhysics, D.ScrollPhysics);
    _inherit(A.ScrollView, B.StatelessWidget);
    _inherit(A.ScrollView_build_closure, B.Closure2Args);
    _inheritMany(B.RenderObjectWidget, [A.SliverWithKeepAliveWidget, A._SlottedMultiChildRenderObjectWidget_RenderObjectWidget_SlottedMultiChildRenderObjectWidgetMixin]);
    _inherit(A.SliverMultiBoxAdaptorWidget, A.SliverWithKeepAliveWidget);
    _inherit(A.SliverList, A.SliverMultiBoxAdaptorWidget);
    _inheritMany(B.RenderObjectElement, [A.SliverMultiBoxAdaptorElement, A.SlottedRenderObjectElement]);
    _inherit(A.KeepAlive, E.ParentDataWidget);
    _inherit(A.SlottedMultiChildRenderObjectWidget, A._SlottedMultiChildRenderObjectWidget_RenderObjectWidget_SlottedMultiChildRenderObjectWidgetMixin);
    _inherit(A.MatrixTransition, I.AnimatedWidget);
    _inherit(A.ScaleTransition, A.MatrixTransition);
    _inheritMany(E.MultiChildRenderObjectWidget, [A.Viewport, A.ShrinkWrappingViewport]);
    _inherit(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin, E.MultiChildRenderObjectElement);
    _inherit(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin, A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin);
    _inherit(A._ViewportElement, A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin);
    _mixin(A._SplayTreeMap__SplayTree_MapMixin, B.MapBase);
    _mixin(A._SliverGeometry_Object_Diagnosticable, B.Diagnosticable);
    _mixinHard(A._SliverLogicalContainerParentData_SliverLogicalParentData_ContainerParentDataMixin, E.ContainerParentDataMixin);
    _mixinHard(A._SliverPhysicalContainerParentData_SliverPhysicalParentData_ContainerParentDataMixin, E.ContainerParentDataMixin);
    _mixinHard(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin, E.ContainerRenderObjectMixin);
    _mixin(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers, A.RenderSliverHelpers);
    _mixin(A._RenderSliverMultiBoxAdaptor_RenderSliver_ContainerRenderObjectMixin_RenderSliverHelpers_RenderSliverWithKeepAliveMixin, A.RenderSliverWithKeepAliveMixin);
    _mixinHard(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin, E.ContainerParentDataMixin);
    _mixin(A._SliverMultiBoxAdaptorParentData_SliverLogicalParentData_ContainerParentDataMixin_KeepAliveParentDataMixin, A.KeepAliveParentDataMixin);
    _mixinHard(A._RenderSliverEdgeInsetsPadding_RenderSliver_RenderObjectWithChildMixin, B.RenderObjectWithChildMixin);
    _mixinHard(A._RenderViewportBase_RenderBox_ContainerRenderObjectMixin, E.ContainerRenderObjectMixin);
    _mixinHard(A.__SelectionKeepAliveState_State_AutomaticKeepAliveClientMixin, O.AutomaticKeepAliveClientMixin);
    _mixinHard(A._SlottedMultiChildRenderObjectWidget_RenderObjectWidget_SlottedMultiChildRenderObjectWidgetMixin, A.SlottedMultiChildRenderObjectWidgetMixin);
    _mixin(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin, D.NotifiableElementMixin);
    _mixin(A.__ViewportElement_MultiChildRenderObjectElement_NotifiableElementMixin_ViewportElementMixin, F.ViewportElementMixin);
  })();
  B._Universe_addRules(init.typeUniverse, JSON.parse('{"_SplayTreeMapNode":{"_SplayTreeNode":["1","_SplayTreeMapNode<1,2>"],"_SplayTreeNode.1":"_SplayTreeMapNode<1,2>","_SplayTreeNode.K":"1"},"SplayTreeMap":{"MapBase":["1","2"],"_SplayTree":["1","_SplayTreeMapNode<1,2>"],"Map":["1","2"],"MapBase.K":"1","MapBase.V":"2","_SplayTree.K":"1","_SplayTree.1":"_SplayTreeMapNode<1,2>"},"_SplayTreeKeyIterable":{"EfficientLengthIterable":["1"],"Iterable":["1"],"Iterable.E":"1"},"_SplayTreeValueIterable":{"EfficientLengthIterable":["2"],"Iterable":["2"],"Iterable.E":"2"},"_SplayTreeMapEntryIterable":{"EfficientLengthIterable":["MapEntry<1,2>"],"Iterable":["MapEntry<1,2>"],"Iterable.E":"MapEntry<1,2>"},"_SplayTreeValueIterator":{"_SplayTreeIterator":["1","_SplayTreeMapNode<1,2>","2"],"Iterator":["2"],"_SplayTreeIterator.K":"1","_SplayTreeIterator.T":"2","_SplayTreeIterator.1":"_SplayTreeMapNode<1,2>"},"_SplayTreeMapEntryIterator":{"_SplayTreeIterator":["1","_SplayTreeMapNode<1,2>","MapEntry<1,2>"],"Iterator":["MapEntry<1,2>"],"_SplayTreeIterator.K":"1","_SplayTreeIterator.T":"MapEntry<1,2>","_SplayTreeIterator.1":"_SplayTreeMapNode<1,2>"},"IconButtonTheme":{"InheritedTheme":[],"InheritedWidget":[],"ProxyWidget":[],"Widget":[],"DiagnosticableTree":[]},"RenderIndexedSemantics":{"RenderBox":[],"RenderObjectWithChildMixin":["RenderBox"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"RenderObjectWithChildMixin.0":"RenderBox"},"SliverConstraints":{"Constraints":[]},"SliverHitTestResult":{"HitTestResult":[]},"SliverLogicalContainerParentData":{"SliverLogicalParentData":[],"ContainerParentDataMixin":["RenderSliver"],"ParentData":[],"ContainerParentDataMixin.0":"RenderSliver"},"SliverPhysicalContainerParentData":{"SliverPhysicalParentData":[],"ContainerParentDataMixin":["RenderSliver"],"ParentData":[],"ContainerParentDataMixin.0":"RenderSliver"},"RenderSliver":{"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"SliverHitTestEntry":{"HitTestEntry":["RenderSliver"],"HitTestEntry.T":"RenderSliver"},"SliverLogicalParentData":{"ParentData":[]},"SliverPhysicalParentData":{"ParentData":[]},"RenderSliverList":{"RenderSliverMultiBoxAdaptor":[],"RenderSliver":[],"ContainerRenderObjectMixin":["RenderBox","SliverMultiBoxAdaptorParentData"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverMultiBoxAdaptorParentData","ContainerRenderObjectMixin.0":"RenderBox"},"KeepAliveParentDataMixin":{"ParentData":[]},"SliverMultiBoxAdaptorParentData":{"SliverLogicalParentData":[],"ContainerParentDataMixin":["RenderBox"],"KeepAliveParentDataMixin":[],"ParentData":[],"ContainerParentDataMixin.0":"RenderBox"},"RenderSliverMultiBoxAdaptor":{"RenderSliver":[],"ContainerRenderObjectMixin":["RenderBox","SliverMultiBoxAdaptorParentData"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"RenderSliverEdgeInsetsPadding":{"RenderSliver":[],"RenderObjectWithChildMixin":["RenderSliver"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"RenderSliverPadding":{"RenderSliver":[],"RenderObjectWithChildMixin":["RenderSliver"],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"RenderObjectWithChildMixin.0":"RenderSliver"},"CacheExtentStyle":{"Enum":[]},"RenderViewportBase":{"_RenderViewportBase_RenderBox_ContainerRenderObjectMixin":["1"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderSliver","1"],"RenderAbstractViewport":[],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[]},"RenderViewport":{"RenderViewportBase":["SliverPhysicalContainerParentData"],"_RenderViewportBase_RenderBox_ContainerRenderObjectMixin":["SliverPhysicalContainerParentData"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderSliver","SliverPhysicalContainerParentData"],"RenderAbstractViewport":[],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverPhysicalContainerParentData","ContainerRenderObjectMixin.0":"RenderSliver","_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0":"SliverPhysicalContainerParentData"},"RenderShrinkWrappingViewport":{"RenderViewportBase":["SliverLogicalContainerParentData"],"_RenderViewportBase_RenderBox_ContainerRenderObjectMixin":["SliverLogicalContainerParentData"],"RenderBox":[],"ContainerRenderObjectMixin":["RenderSliver","SliverLogicalContainerParentData"],"RenderAbstractViewport":[],"RenderObject":[],"DiagnosticableTree":[],"HitTestTarget":[],"ContainerRenderObjectMixin.1":"SliverLogicalContainerParentData","ContainerRenderObjectMixin.0":"RenderSliver","_RenderViewportBase_RenderBox_ContainerRenderObjectMixin.0":"SliverLogicalContainerParentData"},"AutomaticKeepAlive":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_AutomaticKeepAliveState":{"State":["AutomaticKeepAlive"],"State.T":"AutomaticKeepAlive"},"SliverPadding":{"SingleChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"IndexedSemantics":{"SingleChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_SelectionKeepAlive":{"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"_SaltedValueKey":{"ValueKey":["Key"],"LocalKey":[],"Key":[],"ValueKey.T":"Key"},"SliverChildBuilderDelegate":{"SliverChildDelegate":[]},"_SelectionKeepAliveState":{"State":["_SelectionKeepAlive"],"SelectionRegistrar":[],"State.T":"_SelectionKeepAlive"},"AlwaysScrollableScrollPhysics":{"ScrollPhysics":[]},"ScrollView":{"StatelessWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverWithKeepAliveWidget":{"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverMultiBoxAdaptorWidget":{"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverList":{"SliverMultiBoxAdaptorWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SliverMultiBoxAdaptorElement":{"RenderObjectElement":[],"Element":[],"DiagnosticableTree":[],"BuildContext":[],"RenderSliverBoxChildManager":[]},"KeepAlive":{"ParentDataWidget":["KeepAliveParentDataMixin"],"ProxyWidget":[],"Widget":[],"DiagnosticableTree":[],"ParentDataWidget.T":"KeepAliveParentDataMixin"},"SlottedMultiChildRenderObjectWidget":{"SlottedMultiChildRenderObjectWidgetMixin":["1","2"],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"SlottedRenderObjectElement":{"RenderObjectElement":[],"Element":[],"DiagnosticableTree":[],"BuildContext":[]},"MatrixTransition":{"AnimatedWidget":[],"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"ScaleTransition":{"AnimatedWidget":[],"StatefulWidget":[],"Widget":[],"DiagnosticableTree":[]},"Viewport":{"MultiChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]},"_ViewportElement":{"RenderObjectElement":[],"NotifiableElementMixin":[],"Element":[],"DiagnosticableTree":[],"BuildContext":[]},"ShrinkWrappingViewport":{"MultiChildRenderObjectWidget":[],"RenderObjectWidget":[],"Widget":[],"DiagnosticableTree":[]}}'));
  B._Universe_addErasedTypes(init.typeUniverse, JSON.parse('{"_SplayTreeMap__SplayTree_MapMixin":2,"SlottedMultiChildRenderObjectWidget":2,"_SlottedMultiChildRenderObjectWidget_RenderObjectWidget_SlottedMultiChildRenderObjectWidgetMixin":2}'));
  var type$ = (function rtii() {
    var findType = B.findType;
    return {
      Animation_double: findType("Animation<double>"),
      AutomaticKeepAlive: findType("AutomaticKeepAlive"),
      BoxConstraints: findType("BoxConstraints"),
      BuildContext: findType("BuildContext"),
      ClipRectLayer: findType("ClipRectLayer"),
      ContainerLayer: findType("ContainerLayer0"),
      Curve: findType("Curve"),
      DefaultTextStyle: findType("DefaultTextStyle"),
      Directionality: findType("Directionality"),
      Duration: findType("Duration"),
      Element: findType("Element"),
      IconButtonTheme: findType("IconButtonTheme"),
      IndexedSlot_nullable_Element: findType("IndexedSlot<Element?>"),
      JSArray_RenderSliver: findType("JSArray<RenderSliver>"),
      JSArray_String: findType("JSArray<String>"),
      KeepAliveNotification: findType("KeepAliveNotification"),
      KeepAliveParentDataMixin: findType("KeepAliveParentDataMixin"),
      Key: findType("Key"),
      List_String: findType("List<String>"),
      List_Widget: findType("List<Widget>"),
      Listenable: findType("Listenable"),
      Map_Key_Element: findType("Map<Key,Element>"),
      MultiChildRenderObjectWidget: findType("MultiChildRenderObjectWidget"),
      NotificationListener_KeepAliveNotification: findType("NotificationListener<KeepAliveNotification>"),
      NotificationListener_ScrollUpdateNotification: findType("NotificationListener<ScrollUpdateNotification>"),
      Offset: findType("Offset"),
      ParentDataElement_KeepAliveParentDataMixin: findType("ParentDataElement<KeepAliveParentDataMixin>"),
      ParentDataWidget_KeepAliveParentDataMixin: findType("ParentDataWidget<KeepAliveParentDataMixin>"),
      RenderBox: findType("RenderBox"),
      RenderIndexedSemantics: findType("RenderIndexedSemantics"),
      RenderObject: findType("RenderObject"),
      RenderShrinkWrappingViewport: findType("RenderShrinkWrappingViewport"),
      RenderSliver: findType("RenderSliver"),
      RenderSliverMultiBoxAdaptor: findType("RenderSliverMultiBoxAdaptor"),
      RenderSliverPadding: findType("RenderSliverPadding"),
      RenderViewport: findType("RenderViewport"),
      ScrollUpdateNotification: findType("ScrollUpdateNotification"),
      Selectable: findType("Selectable0"),
      Size: findType("Size"),
      SliverChildBuilderDelegate: findType("SliverChildBuilderDelegate"),
      SliverConstraints: findType("SliverConstraints"),
      SliverHitTestEntry: findType("SliverHitTestEntry"),
      SliverLogicalParentData: findType("SliverLogicalParentData"),
      SliverMultiBoxAdaptorElement: findType("SliverMultiBoxAdaptorElement"),
      SliverMultiBoxAdaptorParentData: findType("SliverMultiBoxAdaptorParentData"),
      SliverMultiBoxAdaptorWidget: findType("SliverMultiBoxAdaptorWidget"),
      SliverPhysicalParentData: findType("SliverPhysicalParentData"),
      Viewport: findType("Viewport"),
      ViewportOffset: findType("ViewportOffset"),
      bool_Function_SliverHitTestResult_$named_$req_crossAxisPosition_double_and_$req_mainAxisPosition_double: findType("bool(SliverHitTestResult{crossAxisPosition!double,mainAxisPosition!double})"),
      double: findType("double"),
      int: findType("int"),
      nullable_Element: findType("Element?"),
      nullable_Map_of_Listenable_and_void_Function: findType("Map<Listenable,~()>?"),
      nullable_Map_of_Selectable_and_void_Function: findType("Map<Selectable0,~()>?"),
      nullable_ParentDataElement_KeepAliveParentDataMixin: findType("ParentDataElement<KeepAliveParentDataMixin>?"),
      nullable_Rect: findType("Rect?"),
      nullable_RenderBox: findType("RenderBox?"),
      nullable_RenderObject: findType("RenderObject?"),
      nullable_RenderSliver: findType("RenderSliver?"),
      nullable_RenderSliver_Function_RenderSliver: findType("RenderSliver?(RenderSliver)"),
      nullable_Set_Selectable: findType("Set<Selectable0>?"),
      nullable_SliverMultiBoxAdaptorParentData: findType("SliverMultiBoxAdaptorParentData?"),
      void_Function: findType("~()"),
      void_Function_Duration: findType("~(Duration)"),
      void_Function_Element: findType("~(Element)"),
      void_Function_RenderObject: findType("~(RenderObject)")
    };
  })();
  (function constants() {
    G.AlwaysScrollableScrollPhysics_null = new A.AlwaysScrollableScrollPhysics(null);
    G.CacheExtentStyle_0 = new A.CacheExtentStyle(0, "pixel");
    G.CacheExtentStyle_1 = new A.CacheExtentStyle(1, "viewport");
    G.SliverGeometry_QEo = new A.SliverGeometry(0, 0, 0, 0, 0, 0, false, false, null, 0);
  })();
};
;
((d, h) => {
  d[h] = d.current;
  d.eventLog.push({p: "main.dart.js_97", e: "endPart", h: h});
})($__dart_deferred_initializers__, "lj4cyWUqRjabQQezeuL4mNEJM2Y=");
;
//# sourceMappingURL=main.dart.js_97.part.js.map
